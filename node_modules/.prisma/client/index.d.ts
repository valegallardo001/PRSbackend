
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model TraitCategory
 * 
 */
export type TraitCategory = $Result.DefaultSelection<Prisma.$TraitCategoryPayload>
/**
 * Model Trait
 * 
 */
export type Trait = $Result.DefaultSelection<Prisma.$TraitPayload>
/**
 * Model TraitToTraitCategory
 * 
 */
export type TraitToTraitCategory = $Result.DefaultSelection<Prisma.$TraitToTraitCategoryPayload>
/**
 * Model PRSModel
 * 
 */
export type PRSModel = $Result.DefaultSelection<Prisma.$PRSModelPayload>
/**
 * Model PRSModelToTrait
 * 
 */
export type PRSModelToTrait = $Result.DefaultSelection<Prisma.$PRSModelToTraitPayload>
/**
 * Model ScoringFile
 * 
 */
export type ScoringFile = $Result.DefaultSelection<Prisma.$ScoringFilePayload>
/**
 * Model Publication
 * 
 */
export type Publication = $Result.DefaultSelection<Prisma.$PublicationPayload>
/**
 * Model ModelEvaluation
 * 
 */
export type ModelEvaluation = $Result.DefaultSelection<Prisma.$ModelEvaluationPayload>
/**
 * Model PerformanceMetricEvaluation
 * 
 */
export type PerformanceMetricEvaluation = $Result.DefaultSelection<Prisma.$PerformanceMetricEvaluationPayload>
/**
 * Model PerformanceMetric
 * 
 */
export type PerformanceMetric = $Result.DefaultSelection<Prisma.$PerformanceMetricPayload>
/**
 * Model EvaluationPopulationSample
 * 
 */
export type EvaluationPopulationSample = $Result.DefaultSelection<Prisma.$EvaluationPopulationSamplePayload>
/**
 * Model BroadAncestryCategory
 * 
 */
export type BroadAncestryCategory = $Result.DefaultSelection<Prisma.$BroadAncestryCategoryPayload>
/**
 * Model BroadAncestryInModel
 * 
 */
export type BroadAncestryInModel = $Result.DefaultSelection<Prisma.$BroadAncestryInModelPayload>
/**
 * Model DevelopmentPopulationSample
 * 
 */
export type DevelopmentPopulationSample = $Result.DefaultSelection<Prisma.$DevelopmentPopulationSamplePayload>
/**
 * Model BroadAncestryInRefPop
 * 
 */
export type BroadAncestryInRefPop = $Result.DefaultSelection<Prisma.$BroadAncestryInRefPopPayload>
/**
 * Model ReferencePopulation
 * 
 */
export type ReferencePopulation = $Result.DefaultSelection<Prisma.$ReferencePopulationPayload>
/**
 * Model PRSAnalysis
 * 
 */
export type PRSAnalysis = $Result.DefaultSelection<Prisma.$PRSAnalysisPayload>
/**
 * Model PrioritizedModel
 * 
 */
export type PrioritizedModel = $Result.DefaultSelection<Prisma.$PrioritizedModelPayload>
/**
 * Model PRSResult
 * 
 */
export type PRSResult = $Result.DefaultSelection<Prisma.$PRSResultPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AncestryAdjustmentType: {
  CONTINUOUS: 'CONTINUOUS',
  DISCONTINUOUS: 'DISCONTINUOUS'
};

export type AncestryAdjustmentType = (typeof AncestryAdjustmentType)[keyof typeof AncestryAdjustmentType]


export const DevelopmentRoleType: {
  BASE: 'BASE',
  TUNING: 'TUNING'
};

export type DevelopmentRoleType = (typeof DevelopmentRoleType)[keyof typeof DevelopmentRoleType]


export const PerformanceMetricType: {
  RISK_ASSOCIATION: 'RISK_ASSOCIATION',
  DISCRIMINATING_POWER: 'DISCRIMINATING_POWER',
  OTHER: 'OTHER'
};

export type PerformanceMetricType = (typeof PerformanceMetricType)[keyof typeof PerformanceMetricType]


export const AssemblyType: {
  GRCh37: 'GRCh37',
  GRCh38: 'GRCh38'
};

export type AssemblyType = (typeof AssemblyType)[keyof typeof AssemblyType]

}

export type AncestryAdjustmentType = $Enums.AncestryAdjustmentType

export const AncestryAdjustmentType: typeof $Enums.AncestryAdjustmentType

export type DevelopmentRoleType = $Enums.DevelopmentRoleType

export const DevelopmentRoleType: typeof $Enums.DevelopmentRoleType

export type PerformanceMetricType = $Enums.PerformanceMetricType

export const PerformanceMetricType: typeof $Enums.PerformanceMetricType

export type AssemblyType = $Enums.AssemblyType

export const AssemblyType: typeof $Enums.AssemblyType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more TraitCategories
 * const traitCategories = await prisma.traitCategory.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more TraitCategories
   * const traitCategories = await prisma.traitCategory.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.traitCategory`: Exposes CRUD operations for the **TraitCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TraitCategories
    * const traitCategories = await prisma.traitCategory.findMany()
    * ```
    */
  get traitCategory(): Prisma.TraitCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trait`: Exposes CRUD operations for the **Trait** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Traits
    * const traits = await prisma.trait.findMany()
    * ```
    */
  get trait(): Prisma.TraitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.traitToTraitCategory`: Exposes CRUD operations for the **TraitToTraitCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TraitToTraitCategories
    * const traitToTraitCategories = await prisma.traitToTraitCategory.findMany()
    * ```
    */
  get traitToTraitCategory(): Prisma.TraitToTraitCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pRSModel`: Exposes CRUD operations for the **PRSModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PRSModels
    * const pRSModels = await prisma.pRSModel.findMany()
    * ```
    */
  get pRSModel(): Prisma.PRSModelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pRSModelToTrait`: Exposes CRUD operations for the **PRSModelToTrait** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PRSModelToTraits
    * const pRSModelToTraits = await prisma.pRSModelToTrait.findMany()
    * ```
    */
  get pRSModelToTrait(): Prisma.PRSModelToTraitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scoringFile`: Exposes CRUD operations for the **ScoringFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScoringFiles
    * const scoringFiles = await prisma.scoringFile.findMany()
    * ```
    */
  get scoringFile(): Prisma.ScoringFileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.publication`: Exposes CRUD operations for the **Publication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publications
    * const publications = await prisma.publication.findMany()
    * ```
    */
  get publication(): Prisma.PublicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modelEvaluation`: Exposes CRUD operations for the **ModelEvaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModelEvaluations
    * const modelEvaluations = await prisma.modelEvaluation.findMany()
    * ```
    */
  get modelEvaluation(): Prisma.ModelEvaluationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performanceMetricEvaluation`: Exposes CRUD operations for the **PerformanceMetricEvaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceMetricEvaluations
    * const performanceMetricEvaluations = await prisma.performanceMetricEvaluation.findMany()
    * ```
    */
  get performanceMetricEvaluation(): Prisma.PerformanceMetricEvaluationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performanceMetric`: Exposes CRUD operations for the **PerformanceMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceMetrics
    * const performanceMetrics = await prisma.performanceMetric.findMany()
    * ```
    */
  get performanceMetric(): Prisma.PerformanceMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evaluationPopulationSample`: Exposes CRUD operations for the **EvaluationPopulationSample** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvaluationPopulationSamples
    * const evaluationPopulationSamples = await prisma.evaluationPopulationSample.findMany()
    * ```
    */
  get evaluationPopulationSample(): Prisma.EvaluationPopulationSampleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.broadAncestryCategory`: Exposes CRUD operations for the **BroadAncestryCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BroadAncestryCategories
    * const broadAncestryCategories = await prisma.broadAncestryCategory.findMany()
    * ```
    */
  get broadAncestryCategory(): Prisma.BroadAncestryCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.broadAncestryInModel`: Exposes CRUD operations for the **BroadAncestryInModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BroadAncestryInModels
    * const broadAncestryInModels = await prisma.broadAncestryInModel.findMany()
    * ```
    */
  get broadAncestryInModel(): Prisma.BroadAncestryInModelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.developmentPopulationSample`: Exposes CRUD operations for the **DevelopmentPopulationSample** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DevelopmentPopulationSamples
    * const developmentPopulationSamples = await prisma.developmentPopulationSample.findMany()
    * ```
    */
  get developmentPopulationSample(): Prisma.DevelopmentPopulationSampleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.broadAncestryInRefPop`: Exposes CRUD operations for the **BroadAncestryInRefPop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BroadAncestryInRefPops
    * const broadAncestryInRefPops = await prisma.broadAncestryInRefPop.findMany()
    * ```
    */
  get broadAncestryInRefPop(): Prisma.BroadAncestryInRefPopDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referencePopulation`: Exposes CRUD operations for the **ReferencePopulation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferencePopulations
    * const referencePopulations = await prisma.referencePopulation.findMany()
    * ```
    */
  get referencePopulation(): Prisma.ReferencePopulationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pRSAnalysis`: Exposes CRUD operations for the **PRSAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PRSAnalyses
    * const pRSAnalyses = await prisma.pRSAnalysis.findMany()
    * ```
    */
  get pRSAnalysis(): Prisma.PRSAnalysisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prioritizedModel`: Exposes CRUD operations for the **PrioritizedModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrioritizedModels
    * const prioritizedModels = await prisma.prioritizedModel.findMany()
    * ```
    */
  get prioritizedModel(): Prisma.PrioritizedModelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pRSResult`: Exposes CRUD operations for the **PRSResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PRSResults
    * const pRSResults = await prisma.pRSResult.findMany()
    * ```
    */
  get pRSResult(): Prisma.PRSResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    TraitCategory: 'TraitCategory',
    Trait: 'Trait',
    TraitToTraitCategory: 'TraitToTraitCategory',
    PRSModel: 'PRSModel',
    PRSModelToTrait: 'PRSModelToTrait',
    ScoringFile: 'ScoringFile',
    Publication: 'Publication',
    ModelEvaluation: 'ModelEvaluation',
    PerformanceMetricEvaluation: 'PerformanceMetricEvaluation',
    PerformanceMetric: 'PerformanceMetric',
    EvaluationPopulationSample: 'EvaluationPopulationSample',
    BroadAncestryCategory: 'BroadAncestryCategory',
    BroadAncestryInModel: 'BroadAncestryInModel',
    DevelopmentPopulationSample: 'DevelopmentPopulationSample',
    BroadAncestryInRefPop: 'BroadAncestryInRefPop',
    ReferencePopulation: 'ReferencePopulation',
    PRSAnalysis: 'PRSAnalysis',
    PrioritizedModel: 'PrioritizedModel',
    PRSResult: 'PRSResult',
    Patient: 'Patient'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "traitCategory" | "trait" | "traitToTraitCategory" | "pRSModel" | "pRSModelToTrait" | "scoringFile" | "publication" | "modelEvaluation" | "performanceMetricEvaluation" | "performanceMetric" | "evaluationPopulationSample" | "broadAncestryCategory" | "broadAncestryInModel" | "developmentPopulationSample" | "broadAncestryInRefPop" | "referencePopulation" | "pRSAnalysis" | "prioritizedModel" | "pRSResult" | "patient"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      TraitCategory: {
        payload: Prisma.$TraitCategoryPayload<ExtArgs>
        fields: Prisma.TraitCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TraitCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TraitCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitCategoryPayload>
          }
          findFirst: {
            args: Prisma.TraitCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TraitCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitCategoryPayload>
          }
          findMany: {
            args: Prisma.TraitCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitCategoryPayload>[]
          }
          create: {
            args: Prisma.TraitCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitCategoryPayload>
          }
          createMany: {
            args: Prisma.TraitCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TraitCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitCategoryPayload>
          }
          update: {
            args: Prisma.TraitCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitCategoryPayload>
          }
          deleteMany: {
            args: Prisma.TraitCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TraitCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TraitCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitCategoryPayload>
          }
          aggregate: {
            args: Prisma.TraitCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTraitCategory>
          }
          groupBy: {
            args: Prisma.TraitCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TraitCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TraitCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<TraitCategoryCountAggregateOutputType> | number
          }
        }
      }
      Trait: {
        payload: Prisma.$TraitPayload<ExtArgs>
        fields: Prisma.TraitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TraitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TraitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>
          }
          findFirst: {
            args: Prisma.TraitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TraitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>
          }
          findMany: {
            args: Prisma.TraitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>[]
          }
          create: {
            args: Prisma.TraitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>
          }
          createMany: {
            args: Prisma.TraitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TraitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>
          }
          update: {
            args: Prisma.TraitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>
          }
          deleteMany: {
            args: Prisma.TraitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TraitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TraitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>
          }
          aggregate: {
            args: Prisma.TraitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrait>
          }
          groupBy: {
            args: Prisma.TraitGroupByArgs<ExtArgs>
            result: $Utils.Optional<TraitGroupByOutputType>[]
          }
          count: {
            args: Prisma.TraitCountArgs<ExtArgs>
            result: $Utils.Optional<TraitCountAggregateOutputType> | number
          }
        }
      }
      TraitToTraitCategory: {
        payload: Prisma.$TraitToTraitCategoryPayload<ExtArgs>
        fields: Prisma.TraitToTraitCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TraitToTraitCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitToTraitCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TraitToTraitCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitToTraitCategoryPayload>
          }
          findFirst: {
            args: Prisma.TraitToTraitCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitToTraitCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TraitToTraitCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitToTraitCategoryPayload>
          }
          findMany: {
            args: Prisma.TraitToTraitCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitToTraitCategoryPayload>[]
          }
          create: {
            args: Prisma.TraitToTraitCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitToTraitCategoryPayload>
          }
          createMany: {
            args: Prisma.TraitToTraitCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TraitToTraitCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitToTraitCategoryPayload>
          }
          update: {
            args: Prisma.TraitToTraitCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitToTraitCategoryPayload>
          }
          deleteMany: {
            args: Prisma.TraitToTraitCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TraitToTraitCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TraitToTraitCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitToTraitCategoryPayload>
          }
          aggregate: {
            args: Prisma.TraitToTraitCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTraitToTraitCategory>
          }
          groupBy: {
            args: Prisma.TraitToTraitCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TraitToTraitCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TraitToTraitCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<TraitToTraitCategoryCountAggregateOutputType> | number
          }
        }
      }
      PRSModel: {
        payload: Prisma.$PRSModelPayload<ExtArgs>
        fields: Prisma.PRSModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PRSModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PRSModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSModelPayload>
          }
          findFirst: {
            args: Prisma.PRSModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PRSModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSModelPayload>
          }
          findMany: {
            args: Prisma.PRSModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSModelPayload>[]
          }
          create: {
            args: Prisma.PRSModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSModelPayload>
          }
          createMany: {
            args: Prisma.PRSModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PRSModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSModelPayload>
          }
          update: {
            args: Prisma.PRSModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSModelPayload>
          }
          deleteMany: {
            args: Prisma.PRSModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PRSModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PRSModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSModelPayload>
          }
          aggregate: {
            args: Prisma.PRSModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePRSModel>
          }
          groupBy: {
            args: Prisma.PRSModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<PRSModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.PRSModelCountArgs<ExtArgs>
            result: $Utils.Optional<PRSModelCountAggregateOutputType> | number
          }
        }
      }
      PRSModelToTrait: {
        payload: Prisma.$PRSModelToTraitPayload<ExtArgs>
        fields: Prisma.PRSModelToTraitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PRSModelToTraitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSModelToTraitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PRSModelToTraitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSModelToTraitPayload>
          }
          findFirst: {
            args: Prisma.PRSModelToTraitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSModelToTraitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PRSModelToTraitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSModelToTraitPayload>
          }
          findMany: {
            args: Prisma.PRSModelToTraitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSModelToTraitPayload>[]
          }
          create: {
            args: Prisma.PRSModelToTraitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSModelToTraitPayload>
          }
          createMany: {
            args: Prisma.PRSModelToTraitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PRSModelToTraitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSModelToTraitPayload>
          }
          update: {
            args: Prisma.PRSModelToTraitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSModelToTraitPayload>
          }
          deleteMany: {
            args: Prisma.PRSModelToTraitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PRSModelToTraitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PRSModelToTraitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSModelToTraitPayload>
          }
          aggregate: {
            args: Prisma.PRSModelToTraitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePRSModelToTrait>
          }
          groupBy: {
            args: Prisma.PRSModelToTraitGroupByArgs<ExtArgs>
            result: $Utils.Optional<PRSModelToTraitGroupByOutputType>[]
          }
          count: {
            args: Prisma.PRSModelToTraitCountArgs<ExtArgs>
            result: $Utils.Optional<PRSModelToTraitCountAggregateOutputType> | number
          }
        }
      }
      ScoringFile: {
        payload: Prisma.$ScoringFilePayload<ExtArgs>
        fields: Prisma.ScoringFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScoringFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScoringFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringFilePayload>
          }
          findFirst: {
            args: Prisma.ScoringFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScoringFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringFilePayload>
          }
          findMany: {
            args: Prisma.ScoringFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringFilePayload>[]
          }
          create: {
            args: Prisma.ScoringFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringFilePayload>
          }
          createMany: {
            args: Prisma.ScoringFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ScoringFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringFilePayload>
          }
          update: {
            args: Prisma.ScoringFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringFilePayload>
          }
          deleteMany: {
            args: Prisma.ScoringFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScoringFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScoringFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringFilePayload>
          }
          aggregate: {
            args: Prisma.ScoringFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScoringFile>
          }
          groupBy: {
            args: Prisma.ScoringFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScoringFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScoringFileCountArgs<ExtArgs>
            result: $Utils.Optional<ScoringFileCountAggregateOutputType> | number
          }
        }
      }
      Publication: {
        payload: Prisma.$PublicationPayload<ExtArgs>
        fields: Prisma.PublicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PublicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PublicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          findFirst: {
            args: Prisma.PublicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PublicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          findMany: {
            args: Prisma.PublicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>[]
          }
          create: {
            args: Prisma.PublicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          createMany: {
            args: Prisma.PublicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PublicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          update: {
            args: Prisma.PublicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          deleteMany: {
            args: Prisma.PublicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PublicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PublicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          aggregate: {
            args: Prisma.PublicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublication>
          }
          groupBy: {
            args: Prisma.PublicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PublicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PublicationCountArgs<ExtArgs>
            result: $Utils.Optional<PublicationCountAggregateOutputType> | number
          }
        }
      }
      ModelEvaluation: {
        payload: Prisma.$ModelEvaluationPayload<ExtArgs>
        fields: Prisma.ModelEvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelEvaluationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelEvaluationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEvaluationPayload>
          }
          findFirst: {
            args: Prisma.ModelEvaluationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelEvaluationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEvaluationPayload>
          }
          findMany: {
            args: Prisma.ModelEvaluationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEvaluationPayload>[]
          }
          create: {
            args: Prisma.ModelEvaluationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEvaluationPayload>
          }
          createMany: {
            args: Prisma.ModelEvaluationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ModelEvaluationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEvaluationPayload>
          }
          update: {
            args: Prisma.ModelEvaluationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEvaluationPayload>
          }
          deleteMany: {
            args: Prisma.ModelEvaluationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelEvaluationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModelEvaluationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelEvaluationPayload>
          }
          aggregate: {
            args: Prisma.ModelEvaluationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModelEvaluation>
          }
          groupBy: {
            args: Prisma.ModelEvaluationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelEvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModelEvaluationCountArgs<ExtArgs>
            result: $Utils.Optional<ModelEvaluationCountAggregateOutputType> | number
          }
        }
      }
      PerformanceMetricEvaluation: {
        payload: Prisma.$PerformanceMetricEvaluationPayload<ExtArgs>
        fields: Prisma.PerformanceMetricEvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceMetricEvaluationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricEvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceMetricEvaluationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricEvaluationPayload>
          }
          findFirst: {
            args: Prisma.PerformanceMetricEvaluationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricEvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceMetricEvaluationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricEvaluationPayload>
          }
          findMany: {
            args: Prisma.PerformanceMetricEvaluationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricEvaluationPayload>[]
          }
          create: {
            args: Prisma.PerformanceMetricEvaluationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricEvaluationPayload>
          }
          createMany: {
            args: Prisma.PerformanceMetricEvaluationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PerformanceMetricEvaluationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricEvaluationPayload>
          }
          update: {
            args: Prisma.PerformanceMetricEvaluationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricEvaluationPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceMetricEvaluationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceMetricEvaluationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PerformanceMetricEvaluationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricEvaluationPayload>
          }
          aggregate: {
            args: Prisma.PerformanceMetricEvaluationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceMetricEvaluation>
          }
          groupBy: {
            args: Prisma.PerformanceMetricEvaluationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceMetricEvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceMetricEvaluationCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceMetricEvaluationCountAggregateOutputType> | number
          }
        }
      }
      PerformanceMetric: {
        payload: Prisma.$PerformanceMetricPayload<ExtArgs>
        fields: Prisma.PerformanceMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          findFirst: {
            args: Prisma.PerformanceMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          findMany: {
            args: Prisma.PerformanceMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>[]
          }
          create: {
            args: Prisma.PerformanceMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          createMany: {
            args: Prisma.PerformanceMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PerformanceMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          update: {
            args: Prisma.PerformanceMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PerformanceMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          aggregate: {
            args: Prisma.PerformanceMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceMetric>
          }
          groupBy: {
            args: Prisma.PerformanceMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceMetricCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceMetricCountAggregateOutputType> | number
          }
        }
      }
      EvaluationPopulationSample: {
        payload: Prisma.$EvaluationPopulationSamplePayload<ExtArgs>
        fields: Prisma.EvaluationPopulationSampleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationPopulationSampleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPopulationSamplePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationPopulationSampleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPopulationSamplePayload>
          }
          findFirst: {
            args: Prisma.EvaluationPopulationSampleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPopulationSamplePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationPopulationSampleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPopulationSamplePayload>
          }
          findMany: {
            args: Prisma.EvaluationPopulationSampleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPopulationSamplePayload>[]
          }
          create: {
            args: Prisma.EvaluationPopulationSampleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPopulationSamplePayload>
          }
          createMany: {
            args: Prisma.EvaluationPopulationSampleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EvaluationPopulationSampleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPopulationSamplePayload>
          }
          update: {
            args: Prisma.EvaluationPopulationSampleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPopulationSamplePayload>
          }
          deleteMany: {
            args: Prisma.EvaluationPopulationSampleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationPopulationSampleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvaluationPopulationSampleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPopulationSamplePayload>
          }
          aggregate: {
            args: Prisma.EvaluationPopulationSampleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaluationPopulationSample>
          }
          groupBy: {
            args: Prisma.EvaluationPopulationSampleGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaluationPopulationSampleGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationPopulationSampleCountArgs<ExtArgs>
            result: $Utils.Optional<EvaluationPopulationSampleCountAggregateOutputType> | number
          }
        }
      }
      BroadAncestryCategory: {
        payload: Prisma.$BroadAncestryCategoryPayload<ExtArgs>
        fields: Prisma.BroadAncestryCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BroadAncestryCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BroadAncestryCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryCategoryPayload>
          }
          findFirst: {
            args: Prisma.BroadAncestryCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BroadAncestryCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryCategoryPayload>
          }
          findMany: {
            args: Prisma.BroadAncestryCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryCategoryPayload>[]
          }
          create: {
            args: Prisma.BroadAncestryCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryCategoryPayload>
          }
          createMany: {
            args: Prisma.BroadAncestryCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BroadAncestryCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryCategoryPayload>
          }
          update: {
            args: Prisma.BroadAncestryCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryCategoryPayload>
          }
          deleteMany: {
            args: Prisma.BroadAncestryCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BroadAncestryCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BroadAncestryCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryCategoryPayload>
          }
          aggregate: {
            args: Prisma.BroadAncestryCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBroadAncestryCategory>
          }
          groupBy: {
            args: Prisma.BroadAncestryCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BroadAncestryCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BroadAncestryCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<BroadAncestryCategoryCountAggregateOutputType> | number
          }
        }
      }
      BroadAncestryInModel: {
        payload: Prisma.$BroadAncestryInModelPayload<ExtArgs>
        fields: Prisma.BroadAncestryInModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BroadAncestryInModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryInModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BroadAncestryInModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryInModelPayload>
          }
          findFirst: {
            args: Prisma.BroadAncestryInModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryInModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BroadAncestryInModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryInModelPayload>
          }
          findMany: {
            args: Prisma.BroadAncestryInModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryInModelPayload>[]
          }
          create: {
            args: Prisma.BroadAncestryInModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryInModelPayload>
          }
          createMany: {
            args: Prisma.BroadAncestryInModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BroadAncestryInModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryInModelPayload>
          }
          update: {
            args: Prisma.BroadAncestryInModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryInModelPayload>
          }
          deleteMany: {
            args: Prisma.BroadAncestryInModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BroadAncestryInModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BroadAncestryInModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryInModelPayload>
          }
          aggregate: {
            args: Prisma.BroadAncestryInModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBroadAncestryInModel>
          }
          groupBy: {
            args: Prisma.BroadAncestryInModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<BroadAncestryInModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.BroadAncestryInModelCountArgs<ExtArgs>
            result: $Utils.Optional<BroadAncestryInModelCountAggregateOutputType> | number
          }
        }
      }
      DevelopmentPopulationSample: {
        payload: Prisma.$DevelopmentPopulationSamplePayload<ExtArgs>
        fields: Prisma.DevelopmentPopulationSampleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DevelopmentPopulationSampleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevelopmentPopulationSamplePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DevelopmentPopulationSampleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevelopmentPopulationSamplePayload>
          }
          findFirst: {
            args: Prisma.DevelopmentPopulationSampleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevelopmentPopulationSamplePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DevelopmentPopulationSampleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevelopmentPopulationSamplePayload>
          }
          findMany: {
            args: Prisma.DevelopmentPopulationSampleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevelopmentPopulationSamplePayload>[]
          }
          create: {
            args: Prisma.DevelopmentPopulationSampleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevelopmentPopulationSamplePayload>
          }
          createMany: {
            args: Prisma.DevelopmentPopulationSampleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DevelopmentPopulationSampleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevelopmentPopulationSamplePayload>
          }
          update: {
            args: Prisma.DevelopmentPopulationSampleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevelopmentPopulationSamplePayload>
          }
          deleteMany: {
            args: Prisma.DevelopmentPopulationSampleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DevelopmentPopulationSampleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DevelopmentPopulationSampleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevelopmentPopulationSamplePayload>
          }
          aggregate: {
            args: Prisma.DevelopmentPopulationSampleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevelopmentPopulationSample>
          }
          groupBy: {
            args: Prisma.DevelopmentPopulationSampleGroupByArgs<ExtArgs>
            result: $Utils.Optional<DevelopmentPopulationSampleGroupByOutputType>[]
          }
          count: {
            args: Prisma.DevelopmentPopulationSampleCountArgs<ExtArgs>
            result: $Utils.Optional<DevelopmentPopulationSampleCountAggregateOutputType> | number
          }
        }
      }
      BroadAncestryInRefPop: {
        payload: Prisma.$BroadAncestryInRefPopPayload<ExtArgs>
        fields: Prisma.BroadAncestryInRefPopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BroadAncestryInRefPopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryInRefPopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BroadAncestryInRefPopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryInRefPopPayload>
          }
          findFirst: {
            args: Prisma.BroadAncestryInRefPopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryInRefPopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BroadAncestryInRefPopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryInRefPopPayload>
          }
          findMany: {
            args: Prisma.BroadAncestryInRefPopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryInRefPopPayload>[]
          }
          create: {
            args: Prisma.BroadAncestryInRefPopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryInRefPopPayload>
          }
          createMany: {
            args: Prisma.BroadAncestryInRefPopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BroadAncestryInRefPopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryInRefPopPayload>
          }
          update: {
            args: Prisma.BroadAncestryInRefPopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryInRefPopPayload>
          }
          deleteMany: {
            args: Prisma.BroadAncestryInRefPopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BroadAncestryInRefPopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BroadAncestryInRefPopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadAncestryInRefPopPayload>
          }
          aggregate: {
            args: Prisma.BroadAncestryInRefPopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBroadAncestryInRefPop>
          }
          groupBy: {
            args: Prisma.BroadAncestryInRefPopGroupByArgs<ExtArgs>
            result: $Utils.Optional<BroadAncestryInRefPopGroupByOutputType>[]
          }
          count: {
            args: Prisma.BroadAncestryInRefPopCountArgs<ExtArgs>
            result: $Utils.Optional<BroadAncestryInRefPopCountAggregateOutputType> | number
          }
        }
      }
      ReferencePopulation: {
        payload: Prisma.$ReferencePopulationPayload<ExtArgs>
        fields: Prisma.ReferencePopulationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferencePopulationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferencePopulationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferencePopulationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferencePopulationPayload>
          }
          findFirst: {
            args: Prisma.ReferencePopulationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferencePopulationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferencePopulationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferencePopulationPayload>
          }
          findMany: {
            args: Prisma.ReferencePopulationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferencePopulationPayload>[]
          }
          create: {
            args: Prisma.ReferencePopulationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferencePopulationPayload>
          }
          createMany: {
            args: Prisma.ReferencePopulationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReferencePopulationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferencePopulationPayload>
          }
          update: {
            args: Prisma.ReferencePopulationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferencePopulationPayload>
          }
          deleteMany: {
            args: Prisma.ReferencePopulationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferencePopulationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferencePopulationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferencePopulationPayload>
          }
          aggregate: {
            args: Prisma.ReferencePopulationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferencePopulation>
          }
          groupBy: {
            args: Prisma.ReferencePopulationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferencePopulationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferencePopulationCountArgs<ExtArgs>
            result: $Utils.Optional<ReferencePopulationCountAggregateOutputType> | number
          }
        }
      }
      PRSAnalysis: {
        payload: Prisma.$PRSAnalysisPayload<ExtArgs>
        fields: Prisma.PRSAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PRSAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PRSAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSAnalysisPayload>
          }
          findFirst: {
            args: Prisma.PRSAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PRSAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSAnalysisPayload>
          }
          findMany: {
            args: Prisma.PRSAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSAnalysisPayload>[]
          }
          create: {
            args: Prisma.PRSAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSAnalysisPayload>
          }
          createMany: {
            args: Prisma.PRSAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PRSAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSAnalysisPayload>
          }
          update: {
            args: Prisma.PRSAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.PRSAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PRSAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PRSAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSAnalysisPayload>
          }
          aggregate: {
            args: Prisma.PRSAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePRSAnalysis>
          }
          groupBy: {
            args: Prisma.PRSAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<PRSAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.PRSAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<PRSAnalysisCountAggregateOutputType> | number
          }
        }
      }
      PrioritizedModel: {
        payload: Prisma.$PrioritizedModelPayload<ExtArgs>
        fields: Prisma.PrioritizedModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrioritizedModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrioritizedModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrioritizedModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrioritizedModelPayload>
          }
          findFirst: {
            args: Prisma.PrioritizedModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrioritizedModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrioritizedModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrioritizedModelPayload>
          }
          findMany: {
            args: Prisma.PrioritizedModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrioritizedModelPayload>[]
          }
          create: {
            args: Prisma.PrioritizedModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrioritizedModelPayload>
          }
          createMany: {
            args: Prisma.PrioritizedModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PrioritizedModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrioritizedModelPayload>
          }
          update: {
            args: Prisma.PrioritizedModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrioritizedModelPayload>
          }
          deleteMany: {
            args: Prisma.PrioritizedModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrioritizedModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrioritizedModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrioritizedModelPayload>
          }
          aggregate: {
            args: Prisma.PrioritizedModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrioritizedModel>
          }
          groupBy: {
            args: Prisma.PrioritizedModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrioritizedModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrioritizedModelCountArgs<ExtArgs>
            result: $Utils.Optional<PrioritizedModelCountAggregateOutputType> | number
          }
        }
      }
      PRSResult: {
        payload: Prisma.$PRSResultPayload<ExtArgs>
        fields: Prisma.PRSResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PRSResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PRSResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSResultPayload>
          }
          findFirst: {
            args: Prisma.PRSResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PRSResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSResultPayload>
          }
          findMany: {
            args: Prisma.PRSResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSResultPayload>[]
          }
          create: {
            args: Prisma.PRSResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSResultPayload>
          }
          createMany: {
            args: Prisma.PRSResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PRSResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSResultPayload>
          }
          update: {
            args: Prisma.PRSResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSResultPayload>
          }
          deleteMany: {
            args: Prisma.PRSResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PRSResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PRSResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRSResultPayload>
          }
          aggregate: {
            args: Prisma.PRSResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePRSResult>
          }
          groupBy: {
            args: Prisma.PRSResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<PRSResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.PRSResultCountArgs<ExtArgs>
            result: $Utils.Optional<PRSResultCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    traitCategory?: TraitCategoryOmit
    trait?: TraitOmit
    traitToTraitCategory?: TraitToTraitCategoryOmit
    pRSModel?: PRSModelOmit
    pRSModelToTrait?: PRSModelToTraitOmit
    scoringFile?: ScoringFileOmit
    publication?: PublicationOmit
    modelEvaluation?: ModelEvaluationOmit
    performanceMetricEvaluation?: PerformanceMetricEvaluationOmit
    performanceMetric?: PerformanceMetricOmit
    evaluationPopulationSample?: EvaluationPopulationSampleOmit
    broadAncestryCategory?: BroadAncestryCategoryOmit
    broadAncestryInModel?: BroadAncestryInModelOmit
    developmentPopulationSample?: DevelopmentPopulationSampleOmit
    broadAncestryInRefPop?: BroadAncestryInRefPopOmit
    referencePopulation?: ReferencePopulationOmit
    pRSAnalysis?: PRSAnalysisOmit
    prioritizedModel?: PrioritizedModelOmit
    pRSResult?: PRSResultOmit
    patient?: PatientOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TraitCategoryCountOutputType
   */

  export type TraitCategoryCountOutputType = {
    traits: number
  }

  export type TraitCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    traits?: boolean | TraitCategoryCountOutputTypeCountTraitsArgs
  }

  // Custom InputTypes
  /**
   * TraitCategoryCountOutputType without action
   */
  export type TraitCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitCategoryCountOutputType
     */
    select?: TraitCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TraitCategoryCountOutputType without action
   */
  export type TraitCategoryCountOutputTypeCountTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraitToTraitCategoryWhereInput
  }


  /**
   * Count Type TraitCountOutputType
   */

  export type TraitCountOutputType = {
    prsModels: number
    categories: number
  }

  export type TraitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prsModels?: boolean | TraitCountOutputTypeCountPrsModelsArgs
    categories?: boolean | TraitCountOutputTypeCountCategoriesArgs
  }

  // Custom InputTypes
  /**
   * TraitCountOutputType without action
   */
  export type TraitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitCountOutputType
     */
    select?: TraitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TraitCountOutputType without action
   */
  export type TraitCountOutputTypeCountPrsModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PRSModelToTraitWhereInput
  }

  /**
   * TraitCountOutputType without action
   */
  export type TraitCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraitToTraitCategoryWhereInput
  }


  /**
   * Count Type PRSModelCountOutputType
   */

  export type PRSModelCountOutputType = {
    broadAncestryCategories: number
    DevelopmentPopulationSamples: number
    modelEvaluations: number
    traits: number
    prioritizedModels: number
  }

  export type PRSModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    broadAncestryCategories?: boolean | PRSModelCountOutputTypeCountBroadAncestryCategoriesArgs
    DevelopmentPopulationSamples?: boolean | PRSModelCountOutputTypeCountDevelopmentPopulationSamplesArgs
    modelEvaluations?: boolean | PRSModelCountOutputTypeCountModelEvaluationsArgs
    traits?: boolean | PRSModelCountOutputTypeCountTraitsArgs
    prioritizedModels?: boolean | PRSModelCountOutputTypeCountPrioritizedModelsArgs
  }

  // Custom InputTypes
  /**
   * PRSModelCountOutputType without action
   */
  export type PRSModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModelCountOutputType
     */
    select?: PRSModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PRSModelCountOutputType without action
   */
  export type PRSModelCountOutputTypeCountBroadAncestryCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BroadAncestryInModelWhereInput
  }

  /**
   * PRSModelCountOutputType without action
   */
  export type PRSModelCountOutputTypeCountDevelopmentPopulationSamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DevelopmentPopulationSampleWhereInput
  }

  /**
   * PRSModelCountOutputType without action
   */
  export type PRSModelCountOutputTypeCountModelEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelEvaluationWhereInput
  }

  /**
   * PRSModelCountOutputType without action
   */
  export type PRSModelCountOutputTypeCountTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PRSModelToTraitWhereInput
  }

  /**
   * PRSModelCountOutputType without action
   */
  export type PRSModelCountOutputTypeCountPrioritizedModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrioritizedModelWhereInput
  }


  /**
   * Count Type PublicationCountOutputType
   */

  export type PublicationCountOutputType = {
    modelEvaluations: number
    prsModels: number
  }

  export type PublicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modelEvaluations?: boolean | PublicationCountOutputTypeCountModelEvaluationsArgs
    prsModels?: boolean | PublicationCountOutputTypeCountPrsModelsArgs
  }

  // Custom InputTypes
  /**
   * PublicationCountOutputType without action
   */
  export type PublicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationCountOutputType
     */
    select?: PublicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PublicationCountOutputType without action
   */
  export type PublicationCountOutputTypeCountModelEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelEvaluationWhereInput
  }

  /**
   * PublicationCountOutputType without action
   */
  export type PublicationCountOutputTypeCountPrsModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PRSModelWhereInput
  }


  /**
   * Count Type ModelEvaluationCountOutputType
   */

  export type ModelEvaluationCountOutputType = {
    metricEvaluations: number
  }

  export type ModelEvaluationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metricEvaluations?: boolean | ModelEvaluationCountOutputTypeCountMetricEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * ModelEvaluationCountOutputType without action
   */
  export type ModelEvaluationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEvaluationCountOutputType
     */
    select?: ModelEvaluationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModelEvaluationCountOutputType without action
   */
  export type ModelEvaluationCountOutputTypeCountMetricEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceMetricEvaluationWhereInput
  }


  /**
   * Count Type PerformanceMetricCountOutputType
   */

  export type PerformanceMetricCountOutputType = {
    performanceMetricEvaluations: number
  }

  export type PerformanceMetricCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performanceMetricEvaluations?: boolean | PerformanceMetricCountOutputTypeCountPerformanceMetricEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * PerformanceMetricCountOutputType without action
   */
  export type PerformanceMetricCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetricCountOutputType
     */
    select?: PerformanceMetricCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PerformanceMetricCountOutputType without action
   */
  export type PerformanceMetricCountOutputTypeCountPerformanceMetricEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceMetricEvaluationWhereInput
  }


  /**
   * Count Type EvaluationPopulationSampleCountOutputType
   */

  export type EvaluationPopulationSampleCountOutputType = {
    modelEvaluations: number
  }

  export type EvaluationPopulationSampleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modelEvaluations?: boolean | EvaluationPopulationSampleCountOutputTypeCountModelEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * EvaluationPopulationSampleCountOutputType without action
   */
  export type EvaluationPopulationSampleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPopulationSampleCountOutputType
     */
    select?: EvaluationPopulationSampleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EvaluationPopulationSampleCountOutputType without action
   */
  export type EvaluationPopulationSampleCountOutputTypeCountModelEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelEvaluationWhereInput
  }


  /**
   * Count Type BroadAncestryCategoryCountOutputType
   */

  export type BroadAncestryCategoryCountOutputType = {
    broadAncestryInModels: number
    broadAncestryInRefPops: number
    DevelopmentPopulationSamples: number
    EvaluationPopulationSamples: number
  }

  export type BroadAncestryCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    broadAncestryInModels?: boolean | BroadAncestryCategoryCountOutputTypeCountBroadAncestryInModelsArgs
    broadAncestryInRefPops?: boolean | BroadAncestryCategoryCountOutputTypeCountBroadAncestryInRefPopsArgs
    DevelopmentPopulationSamples?: boolean | BroadAncestryCategoryCountOutputTypeCountDevelopmentPopulationSamplesArgs
    EvaluationPopulationSamples?: boolean | BroadAncestryCategoryCountOutputTypeCountEvaluationPopulationSamplesArgs
  }

  // Custom InputTypes
  /**
   * BroadAncestryCategoryCountOutputType without action
   */
  export type BroadAncestryCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryCategoryCountOutputType
     */
    select?: BroadAncestryCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BroadAncestryCategoryCountOutputType without action
   */
  export type BroadAncestryCategoryCountOutputTypeCountBroadAncestryInModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BroadAncestryInModelWhereInput
  }

  /**
   * BroadAncestryCategoryCountOutputType without action
   */
  export type BroadAncestryCategoryCountOutputTypeCountBroadAncestryInRefPopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BroadAncestryInRefPopWhereInput
  }

  /**
   * BroadAncestryCategoryCountOutputType without action
   */
  export type BroadAncestryCategoryCountOutputTypeCountDevelopmentPopulationSamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DevelopmentPopulationSampleWhereInput
  }

  /**
   * BroadAncestryCategoryCountOutputType without action
   */
  export type BroadAncestryCategoryCountOutputTypeCountEvaluationPopulationSamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationPopulationSampleWhereInput
  }


  /**
   * Count Type ReferencePopulationCountOutputType
   */

  export type ReferencePopulationCountOutputType = {
    broadAncestryCategories: number
    prsAnalyses: number
  }

  export type ReferencePopulationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    broadAncestryCategories?: boolean | ReferencePopulationCountOutputTypeCountBroadAncestryCategoriesArgs
    prsAnalyses?: boolean | ReferencePopulationCountOutputTypeCountPrsAnalysesArgs
  }

  // Custom InputTypes
  /**
   * ReferencePopulationCountOutputType without action
   */
  export type ReferencePopulationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferencePopulationCountOutputType
     */
    select?: ReferencePopulationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReferencePopulationCountOutputType without action
   */
  export type ReferencePopulationCountOutputTypeCountBroadAncestryCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BroadAncestryInRefPopWhereInput
  }

  /**
   * ReferencePopulationCountOutputType without action
   */
  export type ReferencePopulationCountOutputTypeCountPrsAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PRSAnalysisWhereInput
  }


  /**
   * Count Type PRSAnalysisCountOutputType
   */

  export type PRSAnalysisCountOutputType = {
    prioritizedModels: number
  }

  export type PRSAnalysisCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prioritizedModels?: boolean | PRSAnalysisCountOutputTypeCountPrioritizedModelsArgs
  }

  // Custom InputTypes
  /**
   * PRSAnalysisCountOutputType without action
   */
  export type PRSAnalysisCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSAnalysisCountOutputType
     */
    select?: PRSAnalysisCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PRSAnalysisCountOutputType without action
   */
  export type PRSAnalysisCountOutputTypeCountPrioritizedModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrioritizedModelWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    prsAnalyses: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prsAnalyses?: boolean | PatientCountOutputTypeCountPrsAnalysesArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPrsAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PRSAnalysisWhereInput
  }


  /**
   * Models
   */

  /**
   * Model TraitCategory
   */

  export type AggregateTraitCategory = {
    _count: TraitCategoryCountAggregateOutputType | null
    _avg: TraitCategoryAvgAggregateOutputType | null
    _sum: TraitCategorySumAggregateOutputType | null
    _min: TraitCategoryMinAggregateOutputType | null
    _max: TraitCategoryMaxAggregateOutputType | null
  }

  export type TraitCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type TraitCategorySumAggregateOutputType = {
    id: number | null
  }

  export type TraitCategoryMinAggregateOutputType = {
    id: number | null
    label: string | null
  }

  export type TraitCategoryMaxAggregateOutputType = {
    id: number | null
    label: string | null
  }

  export type TraitCategoryCountAggregateOutputType = {
    id: number
    label: number
    _all: number
  }


  export type TraitCategoryAvgAggregateInputType = {
    id?: true
  }

  export type TraitCategorySumAggregateInputType = {
    id?: true
  }

  export type TraitCategoryMinAggregateInputType = {
    id?: true
    label?: true
  }

  export type TraitCategoryMaxAggregateInputType = {
    id?: true
    label?: true
  }

  export type TraitCategoryCountAggregateInputType = {
    id?: true
    label?: true
    _all?: true
  }

  export type TraitCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TraitCategory to aggregate.
     */
    where?: TraitCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraitCategories to fetch.
     */
    orderBy?: TraitCategoryOrderByWithRelationInput | TraitCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TraitCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraitCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraitCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TraitCategories
    **/
    _count?: true | TraitCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TraitCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TraitCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TraitCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TraitCategoryMaxAggregateInputType
  }

  export type GetTraitCategoryAggregateType<T extends TraitCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTraitCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTraitCategory[P]>
      : GetScalarType<T[P], AggregateTraitCategory[P]>
  }




  export type TraitCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraitCategoryWhereInput
    orderBy?: TraitCategoryOrderByWithAggregationInput | TraitCategoryOrderByWithAggregationInput[]
    by: TraitCategoryScalarFieldEnum[] | TraitCategoryScalarFieldEnum
    having?: TraitCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TraitCategoryCountAggregateInputType | true
    _avg?: TraitCategoryAvgAggregateInputType
    _sum?: TraitCategorySumAggregateInputType
    _min?: TraitCategoryMinAggregateInputType
    _max?: TraitCategoryMaxAggregateInputType
  }

  export type TraitCategoryGroupByOutputType = {
    id: number
    label: string
    _count: TraitCategoryCountAggregateOutputType | null
    _avg: TraitCategoryAvgAggregateOutputType | null
    _sum: TraitCategorySumAggregateOutputType | null
    _min: TraitCategoryMinAggregateOutputType | null
    _max: TraitCategoryMaxAggregateOutputType | null
  }

  type GetTraitCategoryGroupByPayload<T extends TraitCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TraitCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TraitCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TraitCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], TraitCategoryGroupByOutputType[P]>
        }
      >
    >


  export type TraitCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    traits?: boolean | TraitCategory$traitsArgs<ExtArgs>
    _count?: boolean | TraitCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["traitCategory"]>



  export type TraitCategorySelectScalar = {
    id?: boolean
    label?: boolean
  }

  export type TraitCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label", ExtArgs["result"]["traitCategory"]>
  export type TraitCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    traits?: boolean | TraitCategory$traitsArgs<ExtArgs>
    _count?: boolean | TraitCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TraitCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TraitCategory"
    objects: {
      traits: Prisma.$TraitToTraitCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      label: string
    }, ExtArgs["result"]["traitCategory"]>
    composites: {}
  }

  type TraitCategoryGetPayload<S extends boolean | null | undefined | TraitCategoryDefaultArgs> = $Result.GetResult<Prisma.$TraitCategoryPayload, S>

  type TraitCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TraitCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TraitCategoryCountAggregateInputType | true
    }

  export interface TraitCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TraitCategory'], meta: { name: 'TraitCategory' } }
    /**
     * Find zero or one TraitCategory that matches the filter.
     * @param {TraitCategoryFindUniqueArgs} args - Arguments to find a TraitCategory
     * @example
     * // Get one TraitCategory
     * const traitCategory = await prisma.traitCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TraitCategoryFindUniqueArgs>(args: SelectSubset<T, TraitCategoryFindUniqueArgs<ExtArgs>>): Prisma__TraitCategoryClient<$Result.GetResult<Prisma.$TraitCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TraitCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TraitCategoryFindUniqueOrThrowArgs} args - Arguments to find a TraitCategory
     * @example
     * // Get one TraitCategory
     * const traitCategory = await prisma.traitCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TraitCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, TraitCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TraitCategoryClient<$Result.GetResult<Prisma.$TraitCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TraitCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitCategoryFindFirstArgs} args - Arguments to find a TraitCategory
     * @example
     * // Get one TraitCategory
     * const traitCategory = await prisma.traitCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TraitCategoryFindFirstArgs>(args?: SelectSubset<T, TraitCategoryFindFirstArgs<ExtArgs>>): Prisma__TraitCategoryClient<$Result.GetResult<Prisma.$TraitCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TraitCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitCategoryFindFirstOrThrowArgs} args - Arguments to find a TraitCategory
     * @example
     * // Get one TraitCategory
     * const traitCategory = await prisma.traitCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TraitCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, TraitCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TraitCategoryClient<$Result.GetResult<Prisma.$TraitCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TraitCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TraitCategories
     * const traitCategories = await prisma.traitCategory.findMany()
     * 
     * // Get first 10 TraitCategories
     * const traitCategories = await prisma.traitCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const traitCategoryWithIdOnly = await prisma.traitCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TraitCategoryFindManyArgs>(args?: SelectSubset<T, TraitCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraitCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TraitCategory.
     * @param {TraitCategoryCreateArgs} args - Arguments to create a TraitCategory.
     * @example
     * // Create one TraitCategory
     * const TraitCategory = await prisma.traitCategory.create({
     *   data: {
     *     // ... data to create a TraitCategory
     *   }
     * })
     * 
     */
    create<T extends TraitCategoryCreateArgs>(args: SelectSubset<T, TraitCategoryCreateArgs<ExtArgs>>): Prisma__TraitCategoryClient<$Result.GetResult<Prisma.$TraitCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TraitCategories.
     * @param {TraitCategoryCreateManyArgs} args - Arguments to create many TraitCategories.
     * @example
     * // Create many TraitCategories
     * const traitCategory = await prisma.traitCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TraitCategoryCreateManyArgs>(args?: SelectSubset<T, TraitCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TraitCategory.
     * @param {TraitCategoryDeleteArgs} args - Arguments to delete one TraitCategory.
     * @example
     * // Delete one TraitCategory
     * const TraitCategory = await prisma.traitCategory.delete({
     *   where: {
     *     // ... filter to delete one TraitCategory
     *   }
     * })
     * 
     */
    delete<T extends TraitCategoryDeleteArgs>(args: SelectSubset<T, TraitCategoryDeleteArgs<ExtArgs>>): Prisma__TraitCategoryClient<$Result.GetResult<Prisma.$TraitCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TraitCategory.
     * @param {TraitCategoryUpdateArgs} args - Arguments to update one TraitCategory.
     * @example
     * // Update one TraitCategory
     * const traitCategory = await prisma.traitCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TraitCategoryUpdateArgs>(args: SelectSubset<T, TraitCategoryUpdateArgs<ExtArgs>>): Prisma__TraitCategoryClient<$Result.GetResult<Prisma.$TraitCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TraitCategories.
     * @param {TraitCategoryDeleteManyArgs} args - Arguments to filter TraitCategories to delete.
     * @example
     * // Delete a few TraitCategories
     * const { count } = await prisma.traitCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TraitCategoryDeleteManyArgs>(args?: SelectSubset<T, TraitCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TraitCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TraitCategories
     * const traitCategory = await prisma.traitCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TraitCategoryUpdateManyArgs>(args: SelectSubset<T, TraitCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TraitCategory.
     * @param {TraitCategoryUpsertArgs} args - Arguments to update or create a TraitCategory.
     * @example
     * // Update or create a TraitCategory
     * const traitCategory = await prisma.traitCategory.upsert({
     *   create: {
     *     // ... data to create a TraitCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TraitCategory we want to update
     *   }
     * })
     */
    upsert<T extends TraitCategoryUpsertArgs>(args: SelectSubset<T, TraitCategoryUpsertArgs<ExtArgs>>): Prisma__TraitCategoryClient<$Result.GetResult<Prisma.$TraitCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TraitCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitCategoryCountArgs} args - Arguments to filter TraitCategories to count.
     * @example
     * // Count the number of TraitCategories
     * const count = await prisma.traitCategory.count({
     *   where: {
     *     // ... the filter for the TraitCategories we want to count
     *   }
     * })
    **/
    count<T extends TraitCategoryCountArgs>(
      args?: Subset<T, TraitCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TraitCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TraitCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TraitCategoryAggregateArgs>(args: Subset<T, TraitCategoryAggregateArgs>): Prisma.PrismaPromise<GetTraitCategoryAggregateType<T>>

    /**
     * Group by TraitCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TraitCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TraitCategoryGroupByArgs['orderBy'] }
        : { orderBy?: TraitCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TraitCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTraitCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TraitCategory model
   */
  readonly fields: TraitCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TraitCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TraitCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    traits<T extends TraitCategory$traitsArgs<ExtArgs> = {}>(args?: Subset<T, TraitCategory$traitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraitToTraitCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TraitCategory model
   */
  interface TraitCategoryFieldRefs {
    readonly id: FieldRef<"TraitCategory", 'Int'>
    readonly label: FieldRef<"TraitCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TraitCategory findUnique
   */
  export type TraitCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitCategory
     */
    select?: TraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitCategory
     */
    omit?: TraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TraitCategory to fetch.
     */
    where: TraitCategoryWhereUniqueInput
  }

  /**
   * TraitCategory findUniqueOrThrow
   */
  export type TraitCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitCategory
     */
    select?: TraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitCategory
     */
    omit?: TraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TraitCategory to fetch.
     */
    where: TraitCategoryWhereUniqueInput
  }

  /**
   * TraitCategory findFirst
   */
  export type TraitCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitCategory
     */
    select?: TraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitCategory
     */
    omit?: TraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TraitCategory to fetch.
     */
    where?: TraitCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraitCategories to fetch.
     */
    orderBy?: TraitCategoryOrderByWithRelationInput | TraitCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TraitCategories.
     */
    cursor?: TraitCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraitCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraitCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TraitCategories.
     */
    distinct?: TraitCategoryScalarFieldEnum | TraitCategoryScalarFieldEnum[]
  }

  /**
   * TraitCategory findFirstOrThrow
   */
  export type TraitCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitCategory
     */
    select?: TraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitCategory
     */
    omit?: TraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TraitCategory to fetch.
     */
    where?: TraitCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraitCategories to fetch.
     */
    orderBy?: TraitCategoryOrderByWithRelationInput | TraitCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TraitCategories.
     */
    cursor?: TraitCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraitCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraitCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TraitCategories.
     */
    distinct?: TraitCategoryScalarFieldEnum | TraitCategoryScalarFieldEnum[]
  }

  /**
   * TraitCategory findMany
   */
  export type TraitCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitCategory
     */
    select?: TraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitCategory
     */
    omit?: TraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TraitCategories to fetch.
     */
    where?: TraitCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraitCategories to fetch.
     */
    orderBy?: TraitCategoryOrderByWithRelationInput | TraitCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TraitCategories.
     */
    cursor?: TraitCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraitCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraitCategories.
     */
    skip?: number
    distinct?: TraitCategoryScalarFieldEnum | TraitCategoryScalarFieldEnum[]
  }

  /**
   * TraitCategory create
   */
  export type TraitCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitCategory
     */
    select?: TraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitCategory
     */
    omit?: TraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a TraitCategory.
     */
    data: XOR<TraitCategoryCreateInput, TraitCategoryUncheckedCreateInput>
  }

  /**
   * TraitCategory createMany
   */
  export type TraitCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TraitCategories.
     */
    data: TraitCategoryCreateManyInput | TraitCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TraitCategory update
   */
  export type TraitCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitCategory
     */
    select?: TraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitCategory
     */
    omit?: TraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a TraitCategory.
     */
    data: XOR<TraitCategoryUpdateInput, TraitCategoryUncheckedUpdateInput>
    /**
     * Choose, which TraitCategory to update.
     */
    where: TraitCategoryWhereUniqueInput
  }

  /**
   * TraitCategory updateMany
   */
  export type TraitCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TraitCategories.
     */
    data: XOR<TraitCategoryUpdateManyMutationInput, TraitCategoryUncheckedUpdateManyInput>
    /**
     * Filter which TraitCategories to update
     */
    where?: TraitCategoryWhereInput
    /**
     * Limit how many TraitCategories to update.
     */
    limit?: number
  }

  /**
   * TraitCategory upsert
   */
  export type TraitCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitCategory
     */
    select?: TraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitCategory
     */
    omit?: TraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the TraitCategory to update in case it exists.
     */
    where: TraitCategoryWhereUniqueInput
    /**
     * In case the TraitCategory found by the `where` argument doesn't exist, create a new TraitCategory with this data.
     */
    create: XOR<TraitCategoryCreateInput, TraitCategoryUncheckedCreateInput>
    /**
     * In case the TraitCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TraitCategoryUpdateInput, TraitCategoryUncheckedUpdateInput>
  }

  /**
   * TraitCategory delete
   */
  export type TraitCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitCategory
     */
    select?: TraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitCategory
     */
    omit?: TraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitCategoryInclude<ExtArgs> | null
    /**
     * Filter which TraitCategory to delete.
     */
    where: TraitCategoryWhereUniqueInput
  }

  /**
   * TraitCategory deleteMany
   */
  export type TraitCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TraitCategories to delete
     */
    where?: TraitCategoryWhereInput
    /**
     * Limit how many TraitCategories to delete.
     */
    limit?: number
  }

  /**
   * TraitCategory.traits
   */
  export type TraitCategory$traitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitToTraitCategory
     */
    select?: TraitToTraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitToTraitCategory
     */
    omit?: TraitToTraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitToTraitCategoryInclude<ExtArgs> | null
    where?: TraitToTraitCategoryWhereInput
    orderBy?: TraitToTraitCategoryOrderByWithRelationInput | TraitToTraitCategoryOrderByWithRelationInput[]
    cursor?: TraitToTraitCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TraitToTraitCategoryScalarFieldEnum | TraitToTraitCategoryScalarFieldEnum[]
  }

  /**
   * TraitCategory without action
   */
  export type TraitCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitCategory
     */
    select?: TraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitCategory
     */
    omit?: TraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Trait
   */

  export type AggregateTrait = {
    _count: TraitCountAggregateOutputType | null
    _avg: TraitAvgAggregateOutputType | null
    _sum: TraitSumAggregateOutputType | null
    _min: TraitMinAggregateOutputType | null
    _max: TraitMaxAggregateOutputType | null
  }

  export type TraitAvgAggregateOutputType = {
    id: number | null
  }

  export type TraitSumAggregateOutputType = {
    id: number | null
  }

  export type TraitMinAggregateOutputType = {
    id: number | null
    label: string | null
    description: string | null
    URL: string | null
    efoId: string | null
    mondoId: string | null
    hpoId: string | null
    orphaId: string | null
    otherId: string | null
  }

  export type TraitMaxAggregateOutputType = {
    id: number | null
    label: string | null
    description: string | null
    URL: string | null
    efoId: string | null
    mondoId: string | null
    hpoId: string | null
    orphaId: string | null
    otherId: string | null
  }

  export type TraitCountAggregateOutputType = {
    id: number
    label: number
    description: number
    URL: number
    efoId: number
    mondoId: number
    hpoId: number
    orphaId: number
    otherId: number
    _all: number
  }


  export type TraitAvgAggregateInputType = {
    id?: true
  }

  export type TraitSumAggregateInputType = {
    id?: true
  }

  export type TraitMinAggregateInputType = {
    id?: true
    label?: true
    description?: true
    URL?: true
    efoId?: true
    mondoId?: true
    hpoId?: true
    orphaId?: true
    otherId?: true
  }

  export type TraitMaxAggregateInputType = {
    id?: true
    label?: true
    description?: true
    URL?: true
    efoId?: true
    mondoId?: true
    hpoId?: true
    orphaId?: true
    otherId?: true
  }

  export type TraitCountAggregateInputType = {
    id?: true
    label?: true
    description?: true
    URL?: true
    efoId?: true
    mondoId?: true
    hpoId?: true
    orphaId?: true
    otherId?: true
    _all?: true
  }

  export type TraitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trait to aggregate.
     */
    where?: TraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traits to fetch.
     */
    orderBy?: TraitOrderByWithRelationInput | TraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Traits
    **/
    _count?: true | TraitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TraitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TraitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TraitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TraitMaxAggregateInputType
  }

  export type GetTraitAggregateType<T extends TraitAggregateArgs> = {
        [P in keyof T & keyof AggregateTrait]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrait[P]>
      : GetScalarType<T[P], AggregateTrait[P]>
  }




  export type TraitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraitWhereInput
    orderBy?: TraitOrderByWithAggregationInput | TraitOrderByWithAggregationInput[]
    by: TraitScalarFieldEnum[] | TraitScalarFieldEnum
    having?: TraitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TraitCountAggregateInputType | true
    _avg?: TraitAvgAggregateInputType
    _sum?: TraitSumAggregateInputType
    _min?: TraitMinAggregateInputType
    _max?: TraitMaxAggregateInputType
  }

  export type TraitGroupByOutputType = {
    id: number
    label: string
    description: string | null
    URL: string | null
    efoId: string | null
    mondoId: string | null
    hpoId: string | null
    orphaId: string | null
    otherId: string | null
    _count: TraitCountAggregateOutputType | null
    _avg: TraitAvgAggregateOutputType | null
    _sum: TraitSumAggregateOutputType | null
    _min: TraitMinAggregateOutputType | null
    _max: TraitMaxAggregateOutputType | null
  }

  type GetTraitGroupByPayload<T extends TraitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TraitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TraitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TraitGroupByOutputType[P]>
            : GetScalarType<T[P], TraitGroupByOutputType[P]>
        }
      >
    >


  export type TraitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    description?: boolean
    URL?: boolean
    efoId?: boolean
    mondoId?: boolean
    hpoId?: boolean
    orphaId?: boolean
    otherId?: boolean
    prsModels?: boolean | Trait$prsModelsArgs<ExtArgs>
    categories?: boolean | Trait$categoriesArgs<ExtArgs>
    _count?: boolean | TraitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trait"]>



  export type TraitSelectScalar = {
    id?: boolean
    label?: boolean
    description?: boolean
    URL?: boolean
    efoId?: boolean
    mondoId?: boolean
    hpoId?: boolean
    orphaId?: boolean
    otherId?: boolean
  }

  export type TraitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "description" | "URL" | "efoId" | "mondoId" | "hpoId" | "orphaId" | "otherId", ExtArgs["result"]["trait"]>
  export type TraitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prsModels?: boolean | Trait$prsModelsArgs<ExtArgs>
    categories?: boolean | Trait$categoriesArgs<ExtArgs>
    _count?: boolean | TraitCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TraitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trait"
    objects: {
      prsModels: Prisma.$PRSModelToTraitPayload<ExtArgs>[]
      categories: Prisma.$TraitToTraitCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      label: string
      description: string | null
      URL: string | null
      efoId: string | null
      mondoId: string | null
      hpoId: string | null
      orphaId: string | null
      otherId: string | null
    }, ExtArgs["result"]["trait"]>
    composites: {}
  }

  type TraitGetPayload<S extends boolean | null | undefined | TraitDefaultArgs> = $Result.GetResult<Prisma.$TraitPayload, S>

  type TraitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TraitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TraitCountAggregateInputType | true
    }

  export interface TraitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trait'], meta: { name: 'Trait' } }
    /**
     * Find zero or one Trait that matches the filter.
     * @param {TraitFindUniqueArgs} args - Arguments to find a Trait
     * @example
     * // Get one Trait
     * const trait = await prisma.trait.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TraitFindUniqueArgs>(args: SelectSubset<T, TraitFindUniqueArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trait that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TraitFindUniqueOrThrowArgs} args - Arguments to find a Trait
     * @example
     * // Get one Trait
     * const trait = await prisma.trait.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TraitFindUniqueOrThrowArgs>(args: SelectSubset<T, TraitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trait that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitFindFirstArgs} args - Arguments to find a Trait
     * @example
     * // Get one Trait
     * const trait = await prisma.trait.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TraitFindFirstArgs>(args?: SelectSubset<T, TraitFindFirstArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trait that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitFindFirstOrThrowArgs} args - Arguments to find a Trait
     * @example
     * // Get one Trait
     * const trait = await prisma.trait.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TraitFindFirstOrThrowArgs>(args?: SelectSubset<T, TraitFindFirstOrThrowArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Traits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Traits
     * const traits = await prisma.trait.findMany()
     * 
     * // Get first 10 Traits
     * const traits = await prisma.trait.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const traitWithIdOnly = await prisma.trait.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TraitFindManyArgs>(args?: SelectSubset<T, TraitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trait.
     * @param {TraitCreateArgs} args - Arguments to create a Trait.
     * @example
     * // Create one Trait
     * const Trait = await prisma.trait.create({
     *   data: {
     *     // ... data to create a Trait
     *   }
     * })
     * 
     */
    create<T extends TraitCreateArgs>(args: SelectSubset<T, TraitCreateArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Traits.
     * @param {TraitCreateManyArgs} args - Arguments to create many Traits.
     * @example
     * // Create many Traits
     * const trait = await prisma.trait.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TraitCreateManyArgs>(args?: SelectSubset<T, TraitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trait.
     * @param {TraitDeleteArgs} args - Arguments to delete one Trait.
     * @example
     * // Delete one Trait
     * const Trait = await prisma.trait.delete({
     *   where: {
     *     // ... filter to delete one Trait
     *   }
     * })
     * 
     */
    delete<T extends TraitDeleteArgs>(args: SelectSubset<T, TraitDeleteArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trait.
     * @param {TraitUpdateArgs} args - Arguments to update one Trait.
     * @example
     * // Update one Trait
     * const trait = await prisma.trait.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TraitUpdateArgs>(args: SelectSubset<T, TraitUpdateArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Traits.
     * @param {TraitDeleteManyArgs} args - Arguments to filter Traits to delete.
     * @example
     * // Delete a few Traits
     * const { count } = await prisma.trait.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TraitDeleteManyArgs>(args?: SelectSubset<T, TraitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Traits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Traits
     * const trait = await prisma.trait.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TraitUpdateManyArgs>(args: SelectSubset<T, TraitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trait.
     * @param {TraitUpsertArgs} args - Arguments to update or create a Trait.
     * @example
     * // Update or create a Trait
     * const trait = await prisma.trait.upsert({
     *   create: {
     *     // ... data to create a Trait
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trait we want to update
     *   }
     * })
     */
    upsert<T extends TraitUpsertArgs>(args: SelectSubset<T, TraitUpsertArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Traits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitCountArgs} args - Arguments to filter Traits to count.
     * @example
     * // Count the number of Traits
     * const count = await prisma.trait.count({
     *   where: {
     *     // ... the filter for the Traits we want to count
     *   }
     * })
    **/
    count<T extends TraitCountArgs>(
      args?: Subset<T, TraitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TraitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TraitAggregateArgs>(args: Subset<T, TraitAggregateArgs>): Prisma.PrismaPromise<GetTraitAggregateType<T>>

    /**
     * Group by Trait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TraitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TraitGroupByArgs['orderBy'] }
        : { orderBy?: TraitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TraitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTraitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trait model
   */
  readonly fields: TraitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trait.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TraitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prsModels<T extends Trait$prsModelsArgs<ExtArgs> = {}>(args?: Subset<T, Trait$prsModelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PRSModelToTraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends Trait$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Trait$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraitToTraitCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trait model
   */
  interface TraitFieldRefs {
    readonly id: FieldRef<"Trait", 'Int'>
    readonly label: FieldRef<"Trait", 'String'>
    readonly description: FieldRef<"Trait", 'String'>
    readonly URL: FieldRef<"Trait", 'String'>
    readonly efoId: FieldRef<"Trait", 'String'>
    readonly mondoId: FieldRef<"Trait", 'String'>
    readonly hpoId: FieldRef<"Trait", 'String'>
    readonly orphaId: FieldRef<"Trait", 'String'>
    readonly otherId: FieldRef<"Trait", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Trait findUnique
   */
  export type TraitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * Filter, which Trait to fetch.
     */
    where: TraitWhereUniqueInput
  }

  /**
   * Trait findUniqueOrThrow
   */
  export type TraitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * Filter, which Trait to fetch.
     */
    where: TraitWhereUniqueInput
  }

  /**
   * Trait findFirst
   */
  export type TraitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * Filter, which Trait to fetch.
     */
    where?: TraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traits to fetch.
     */
    orderBy?: TraitOrderByWithRelationInput | TraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Traits.
     */
    cursor?: TraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Traits.
     */
    distinct?: TraitScalarFieldEnum | TraitScalarFieldEnum[]
  }

  /**
   * Trait findFirstOrThrow
   */
  export type TraitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * Filter, which Trait to fetch.
     */
    where?: TraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traits to fetch.
     */
    orderBy?: TraitOrderByWithRelationInput | TraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Traits.
     */
    cursor?: TraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Traits.
     */
    distinct?: TraitScalarFieldEnum | TraitScalarFieldEnum[]
  }

  /**
   * Trait findMany
   */
  export type TraitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * Filter, which Traits to fetch.
     */
    where?: TraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traits to fetch.
     */
    orderBy?: TraitOrderByWithRelationInput | TraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Traits.
     */
    cursor?: TraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traits.
     */
    skip?: number
    distinct?: TraitScalarFieldEnum | TraitScalarFieldEnum[]
  }

  /**
   * Trait create
   */
  export type TraitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * The data needed to create a Trait.
     */
    data: XOR<TraitCreateInput, TraitUncheckedCreateInput>
  }

  /**
   * Trait createMany
   */
  export type TraitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Traits.
     */
    data: TraitCreateManyInput | TraitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trait update
   */
  export type TraitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * The data needed to update a Trait.
     */
    data: XOR<TraitUpdateInput, TraitUncheckedUpdateInput>
    /**
     * Choose, which Trait to update.
     */
    where: TraitWhereUniqueInput
  }

  /**
   * Trait updateMany
   */
  export type TraitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Traits.
     */
    data: XOR<TraitUpdateManyMutationInput, TraitUncheckedUpdateManyInput>
    /**
     * Filter which Traits to update
     */
    where?: TraitWhereInput
    /**
     * Limit how many Traits to update.
     */
    limit?: number
  }

  /**
   * Trait upsert
   */
  export type TraitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * The filter to search for the Trait to update in case it exists.
     */
    where: TraitWhereUniqueInput
    /**
     * In case the Trait found by the `where` argument doesn't exist, create a new Trait with this data.
     */
    create: XOR<TraitCreateInput, TraitUncheckedCreateInput>
    /**
     * In case the Trait was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TraitUpdateInput, TraitUncheckedUpdateInput>
  }

  /**
   * Trait delete
   */
  export type TraitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * Filter which Trait to delete.
     */
    where: TraitWhereUniqueInput
  }

  /**
   * Trait deleteMany
   */
  export type TraitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Traits to delete
     */
    where?: TraitWhereInput
    /**
     * Limit how many Traits to delete.
     */
    limit?: number
  }

  /**
   * Trait.prsModels
   */
  export type Trait$prsModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModelToTrait
     */
    select?: PRSModelToTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModelToTrait
     */
    omit?: PRSModelToTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelToTraitInclude<ExtArgs> | null
    where?: PRSModelToTraitWhereInput
    orderBy?: PRSModelToTraitOrderByWithRelationInput | PRSModelToTraitOrderByWithRelationInput[]
    cursor?: PRSModelToTraitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PRSModelToTraitScalarFieldEnum | PRSModelToTraitScalarFieldEnum[]
  }

  /**
   * Trait.categories
   */
  export type Trait$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitToTraitCategory
     */
    select?: TraitToTraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitToTraitCategory
     */
    omit?: TraitToTraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitToTraitCategoryInclude<ExtArgs> | null
    where?: TraitToTraitCategoryWhereInput
    orderBy?: TraitToTraitCategoryOrderByWithRelationInput | TraitToTraitCategoryOrderByWithRelationInput[]
    cursor?: TraitToTraitCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TraitToTraitCategoryScalarFieldEnum | TraitToTraitCategoryScalarFieldEnum[]
  }

  /**
   * Trait without action
   */
  export type TraitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
  }


  /**
   * Model TraitToTraitCategory
   */

  export type AggregateTraitToTraitCategory = {
    _count: TraitToTraitCategoryCountAggregateOutputType | null
    _avg: TraitToTraitCategoryAvgAggregateOutputType | null
    _sum: TraitToTraitCategorySumAggregateOutputType | null
    _min: TraitToTraitCategoryMinAggregateOutputType | null
    _max: TraitToTraitCategoryMaxAggregateOutputType | null
  }

  export type TraitToTraitCategoryAvgAggregateOutputType = {
    traitId: number | null
    traitCategoryId: number | null
  }

  export type TraitToTraitCategorySumAggregateOutputType = {
    traitId: number | null
    traitCategoryId: number | null
  }

  export type TraitToTraitCategoryMinAggregateOutputType = {
    traitId: number | null
    traitCategoryId: number | null
  }

  export type TraitToTraitCategoryMaxAggregateOutputType = {
    traitId: number | null
    traitCategoryId: number | null
  }

  export type TraitToTraitCategoryCountAggregateOutputType = {
    traitId: number
    traitCategoryId: number
    _all: number
  }


  export type TraitToTraitCategoryAvgAggregateInputType = {
    traitId?: true
    traitCategoryId?: true
  }

  export type TraitToTraitCategorySumAggregateInputType = {
    traitId?: true
    traitCategoryId?: true
  }

  export type TraitToTraitCategoryMinAggregateInputType = {
    traitId?: true
    traitCategoryId?: true
  }

  export type TraitToTraitCategoryMaxAggregateInputType = {
    traitId?: true
    traitCategoryId?: true
  }

  export type TraitToTraitCategoryCountAggregateInputType = {
    traitId?: true
    traitCategoryId?: true
    _all?: true
  }

  export type TraitToTraitCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TraitToTraitCategory to aggregate.
     */
    where?: TraitToTraitCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraitToTraitCategories to fetch.
     */
    orderBy?: TraitToTraitCategoryOrderByWithRelationInput | TraitToTraitCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TraitToTraitCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraitToTraitCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraitToTraitCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TraitToTraitCategories
    **/
    _count?: true | TraitToTraitCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TraitToTraitCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TraitToTraitCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TraitToTraitCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TraitToTraitCategoryMaxAggregateInputType
  }

  export type GetTraitToTraitCategoryAggregateType<T extends TraitToTraitCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTraitToTraitCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTraitToTraitCategory[P]>
      : GetScalarType<T[P], AggregateTraitToTraitCategory[P]>
  }




  export type TraitToTraitCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraitToTraitCategoryWhereInput
    orderBy?: TraitToTraitCategoryOrderByWithAggregationInput | TraitToTraitCategoryOrderByWithAggregationInput[]
    by: TraitToTraitCategoryScalarFieldEnum[] | TraitToTraitCategoryScalarFieldEnum
    having?: TraitToTraitCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TraitToTraitCategoryCountAggregateInputType | true
    _avg?: TraitToTraitCategoryAvgAggregateInputType
    _sum?: TraitToTraitCategorySumAggregateInputType
    _min?: TraitToTraitCategoryMinAggregateInputType
    _max?: TraitToTraitCategoryMaxAggregateInputType
  }

  export type TraitToTraitCategoryGroupByOutputType = {
    traitId: number
    traitCategoryId: number
    _count: TraitToTraitCategoryCountAggregateOutputType | null
    _avg: TraitToTraitCategoryAvgAggregateOutputType | null
    _sum: TraitToTraitCategorySumAggregateOutputType | null
    _min: TraitToTraitCategoryMinAggregateOutputType | null
    _max: TraitToTraitCategoryMaxAggregateOutputType | null
  }

  type GetTraitToTraitCategoryGroupByPayload<T extends TraitToTraitCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TraitToTraitCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TraitToTraitCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TraitToTraitCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], TraitToTraitCategoryGroupByOutputType[P]>
        }
      >
    >


  export type TraitToTraitCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    traitId?: boolean
    traitCategoryId?: boolean
    traitCategory?: boolean | TraitCategoryDefaultArgs<ExtArgs>
    trait?: boolean | TraitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["traitToTraitCategory"]>



  export type TraitToTraitCategorySelectScalar = {
    traitId?: boolean
    traitCategoryId?: boolean
  }

  export type TraitToTraitCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"traitId" | "traitCategoryId", ExtArgs["result"]["traitToTraitCategory"]>
  export type TraitToTraitCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    traitCategory?: boolean | TraitCategoryDefaultArgs<ExtArgs>
    trait?: boolean | TraitDefaultArgs<ExtArgs>
  }

  export type $TraitToTraitCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TraitToTraitCategory"
    objects: {
      traitCategory: Prisma.$TraitCategoryPayload<ExtArgs>
      trait: Prisma.$TraitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      traitId: number
      traitCategoryId: number
    }, ExtArgs["result"]["traitToTraitCategory"]>
    composites: {}
  }

  type TraitToTraitCategoryGetPayload<S extends boolean | null | undefined | TraitToTraitCategoryDefaultArgs> = $Result.GetResult<Prisma.$TraitToTraitCategoryPayload, S>

  type TraitToTraitCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TraitToTraitCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TraitToTraitCategoryCountAggregateInputType | true
    }

  export interface TraitToTraitCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TraitToTraitCategory'], meta: { name: 'TraitToTraitCategory' } }
    /**
     * Find zero or one TraitToTraitCategory that matches the filter.
     * @param {TraitToTraitCategoryFindUniqueArgs} args - Arguments to find a TraitToTraitCategory
     * @example
     * // Get one TraitToTraitCategory
     * const traitToTraitCategory = await prisma.traitToTraitCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TraitToTraitCategoryFindUniqueArgs>(args: SelectSubset<T, TraitToTraitCategoryFindUniqueArgs<ExtArgs>>): Prisma__TraitToTraitCategoryClient<$Result.GetResult<Prisma.$TraitToTraitCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TraitToTraitCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TraitToTraitCategoryFindUniqueOrThrowArgs} args - Arguments to find a TraitToTraitCategory
     * @example
     * // Get one TraitToTraitCategory
     * const traitToTraitCategory = await prisma.traitToTraitCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TraitToTraitCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, TraitToTraitCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TraitToTraitCategoryClient<$Result.GetResult<Prisma.$TraitToTraitCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TraitToTraitCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitToTraitCategoryFindFirstArgs} args - Arguments to find a TraitToTraitCategory
     * @example
     * // Get one TraitToTraitCategory
     * const traitToTraitCategory = await prisma.traitToTraitCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TraitToTraitCategoryFindFirstArgs>(args?: SelectSubset<T, TraitToTraitCategoryFindFirstArgs<ExtArgs>>): Prisma__TraitToTraitCategoryClient<$Result.GetResult<Prisma.$TraitToTraitCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TraitToTraitCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitToTraitCategoryFindFirstOrThrowArgs} args - Arguments to find a TraitToTraitCategory
     * @example
     * // Get one TraitToTraitCategory
     * const traitToTraitCategory = await prisma.traitToTraitCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TraitToTraitCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, TraitToTraitCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TraitToTraitCategoryClient<$Result.GetResult<Prisma.$TraitToTraitCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TraitToTraitCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitToTraitCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TraitToTraitCategories
     * const traitToTraitCategories = await prisma.traitToTraitCategory.findMany()
     * 
     * // Get first 10 TraitToTraitCategories
     * const traitToTraitCategories = await prisma.traitToTraitCategory.findMany({ take: 10 })
     * 
     * // Only select the `traitId`
     * const traitToTraitCategoryWithTraitIdOnly = await prisma.traitToTraitCategory.findMany({ select: { traitId: true } })
     * 
     */
    findMany<T extends TraitToTraitCategoryFindManyArgs>(args?: SelectSubset<T, TraitToTraitCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraitToTraitCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TraitToTraitCategory.
     * @param {TraitToTraitCategoryCreateArgs} args - Arguments to create a TraitToTraitCategory.
     * @example
     * // Create one TraitToTraitCategory
     * const TraitToTraitCategory = await prisma.traitToTraitCategory.create({
     *   data: {
     *     // ... data to create a TraitToTraitCategory
     *   }
     * })
     * 
     */
    create<T extends TraitToTraitCategoryCreateArgs>(args: SelectSubset<T, TraitToTraitCategoryCreateArgs<ExtArgs>>): Prisma__TraitToTraitCategoryClient<$Result.GetResult<Prisma.$TraitToTraitCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TraitToTraitCategories.
     * @param {TraitToTraitCategoryCreateManyArgs} args - Arguments to create many TraitToTraitCategories.
     * @example
     * // Create many TraitToTraitCategories
     * const traitToTraitCategory = await prisma.traitToTraitCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TraitToTraitCategoryCreateManyArgs>(args?: SelectSubset<T, TraitToTraitCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TraitToTraitCategory.
     * @param {TraitToTraitCategoryDeleteArgs} args - Arguments to delete one TraitToTraitCategory.
     * @example
     * // Delete one TraitToTraitCategory
     * const TraitToTraitCategory = await prisma.traitToTraitCategory.delete({
     *   where: {
     *     // ... filter to delete one TraitToTraitCategory
     *   }
     * })
     * 
     */
    delete<T extends TraitToTraitCategoryDeleteArgs>(args: SelectSubset<T, TraitToTraitCategoryDeleteArgs<ExtArgs>>): Prisma__TraitToTraitCategoryClient<$Result.GetResult<Prisma.$TraitToTraitCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TraitToTraitCategory.
     * @param {TraitToTraitCategoryUpdateArgs} args - Arguments to update one TraitToTraitCategory.
     * @example
     * // Update one TraitToTraitCategory
     * const traitToTraitCategory = await prisma.traitToTraitCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TraitToTraitCategoryUpdateArgs>(args: SelectSubset<T, TraitToTraitCategoryUpdateArgs<ExtArgs>>): Prisma__TraitToTraitCategoryClient<$Result.GetResult<Prisma.$TraitToTraitCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TraitToTraitCategories.
     * @param {TraitToTraitCategoryDeleteManyArgs} args - Arguments to filter TraitToTraitCategories to delete.
     * @example
     * // Delete a few TraitToTraitCategories
     * const { count } = await prisma.traitToTraitCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TraitToTraitCategoryDeleteManyArgs>(args?: SelectSubset<T, TraitToTraitCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TraitToTraitCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitToTraitCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TraitToTraitCategories
     * const traitToTraitCategory = await prisma.traitToTraitCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TraitToTraitCategoryUpdateManyArgs>(args: SelectSubset<T, TraitToTraitCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TraitToTraitCategory.
     * @param {TraitToTraitCategoryUpsertArgs} args - Arguments to update or create a TraitToTraitCategory.
     * @example
     * // Update or create a TraitToTraitCategory
     * const traitToTraitCategory = await prisma.traitToTraitCategory.upsert({
     *   create: {
     *     // ... data to create a TraitToTraitCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TraitToTraitCategory we want to update
     *   }
     * })
     */
    upsert<T extends TraitToTraitCategoryUpsertArgs>(args: SelectSubset<T, TraitToTraitCategoryUpsertArgs<ExtArgs>>): Prisma__TraitToTraitCategoryClient<$Result.GetResult<Prisma.$TraitToTraitCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TraitToTraitCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitToTraitCategoryCountArgs} args - Arguments to filter TraitToTraitCategories to count.
     * @example
     * // Count the number of TraitToTraitCategories
     * const count = await prisma.traitToTraitCategory.count({
     *   where: {
     *     // ... the filter for the TraitToTraitCategories we want to count
     *   }
     * })
    **/
    count<T extends TraitToTraitCategoryCountArgs>(
      args?: Subset<T, TraitToTraitCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TraitToTraitCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TraitToTraitCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitToTraitCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TraitToTraitCategoryAggregateArgs>(args: Subset<T, TraitToTraitCategoryAggregateArgs>): Prisma.PrismaPromise<GetTraitToTraitCategoryAggregateType<T>>

    /**
     * Group by TraitToTraitCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitToTraitCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TraitToTraitCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TraitToTraitCategoryGroupByArgs['orderBy'] }
        : { orderBy?: TraitToTraitCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TraitToTraitCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTraitToTraitCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TraitToTraitCategory model
   */
  readonly fields: TraitToTraitCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TraitToTraitCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TraitToTraitCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    traitCategory<T extends TraitCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TraitCategoryDefaultArgs<ExtArgs>>): Prisma__TraitCategoryClient<$Result.GetResult<Prisma.$TraitCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    trait<T extends TraitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TraitDefaultArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TraitToTraitCategory model
   */
  interface TraitToTraitCategoryFieldRefs {
    readonly traitId: FieldRef<"TraitToTraitCategory", 'Int'>
    readonly traitCategoryId: FieldRef<"TraitToTraitCategory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TraitToTraitCategory findUnique
   */
  export type TraitToTraitCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitToTraitCategory
     */
    select?: TraitToTraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitToTraitCategory
     */
    omit?: TraitToTraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitToTraitCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TraitToTraitCategory to fetch.
     */
    where: TraitToTraitCategoryWhereUniqueInput
  }

  /**
   * TraitToTraitCategory findUniqueOrThrow
   */
  export type TraitToTraitCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitToTraitCategory
     */
    select?: TraitToTraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitToTraitCategory
     */
    omit?: TraitToTraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitToTraitCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TraitToTraitCategory to fetch.
     */
    where: TraitToTraitCategoryWhereUniqueInput
  }

  /**
   * TraitToTraitCategory findFirst
   */
  export type TraitToTraitCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitToTraitCategory
     */
    select?: TraitToTraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitToTraitCategory
     */
    omit?: TraitToTraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitToTraitCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TraitToTraitCategory to fetch.
     */
    where?: TraitToTraitCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraitToTraitCategories to fetch.
     */
    orderBy?: TraitToTraitCategoryOrderByWithRelationInput | TraitToTraitCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TraitToTraitCategories.
     */
    cursor?: TraitToTraitCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraitToTraitCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraitToTraitCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TraitToTraitCategories.
     */
    distinct?: TraitToTraitCategoryScalarFieldEnum | TraitToTraitCategoryScalarFieldEnum[]
  }

  /**
   * TraitToTraitCategory findFirstOrThrow
   */
  export type TraitToTraitCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitToTraitCategory
     */
    select?: TraitToTraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitToTraitCategory
     */
    omit?: TraitToTraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitToTraitCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TraitToTraitCategory to fetch.
     */
    where?: TraitToTraitCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraitToTraitCategories to fetch.
     */
    orderBy?: TraitToTraitCategoryOrderByWithRelationInput | TraitToTraitCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TraitToTraitCategories.
     */
    cursor?: TraitToTraitCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraitToTraitCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraitToTraitCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TraitToTraitCategories.
     */
    distinct?: TraitToTraitCategoryScalarFieldEnum | TraitToTraitCategoryScalarFieldEnum[]
  }

  /**
   * TraitToTraitCategory findMany
   */
  export type TraitToTraitCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitToTraitCategory
     */
    select?: TraitToTraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitToTraitCategory
     */
    omit?: TraitToTraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitToTraitCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TraitToTraitCategories to fetch.
     */
    where?: TraitToTraitCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraitToTraitCategories to fetch.
     */
    orderBy?: TraitToTraitCategoryOrderByWithRelationInput | TraitToTraitCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TraitToTraitCategories.
     */
    cursor?: TraitToTraitCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraitToTraitCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraitToTraitCategories.
     */
    skip?: number
    distinct?: TraitToTraitCategoryScalarFieldEnum | TraitToTraitCategoryScalarFieldEnum[]
  }

  /**
   * TraitToTraitCategory create
   */
  export type TraitToTraitCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitToTraitCategory
     */
    select?: TraitToTraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitToTraitCategory
     */
    omit?: TraitToTraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitToTraitCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a TraitToTraitCategory.
     */
    data: XOR<TraitToTraitCategoryCreateInput, TraitToTraitCategoryUncheckedCreateInput>
  }

  /**
   * TraitToTraitCategory createMany
   */
  export type TraitToTraitCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TraitToTraitCategories.
     */
    data: TraitToTraitCategoryCreateManyInput | TraitToTraitCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TraitToTraitCategory update
   */
  export type TraitToTraitCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitToTraitCategory
     */
    select?: TraitToTraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitToTraitCategory
     */
    omit?: TraitToTraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitToTraitCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a TraitToTraitCategory.
     */
    data: XOR<TraitToTraitCategoryUpdateInput, TraitToTraitCategoryUncheckedUpdateInput>
    /**
     * Choose, which TraitToTraitCategory to update.
     */
    where: TraitToTraitCategoryWhereUniqueInput
  }

  /**
   * TraitToTraitCategory updateMany
   */
  export type TraitToTraitCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TraitToTraitCategories.
     */
    data: XOR<TraitToTraitCategoryUpdateManyMutationInput, TraitToTraitCategoryUncheckedUpdateManyInput>
    /**
     * Filter which TraitToTraitCategories to update
     */
    where?: TraitToTraitCategoryWhereInput
    /**
     * Limit how many TraitToTraitCategories to update.
     */
    limit?: number
  }

  /**
   * TraitToTraitCategory upsert
   */
  export type TraitToTraitCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitToTraitCategory
     */
    select?: TraitToTraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitToTraitCategory
     */
    omit?: TraitToTraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitToTraitCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the TraitToTraitCategory to update in case it exists.
     */
    where: TraitToTraitCategoryWhereUniqueInput
    /**
     * In case the TraitToTraitCategory found by the `where` argument doesn't exist, create a new TraitToTraitCategory with this data.
     */
    create: XOR<TraitToTraitCategoryCreateInput, TraitToTraitCategoryUncheckedCreateInput>
    /**
     * In case the TraitToTraitCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TraitToTraitCategoryUpdateInput, TraitToTraitCategoryUncheckedUpdateInput>
  }

  /**
   * TraitToTraitCategory delete
   */
  export type TraitToTraitCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitToTraitCategory
     */
    select?: TraitToTraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitToTraitCategory
     */
    omit?: TraitToTraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitToTraitCategoryInclude<ExtArgs> | null
    /**
     * Filter which TraitToTraitCategory to delete.
     */
    where: TraitToTraitCategoryWhereUniqueInput
  }

  /**
   * TraitToTraitCategory deleteMany
   */
  export type TraitToTraitCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TraitToTraitCategories to delete
     */
    where?: TraitToTraitCategoryWhereInput
    /**
     * Limit how many TraitToTraitCategories to delete.
     */
    limit?: number
  }

  /**
   * TraitToTraitCategory without action
   */
  export type TraitToTraitCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitToTraitCategory
     */
    select?: TraitToTraitCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitToTraitCategory
     */
    omit?: TraitToTraitCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitToTraitCategoryInclude<ExtArgs> | null
  }


  /**
   * Model PRSModel
   */

  export type AggregatePRSModel = {
    _count: PRSModelCountAggregateOutputType | null
    _avg: PRSModelAvgAggregateOutputType | null
    _sum: PRSModelSumAggregateOutputType | null
    _min: PRSModelMinAggregateOutputType | null
    _max: PRSModelMaxAggregateOutputType | null
  }

  export type PRSModelAvgAggregateOutputType = {
    id: number | null
    numberOfSNP: number | null
    publicationId: number | null
  }

  export type PRSModelSumAggregateOutputType = {
    id: number | null
    numberOfSNP: number | null
    publicationId: number | null
  }

  export type PRSModelMinAggregateOutputType = {
    id: number | null
    name: string | null
    numberOfSNP: number | null
    pgscId: string | null
    pgscURL: string | null
    publicationId: number | null
  }

  export type PRSModelMaxAggregateOutputType = {
    id: number | null
    name: string | null
    numberOfSNP: number | null
    pgscId: string | null
    pgscURL: string | null
    publicationId: number | null
  }

  export type PRSModelCountAggregateOutputType = {
    id: number
    name: number
    numberOfSNP: number
    pgscId: number
    pgscURL: number
    publicationId: number
    _all: number
  }


  export type PRSModelAvgAggregateInputType = {
    id?: true
    numberOfSNP?: true
    publicationId?: true
  }

  export type PRSModelSumAggregateInputType = {
    id?: true
    numberOfSNP?: true
    publicationId?: true
  }

  export type PRSModelMinAggregateInputType = {
    id?: true
    name?: true
    numberOfSNP?: true
    pgscId?: true
    pgscURL?: true
    publicationId?: true
  }

  export type PRSModelMaxAggregateInputType = {
    id?: true
    name?: true
    numberOfSNP?: true
    pgscId?: true
    pgscURL?: true
    publicationId?: true
  }

  export type PRSModelCountAggregateInputType = {
    id?: true
    name?: true
    numberOfSNP?: true
    pgscId?: true
    pgscURL?: true
    publicationId?: true
    _all?: true
  }

  export type PRSModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PRSModel to aggregate.
     */
    where?: PRSModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRSModels to fetch.
     */
    orderBy?: PRSModelOrderByWithRelationInput | PRSModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PRSModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRSModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRSModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PRSModels
    **/
    _count?: true | PRSModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PRSModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PRSModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PRSModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PRSModelMaxAggregateInputType
  }

  export type GetPRSModelAggregateType<T extends PRSModelAggregateArgs> = {
        [P in keyof T & keyof AggregatePRSModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePRSModel[P]>
      : GetScalarType<T[P], AggregatePRSModel[P]>
  }




  export type PRSModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PRSModelWhereInput
    orderBy?: PRSModelOrderByWithAggregationInput | PRSModelOrderByWithAggregationInput[]
    by: PRSModelScalarFieldEnum[] | PRSModelScalarFieldEnum
    having?: PRSModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PRSModelCountAggregateInputType | true
    _avg?: PRSModelAvgAggregateInputType
    _sum?: PRSModelSumAggregateInputType
    _min?: PRSModelMinAggregateInputType
    _max?: PRSModelMaxAggregateInputType
  }

  export type PRSModelGroupByOutputType = {
    id: number
    name: string
    numberOfSNP: number | null
    pgscId: string | null
    pgscURL: string | null
    publicationId: number
    _count: PRSModelCountAggregateOutputType | null
    _avg: PRSModelAvgAggregateOutputType | null
    _sum: PRSModelSumAggregateOutputType | null
    _min: PRSModelMinAggregateOutputType | null
    _max: PRSModelMaxAggregateOutputType | null
  }

  type GetPRSModelGroupByPayload<T extends PRSModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PRSModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PRSModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PRSModelGroupByOutputType[P]>
            : GetScalarType<T[P], PRSModelGroupByOutputType[P]>
        }
      >
    >


  export type PRSModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    numberOfSNP?: boolean
    pgscId?: boolean
    pgscURL?: boolean
    publicationId?: boolean
    broadAncestryCategories?: boolean | PRSModel$broadAncestryCategoriesArgs<ExtArgs>
    DevelopmentPopulationSamples?: boolean | PRSModel$DevelopmentPopulationSamplesArgs<ExtArgs>
    modelEvaluations?: boolean | PRSModel$modelEvaluationsArgs<ExtArgs>
    publication?: boolean | PublicationDefaultArgs<ExtArgs>
    traits?: boolean | PRSModel$traitsArgs<ExtArgs>
    prioritizedModels?: boolean | PRSModel$prioritizedModelsArgs<ExtArgs>
    scoringFiles?: boolean | PRSModel$scoringFilesArgs<ExtArgs>
    _count?: boolean | PRSModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pRSModel"]>



  export type PRSModelSelectScalar = {
    id?: boolean
    name?: boolean
    numberOfSNP?: boolean
    pgscId?: boolean
    pgscURL?: boolean
    publicationId?: boolean
  }

  export type PRSModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "numberOfSNP" | "pgscId" | "pgscURL" | "publicationId", ExtArgs["result"]["pRSModel"]>
  export type PRSModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    broadAncestryCategories?: boolean | PRSModel$broadAncestryCategoriesArgs<ExtArgs>
    DevelopmentPopulationSamples?: boolean | PRSModel$DevelopmentPopulationSamplesArgs<ExtArgs>
    modelEvaluations?: boolean | PRSModel$modelEvaluationsArgs<ExtArgs>
    publication?: boolean | PublicationDefaultArgs<ExtArgs>
    traits?: boolean | PRSModel$traitsArgs<ExtArgs>
    prioritizedModels?: boolean | PRSModel$prioritizedModelsArgs<ExtArgs>
    scoringFiles?: boolean | PRSModel$scoringFilesArgs<ExtArgs>
    _count?: boolean | PRSModelCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PRSModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PRSModel"
    objects: {
      broadAncestryCategories: Prisma.$BroadAncestryInModelPayload<ExtArgs>[]
      DevelopmentPopulationSamples: Prisma.$DevelopmentPopulationSamplePayload<ExtArgs>[]
      modelEvaluations: Prisma.$ModelEvaluationPayload<ExtArgs>[]
      publication: Prisma.$PublicationPayload<ExtArgs>
      traits: Prisma.$PRSModelToTraitPayload<ExtArgs>[]
      prioritizedModels: Prisma.$PrioritizedModelPayload<ExtArgs>[]
      scoringFiles: Prisma.$ScoringFilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      numberOfSNP: number | null
      pgscId: string | null
      pgscURL: string | null
      publicationId: number
    }, ExtArgs["result"]["pRSModel"]>
    composites: {}
  }

  type PRSModelGetPayload<S extends boolean | null | undefined | PRSModelDefaultArgs> = $Result.GetResult<Prisma.$PRSModelPayload, S>

  type PRSModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PRSModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PRSModelCountAggregateInputType | true
    }

  export interface PRSModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PRSModel'], meta: { name: 'PRSModel' } }
    /**
     * Find zero or one PRSModel that matches the filter.
     * @param {PRSModelFindUniqueArgs} args - Arguments to find a PRSModel
     * @example
     * // Get one PRSModel
     * const pRSModel = await prisma.pRSModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PRSModelFindUniqueArgs>(args: SelectSubset<T, PRSModelFindUniqueArgs<ExtArgs>>): Prisma__PRSModelClient<$Result.GetResult<Prisma.$PRSModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PRSModel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PRSModelFindUniqueOrThrowArgs} args - Arguments to find a PRSModel
     * @example
     * // Get one PRSModel
     * const pRSModel = await prisma.pRSModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PRSModelFindUniqueOrThrowArgs>(args: SelectSubset<T, PRSModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PRSModelClient<$Result.GetResult<Prisma.$PRSModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PRSModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSModelFindFirstArgs} args - Arguments to find a PRSModel
     * @example
     * // Get one PRSModel
     * const pRSModel = await prisma.pRSModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PRSModelFindFirstArgs>(args?: SelectSubset<T, PRSModelFindFirstArgs<ExtArgs>>): Prisma__PRSModelClient<$Result.GetResult<Prisma.$PRSModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PRSModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSModelFindFirstOrThrowArgs} args - Arguments to find a PRSModel
     * @example
     * // Get one PRSModel
     * const pRSModel = await prisma.pRSModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PRSModelFindFirstOrThrowArgs>(args?: SelectSubset<T, PRSModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__PRSModelClient<$Result.GetResult<Prisma.$PRSModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PRSModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PRSModels
     * const pRSModels = await prisma.pRSModel.findMany()
     * 
     * // Get first 10 PRSModels
     * const pRSModels = await prisma.pRSModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pRSModelWithIdOnly = await prisma.pRSModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PRSModelFindManyArgs>(args?: SelectSubset<T, PRSModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PRSModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PRSModel.
     * @param {PRSModelCreateArgs} args - Arguments to create a PRSModel.
     * @example
     * // Create one PRSModel
     * const PRSModel = await prisma.pRSModel.create({
     *   data: {
     *     // ... data to create a PRSModel
     *   }
     * })
     * 
     */
    create<T extends PRSModelCreateArgs>(args: SelectSubset<T, PRSModelCreateArgs<ExtArgs>>): Prisma__PRSModelClient<$Result.GetResult<Prisma.$PRSModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PRSModels.
     * @param {PRSModelCreateManyArgs} args - Arguments to create many PRSModels.
     * @example
     * // Create many PRSModels
     * const pRSModel = await prisma.pRSModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PRSModelCreateManyArgs>(args?: SelectSubset<T, PRSModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PRSModel.
     * @param {PRSModelDeleteArgs} args - Arguments to delete one PRSModel.
     * @example
     * // Delete one PRSModel
     * const PRSModel = await prisma.pRSModel.delete({
     *   where: {
     *     // ... filter to delete one PRSModel
     *   }
     * })
     * 
     */
    delete<T extends PRSModelDeleteArgs>(args: SelectSubset<T, PRSModelDeleteArgs<ExtArgs>>): Prisma__PRSModelClient<$Result.GetResult<Prisma.$PRSModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PRSModel.
     * @param {PRSModelUpdateArgs} args - Arguments to update one PRSModel.
     * @example
     * // Update one PRSModel
     * const pRSModel = await prisma.pRSModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PRSModelUpdateArgs>(args: SelectSubset<T, PRSModelUpdateArgs<ExtArgs>>): Prisma__PRSModelClient<$Result.GetResult<Prisma.$PRSModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PRSModels.
     * @param {PRSModelDeleteManyArgs} args - Arguments to filter PRSModels to delete.
     * @example
     * // Delete a few PRSModels
     * const { count } = await prisma.pRSModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PRSModelDeleteManyArgs>(args?: SelectSubset<T, PRSModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PRSModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PRSModels
     * const pRSModel = await prisma.pRSModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PRSModelUpdateManyArgs>(args: SelectSubset<T, PRSModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PRSModel.
     * @param {PRSModelUpsertArgs} args - Arguments to update or create a PRSModel.
     * @example
     * // Update or create a PRSModel
     * const pRSModel = await prisma.pRSModel.upsert({
     *   create: {
     *     // ... data to create a PRSModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PRSModel we want to update
     *   }
     * })
     */
    upsert<T extends PRSModelUpsertArgs>(args: SelectSubset<T, PRSModelUpsertArgs<ExtArgs>>): Prisma__PRSModelClient<$Result.GetResult<Prisma.$PRSModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PRSModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSModelCountArgs} args - Arguments to filter PRSModels to count.
     * @example
     * // Count the number of PRSModels
     * const count = await prisma.pRSModel.count({
     *   where: {
     *     // ... the filter for the PRSModels we want to count
     *   }
     * })
    **/
    count<T extends PRSModelCountArgs>(
      args?: Subset<T, PRSModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PRSModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PRSModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PRSModelAggregateArgs>(args: Subset<T, PRSModelAggregateArgs>): Prisma.PrismaPromise<GetPRSModelAggregateType<T>>

    /**
     * Group by PRSModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PRSModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PRSModelGroupByArgs['orderBy'] }
        : { orderBy?: PRSModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PRSModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPRSModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PRSModel model
   */
  readonly fields: PRSModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PRSModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PRSModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    broadAncestryCategories<T extends PRSModel$broadAncestryCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, PRSModel$broadAncestryCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BroadAncestryInModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DevelopmentPopulationSamples<T extends PRSModel$DevelopmentPopulationSamplesArgs<ExtArgs> = {}>(args?: Subset<T, PRSModel$DevelopmentPopulationSamplesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevelopmentPopulationSamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modelEvaluations<T extends PRSModel$modelEvaluationsArgs<ExtArgs> = {}>(args?: Subset<T, PRSModel$modelEvaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    publication<T extends PublicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PublicationDefaultArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    traits<T extends PRSModel$traitsArgs<ExtArgs> = {}>(args?: Subset<T, PRSModel$traitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PRSModelToTraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prioritizedModels<T extends PRSModel$prioritizedModelsArgs<ExtArgs> = {}>(args?: Subset<T, PRSModel$prioritizedModelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrioritizedModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scoringFiles<T extends PRSModel$scoringFilesArgs<ExtArgs> = {}>(args?: Subset<T, PRSModel$scoringFilesArgs<ExtArgs>>): Prisma__ScoringFileClient<$Result.GetResult<Prisma.$ScoringFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PRSModel model
   */
  interface PRSModelFieldRefs {
    readonly id: FieldRef<"PRSModel", 'Int'>
    readonly name: FieldRef<"PRSModel", 'String'>
    readonly numberOfSNP: FieldRef<"PRSModel", 'Int'>
    readonly pgscId: FieldRef<"PRSModel", 'String'>
    readonly pgscURL: FieldRef<"PRSModel", 'String'>
    readonly publicationId: FieldRef<"PRSModel", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PRSModel findUnique
   */
  export type PRSModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModel
     */
    select?: PRSModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModel
     */
    omit?: PRSModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelInclude<ExtArgs> | null
    /**
     * Filter, which PRSModel to fetch.
     */
    where: PRSModelWhereUniqueInput
  }

  /**
   * PRSModel findUniqueOrThrow
   */
  export type PRSModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModel
     */
    select?: PRSModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModel
     */
    omit?: PRSModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelInclude<ExtArgs> | null
    /**
     * Filter, which PRSModel to fetch.
     */
    where: PRSModelWhereUniqueInput
  }

  /**
   * PRSModel findFirst
   */
  export type PRSModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModel
     */
    select?: PRSModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModel
     */
    omit?: PRSModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelInclude<ExtArgs> | null
    /**
     * Filter, which PRSModel to fetch.
     */
    where?: PRSModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRSModels to fetch.
     */
    orderBy?: PRSModelOrderByWithRelationInput | PRSModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PRSModels.
     */
    cursor?: PRSModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRSModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRSModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PRSModels.
     */
    distinct?: PRSModelScalarFieldEnum | PRSModelScalarFieldEnum[]
  }

  /**
   * PRSModel findFirstOrThrow
   */
  export type PRSModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModel
     */
    select?: PRSModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModel
     */
    omit?: PRSModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelInclude<ExtArgs> | null
    /**
     * Filter, which PRSModel to fetch.
     */
    where?: PRSModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRSModels to fetch.
     */
    orderBy?: PRSModelOrderByWithRelationInput | PRSModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PRSModels.
     */
    cursor?: PRSModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRSModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRSModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PRSModels.
     */
    distinct?: PRSModelScalarFieldEnum | PRSModelScalarFieldEnum[]
  }

  /**
   * PRSModel findMany
   */
  export type PRSModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModel
     */
    select?: PRSModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModel
     */
    omit?: PRSModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelInclude<ExtArgs> | null
    /**
     * Filter, which PRSModels to fetch.
     */
    where?: PRSModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRSModels to fetch.
     */
    orderBy?: PRSModelOrderByWithRelationInput | PRSModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PRSModels.
     */
    cursor?: PRSModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRSModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRSModels.
     */
    skip?: number
    distinct?: PRSModelScalarFieldEnum | PRSModelScalarFieldEnum[]
  }

  /**
   * PRSModel create
   */
  export type PRSModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModel
     */
    select?: PRSModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModel
     */
    omit?: PRSModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelInclude<ExtArgs> | null
    /**
     * The data needed to create a PRSModel.
     */
    data: XOR<PRSModelCreateInput, PRSModelUncheckedCreateInput>
  }

  /**
   * PRSModel createMany
   */
  export type PRSModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PRSModels.
     */
    data: PRSModelCreateManyInput | PRSModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PRSModel update
   */
  export type PRSModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModel
     */
    select?: PRSModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModel
     */
    omit?: PRSModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelInclude<ExtArgs> | null
    /**
     * The data needed to update a PRSModel.
     */
    data: XOR<PRSModelUpdateInput, PRSModelUncheckedUpdateInput>
    /**
     * Choose, which PRSModel to update.
     */
    where: PRSModelWhereUniqueInput
  }

  /**
   * PRSModel updateMany
   */
  export type PRSModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PRSModels.
     */
    data: XOR<PRSModelUpdateManyMutationInput, PRSModelUncheckedUpdateManyInput>
    /**
     * Filter which PRSModels to update
     */
    where?: PRSModelWhereInput
    /**
     * Limit how many PRSModels to update.
     */
    limit?: number
  }

  /**
   * PRSModel upsert
   */
  export type PRSModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModel
     */
    select?: PRSModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModel
     */
    omit?: PRSModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelInclude<ExtArgs> | null
    /**
     * The filter to search for the PRSModel to update in case it exists.
     */
    where: PRSModelWhereUniqueInput
    /**
     * In case the PRSModel found by the `where` argument doesn't exist, create a new PRSModel with this data.
     */
    create: XOR<PRSModelCreateInput, PRSModelUncheckedCreateInput>
    /**
     * In case the PRSModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PRSModelUpdateInput, PRSModelUncheckedUpdateInput>
  }

  /**
   * PRSModel delete
   */
  export type PRSModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModel
     */
    select?: PRSModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModel
     */
    omit?: PRSModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelInclude<ExtArgs> | null
    /**
     * Filter which PRSModel to delete.
     */
    where: PRSModelWhereUniqueInput
  }

  /**
   * PRSModel deleteMany
   */
  export type PRSModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PRSModels to delete
     */
    where?: PRSModelWhereInput
    /**
     * Limit how many PRSModels to delete.
     */
    limit?: number
  }

  /**
   * PRSModel.broadAncestryCategories
   */
  export type PRSModel$broadAncestryCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInModel
     */
    select?: BroadAncestryInModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInModel
     */
    omit?: BroadAncestryInModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInModelInclude<ExtArgs> | null
    where?: BroadAncestryInModelWhereInput
    orderBy?: BroadAncestryInModelOrderByWithRelationInput | BroadAncestryInModelOrderByWithRelationInput[]
    cursor?: BroadAncestryInModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BroadAncestryInModelScalarFieldEnum | BroadAncestryInModelScalarFieldEnum[]
  }

  /**
   * PRSModel.DevelopmentPopulationSamples
   */
  export type PRSModel$DevelopmentPopulationSamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPopulationSample
     */
    select?: DevelopmentPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPopulationSample
     */
    omit?: DevelopmentPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevelopmentPopulationSampleInclude<ExtArgs> | null
    where?: DevelopmentPopulationSampleWhereInput
    orderBy?: DevelopmentPopulationSampleOrderByWithRelationInput | DevelopmentPopulationSampleOrderByWithRelationInput[]
    cursor?: DevelopmentPopulationSampleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DevelopmentPopulationSampleScalarFieldEnum | DevelopmentPopulationSampleScalarFieldEnum[]
  }

  /**
   * PRSModel.modelEvaluations
   */
  export type PRSModel$modelEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEvaluation
     */
    select?: ModelEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEvaluation
     */
    omit?: ModelEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEvaluationInclude<ExtArgs> | null
    where?: ModelEvaluationWhereInput
    orderBy?: ModelEvaluationOrderByWithRelationInput | ModelEvaluationOrderByWithRelationInput[]
    cursor?: ModelEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelEvaluationScalarFieldEnum | ModelEvaluationScalarFieldEnum[]
  }

  /**
   * PRSModel.traits
   */
  export type PRSModel$traitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModelToTrait
     */
    select?: PRSModelToTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModelToTrait
     */
    omit?: PRSModelToTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelToTraitInclude<ExtArgs> | null
    where?: PRSModelToTraitWhereInput
    orderBy?: PRSModelToTraitOrderByWithRelationInput | PRSModelToTraitOrderByWithRelationInput[]
    cursor?: PRSModelToTraitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PRSModelToTraitScalarFieldEnum | PRSModelToTraitScalarFieldEnum[]
  }

  /**
   * PRSModel.prioritizedModels
   */
  export type PRSModel$prioritizedModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrioritizedModel
     */
    select?: PrioritizedModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrioritizedModel
     */
    omit?: PrioritizedModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrioritizedModelInclude<ExtArgs> | null
    where?: PrioritizedModelWhereInput
    orderBy?: PrioritizedModelOrderByWithRelationInput | PrioritizedModelOrderByWithRelationInput[]
    cursor?: PrioritizedModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrioritizedModelScalarFieldEnum | PrioritizedModelScalarFieldEnum[]
  }

  /**
   * PRSModel.scoringFiles
   */
  export type PRSModel$scoringFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringFile
     */
    select?: ScoringFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringFile
     */
    omit?: ScoringFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringFileInclude<ExtArgs> | null
    where?: ScoringFileWhereInput
  }

  /**
   * PRSModel without action
   */
  export type PRSModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModel
     */
    select?: PRSModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModel
     */
    omit?: PRSModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelInclude<ExtArgs> | null
  }


  /**
   * Model PRSModelToTrait
   */

  export type AggregatePRSModelToTrait = {
    _count: PRSModelToTraitCountAggregateOutputType | null
    _avg: PRSModelToTraitAvgAggregateOutputType | null
    _sum: PRSModelToTraitSumAggregateOutputType | null
    _min: PRSModelToTraitMinAggregateOutputType | null
    _max: PRSModelToTraitMaxAggregateOutputType | null
  }

  export type PRSModelToTraitAvgAggregateOutputType = {
    prsModelId: number | null
    traitId: number | null
  }

  export type PRSModelToTraitSumAggregateOutputType = {
    prsModelId: number | null
    traitId: number | null
  }

  export type PRSModelToTraitMinAggregateOutputType = {
    prsModelId: number | null
    traitId: number | null
  }

  export type PRSModelToTraitMaxAggregateOutputType = {
    prsModelId: number | null
    traitId: number | null
  }

  export type PRSModelToTraitCountAggregateOutputType = {
    prsModelId: number
    traitId: number
    _all: number
  }


  export type PRSModelToTraitAvgAggregateInputType = {
    prsModelId?: true
    traitId?: true
  }

  export type PRSModelToTraitSumAggregateInputType = {
    prsModelId?: true
    traitId?: true
  }

  export type PRSModelToTraitMinAggregateInputType = {
    prsModelId?: true
    traitId?: true
  }

  export type PRSModelToTraitMaxAggregateInputType = {
    prsModelId?: true
    traitId?: true
  }

  export type PRSModelToTraitCountAggregateInputType = {
    prsModelId?: true
    traitId?: true
    _all?: true
  }

  export type PRSModelToTraitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PRSModelToTrait to aggregate.
     */
    where?: PRSModelToTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRSModelToTraits to fetch.
     */
    orderBy?: PRSModelToTraitOrderByWithRelationInput | PRSModelToTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PRSModelToTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRSModelToTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRSModelToTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PRSModelToTraits
    **/
    _count?: true | PRSModelToTraitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PRSModelToTraitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PRSModelToTraitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PRSModelToTraitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PRSModelToTraitMaxAggregateInputType
  }

  export type GetPRSModelToTraitAggregateType<T extends PRSModelToTraitAggregateArgs> = {
        [P in keyof T & keyof AggregatePRSModelToTrait]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePRSModelToTrait[P]>
      : GetScalarType<T[P], AggregatePRSModelToTrait[P]>
  }




  export type PRSModelToTraitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PRSModelToTraitWhereInput
    orderBy?: PRSModelToTraitOrderByWithAggregationInput | PRSModelToTraitOrderByWithAggregationInput[]
    by: PRSModelToTraitScalarFieldEnum[] | PRSModelToTraitScalarFieldEnum
    having?: PRSModelToTraitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PRSModelToTraitCountAggregateInputType | true
    _avg?: PRSModelToTraitAvgAggregateInputType
    _sum?: PRSModelToTraitSumAggregateInputType
    _min?: PRSModelToTraitMinAggregateInputType
    _max?: PRSModelToTraitMaxAggregateInputType
  }

  export type PRSModelToTraitGroupByOutputType = {
    prsModelId: number
    traitId: number
    _count: PRSModelToTraitCountAggregateOutputType | null
    _avg: PRSModelToTraitAvgAggregateOutputType | null
    _sum: PRSModelToTraitSumAggregateOutputType | null
    _min: PRSModelToTraitMinAggregateOutputType | null
    _max: PRSModelToTraitMaxAggregateOutputType | null
  }

  type GetPRSModelToTraitGroupByPayload<T extends PRSModelToTraitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PRSModelToTraitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PRSModelToTraitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PRSModelToTraitGroupByOutputType[P]>
            : GetScalarType<T[P], PRSModelToTraitGroupByOutputType[P]>
        }
      >
    >


  export type PRSModelToTraitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    prsModelId?: boolean
    traitId?: boolean
    prsModel?: boolean | PRSModelDefaultArgs<ExtArgs>
    trait?: boolean | TraitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pRSModelToTrait"]>



  export type PRSModelToTraitSelectScalar = {
    prsModelId?: boolean
    traitId?: boolean
  }

  export type PRSModelToTraitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"prsModelId" | "traitId", ExtArgs["result"]["pRSModelToTrait"]>
  export type PRSModelToTraitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prsModel?: boolean | PRSModelDefaultArgs<ExtArgs>
    trait?: boolean | TraitDefaultArgs<ExtArgs>
  }

  export type $PRSModelToTraitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PRSModelToTrait"
    objects: {
      prsModel: Prisma.$PRSModelPayload<ExtArgs>
      trait: Prisma.$TraitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      prsModelId: number
      traitId: number
    }, ExtArgs["result"]["pRSModelToTrait"]>
    composites: {}
  }

  type PRSModelToTraitGetPayload<S extends boolean | null | undefined | PRSModelToTraitDefaultArgs> = $Result.GetResult<Prisma.$PRSModelToTraitPayload, S>

  type PRSModelToTraitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PRSModelToTraitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PRSModelToTraitCountAggregateInputType | true
    }

  export interface PRSModelToTraitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PRSModelToTrait'], meta: { name: 'PRSModelToTrait' } }
    /**
     * Find zero or one PRSModelToTrait that matches the filter.
     * @param {PRSModelToTraitFindUniqueArgs} args - Arguments to find a PRSModelToTrait
     * @example
     * // Get one PRSModelToTrait
     * const pRSModelToTrait = await prisma.pRSModelToTrait.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PRSModelToTraitFindUniqueArgs>(args: SelectSubset<T, PRSModelToTraitFindUniqueArgs<ExtArgs>>): Prisma__PRSModelToTraitClient<$Result.GetResult<Prisma.$PRSModelToTraitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PRSModelToTrait that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PRSModelToTraitFindUniqueOrThrowArgs} args - Arguments to find a PRSModelToTrait
     * @example
     * // Get one PRSModelToTrait
     * const pRSModelToTrait = await prisma.pRSModelToTrait.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PRSModelToTraitFindUniqueOrThrowArgs>(args: SelectSubset<T, PRSModelToTraitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PRSModelToTraitClient<$Result.GetResult<Prisma.$PRSModelToTraitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PRSModelToTrait that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSModelToTraitFindFirstArgs} args - Arguments to find a PRSModelToTrait
     * @example
     * // Get one PRSModelToTrait
     * const pRSModelToTrait = await prisma.pRSModelToTrait.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PRSModelToTraitFindFirstArgs>(args?: SelectSubset<T, PRSModelToTraitFindFirstArgs<ExtArgs>>): Prisma__PRSModelToTraitClient<$Result.GetResult<Prisma.$PRSModelToTraitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PRSModelToTrait that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSModelToTraitFindFirstOrThrowArgs} args - Arguments to find a PRSModelToTrait
     * @example
     * // Get one PRSModelToTrait
     * const pRSModelToTrait = await prisma.pRSModelToTrait.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PRSModelToTraitFindFirstOrThrowArgs>(args?: SelectSubset<T, PRSModelToTraitFindFirstOrThrowArgs<ExtArgs>>): Prisma__PRSModelToTraitClient<$Result.GetResult<Prisma.$PRSModelToTraitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PRSModelToTraits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSModelToTraitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PRSModelToTraits
     * const pRSModelToTraits = await prisma.pRSModelToTrait.findMany()
     * 
     * // Get first 10 PRSModelToTraits
     * const pRSModelToTraits = await prisma.pRSModelToTrait.findMany({ take: 10 })
     * 
     * // Only select the `prsModelId`
     * const pRSModelToTraitWithPrsModelIdOnly = await prisma.pRSModelToTrait.findMany({ select: { prsModelId: true } })
     * 
     */
    findMany<T extends PRSModelToTraitFindManyArgs>(args?: SelectSubset<T, PRSModelToTraitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PRSModelToTraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PRSModelToTrait.
     * @param {PRSModelToTraitCreateArgs} args - Arguments to create a PRSModelToTrait.
     * @example
     * // Create one PRSModelToTrait
     * const PRSModelToTrait = await prisma.pRSModelToTrait.create({
     *   data: {
     *     // ... data to create a PRSModelToTrait
     *   }
     * })
     * 
     */
    create<T extends PRSModelToTraitCreateArgs>(args: SelectSubset<T, PRSModelToTraitCreateArgs<ExtArgs>>): Prisma__PRSModelToTraitClient<$Result.GetResult<Prisma.$PRSModelToTraitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PRSModelToTraits.
     * @param {PRSModelToTraitCreateManyArgs} args - Arguments to create many PRSModelToTraits.
     * @example
     * // Create many PRSModelToTraits
     * const pRSModelToTrait = await prisma.pRSModelToTrait.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PRSModelToTraitCreateManyArgs>(args?: SelectSubset<T, PRSModelToTraitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PRSModelToTrait.
     * @param {PRSModelToTraitDeleteArgs} args - Arguments to delete one PRSModelToTrait.
     * @example
     * // Delete one PRSModelToTrait
     * const PRSModelToTrait = await prisma.pRSModelToTrait.delete({
     *   where: {
     *     // ... filter to delete one PRSModelToTrait
     *   }
     * })
     * 
     */
    delete<T extends PRSModelToTraitDeleteArgs>(args: SelectSubset<T, PRSModelToTraitDeleteArgs<ExtArgs>>): Prisma__PRSModelToTraitClient<$Result.GetResult<Prisma.$PRSModelToTraitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PRSModelToTrait.
     * @param {PRSModelToTraitUpdateArgs} args - Arguments to update one PRSModelToTrait.
     * @example
     * // Update one PRSModelToTrait
     * const pRSModelToTrait = await prisma.pRSModelToTrait.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PRSModelToTraitUpdateArgs>(args: SelectSubset<T, PRSModelToTraitUpdateArgs<ExtArgs>>): Prisma__PRSModelToTraitClient<$Result.GetResult<Prisma.$PRSModelToTraitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PRSModelToTraits.
     * @param {PRSModelToTraitDeleteManyArgs} args - Arguments to filter PRSModelToTraits to delete.
     * @example
     * // Delete a few PRSModelToTraits
     * const { count } = await prisma.pRSModelToTrait.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PRSModelToTraitDeleteManyArgs>(args?: SelectSubset<T, PRSModelToTraitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PRSModelToTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSModelToTraitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PRSModelToTraits
     * const pRSModelToTrait = await prisma.pRSModelToTrait.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PRSModelToTraitUpdateManyArgs>(args: SelectSubset<T, PRSModelToTraitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PRSModelToTrait.
     * @param {PRSModelToTraitUpsertArgs} args - Arguments to update or create a PRSModelToTrait.
     * @example
     * // Update or create a PRSModelToTrait
     * const pRSModelToTrait = await prisma.pRSModelToTrait.upsert({
     *   create: {
     *     // ... data to create a PRSModelToTrait
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PRSModelToTrait we want to update
     *   }
     * })
     */
    upsert<T extends PRSModelToTraitUpsertArgs>(args: SelectSubset<T, PRSModelToTraitUpsertArgs<ExtArgs>>): Prisma__PRSModelToTraitClient<$Result.GetResult<Prisma.$PRSModelToTraitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PRSModelToTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSModelToTraitCountArgs} args - Arguments to filter PRSModelToTraits to count.
     * @example
     * // Count the number of PRSModelToTraits
     * const count = await prisma.pRSModelToTrait.count({
     *   where: {
     *     // ... the filter for the PRSModelToTraits we want to count
     *   }
     * })
    **/
    count<T extends PRSModelToTraitCountArgs>(
      args?: Subset<T, PRSModelToTraitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PRSModelToTraitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PRSModelToTrait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSModelToTraitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PRSModelToTraitAggregateArgs>(args: Subset<T, PRSModelToTraitAggregateArgs>): Prisma.PrismaPromise<GetPRSModelToTraitAggregateType<T>>

    /**
     * Group by PRSModelToTrait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSModelToTraitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PRSModelToTraitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PRSModelToTraitGroupByArgs['orderBy'] }
        : { orderBy?: PRSModelToTraitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PRSModelToTraitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPRSModelToTraitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PRSModelToTrait model
   */
  readonly fields: PRSModelToTraitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PRSModelToTrait.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PRSModelToTraitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prsModel<T extends PRSModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PRSModelDefaultArgs<ExtArgs>>): Prisma__PRSModelClient<$Result.GetResult<Prisma.$PRSModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    trait<T extends TraitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TraitDefaultArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PRSModelToTrait model
   */
  interface PRSModelToTraitFieldRefs {
    readonly prsModelId: FieldRef<"PRSModelToTrait", 'Int'>
    readonly traitId: FieldRef<"PRSModelToTrait", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PRSModelToTrait findUnique
   */
  export type PRSModelToTraitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModelToTrait
     */
    select?: PRSModelToTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModelToTrait
     */
    omit?: PRSModelToTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelToTraitInclude<ExtArgs> | null
    /**
     * Filter, which PRSModelToTrait to fetch.
     */
    where: PRSModelToTraitWhereUniqueInput
  }

  /**
   * PRSModelToTrait findUniqueOrThrow
   */
  export type PRSModelToTraitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModelToTrait
     */
    select?: PRSModelToTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModelToTrait
     */
    omit?: PRSModelToTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelToTraitInclude<ExtArgs> | null
    /**
     * Filter, which PRSModelToTrait to fetch.
     */
    where: PRSModelToTraitWhereUniqueInput
  }

  /**
   * PRSModelToTrait findFirst
   */
  export type PRSModelToTraitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModelToTrait
     */
    select?: PRSModelToTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModelToTrait
     */
    omit?: PRSModelToTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelToTraitInclude<ExtArgs> | null
    /**
     * Filter, which PRSModelToTrait to fetch.
     */
    where?: PRSModelToTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRSModelToTraits to fetch.
     */
    orderBy?: PRSModelToTraitOrderByWithRelationInput | PRSModelToTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PRSModelToTraits.
     */
    cursor?: PRSModelToTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRSModelToTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRSModelToTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PRSModelToTraits.
     */
    distinct?: PRSModelToTraitScalarFieldEnum | PRSModelToTraitScalarFieldEnum[]
  }

  /**
   * PRSModelToTrait findFirstOrThrow
   */
  export type PRSModelToTraitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModelToTrait
     */
    select?: PRSModelToTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModelToTrait
     */
    omit?: PRSModelToTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelToTraitInclude<ExtArgs> | null
    /**
     * Filter, which PRSModelToTrait to fetch.
     */
    where?: PRSModelToTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRSModelToTraits to fetch.
     */
    orderBy?: PRSModelToTraitOrderByWithRelationInput | PRSModelToTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PRSModelToTraits.
     */
    cursor?: PRSModelToTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRSModelToTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRSModelToTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PRSModelToTraits.
     */
    distinct?: PRSModelToTraitScalarFieldEnum | PRSModelToTraitScalarFieldEnum[]
  }

  /**
   * PRSModelToTrait findMany
   */
  export type PRSModelToTraitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModelToTrait
     */
    select?: PRSModelToTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModelToTrait
     */
    omit?: PRSModelToTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelToTraitInclude<ExtArgs> | null
    /**
     * Filter, which PRSModelToTraits to fetch.
     */
    where?: PRSModelToTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRSModelToTraits to fetch.
     */
    orderBy?: PRSModelToTraitOrderByWithRelationInput | PRSModelToTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PRSModelToTraits.
     */
    cursor?: PRSModelToTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRSModelToTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRSModelToTraits.
     */
    skip?: number
    distinct?: PRSModelToTraitScalarFieldEnum | PRSModelToTraitScalarFieldEnum[]
  }

  /**
   * PRSModelToTrait create
   */
  export type PRSModelToTraitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModelToTrait
     */
    select?: PRSModelToTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModelToTrait
     */
    omit?: PRSModelToTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelToTraitInclude<ExtArgs> | null
    /**
     * The data needed to create a PRSModelToTrait.
     */
    data: XOR<PRSModelToTraitCreateInput, PRSModelToTraitUncheckedCreateInput>
  }

  /**
   * PRSModelToTrait createMany
   */
  export type PRSModelToTraitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PRSModelToTraits.
     */
    data: PRSModelToTraitCreateManyInput | PRSModelToTraitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PRSModelToTrait update
   */
  export type PRSModelToTraitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModelToTrait
     */
    select?: PRSModelToTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModelToTrait
     */
    omit?: PRSModelToTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelToTraitInclude<ExtArgs> | null
    /**
     * The data needed to update a PRSModelToTrait.
     */
    data: XOR<PRSModelToTraitUpdateInput, PRSModelToTraitUncheckedUpdateInput>
    /**
     * Choose, which PRSModelToTrait to update.
     */
    where: PRSModelToTraitWhereUniqueInput
  }

  /**
   * PRSModelToTrait updateMany
   */
  export type PRSModelToTraitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PRSModelToTraits.
     */
    data: XOR<PRSModelToTraitUpdateManyMutationInput, PRSModelToTraitUncheckedUpdateManyInput>
    /**
     * Filter which PRSModelToTraits to update
     */
    where?: PRSModelToTraitWhereInput
    /**
     * Limit how many PRSModelToTraits to update.
     */
    limit?: number
  }

  /**
   * PRSModelToTrait upsert
   */
  export type PRSModelToTraitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModelToTrait
     */
    select?: PRSModelToTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModelToTrait
     */
    omit?: PRSModelToTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelToTraitInclude<ExtArgs> | null
    /**
     * The filter to search for the PRSModelToTrait to update in case it exists.
     */
    where: PRSModelToTraitWhereUniqueInput
    /**
     * In case the PRSModelToTrait found by the `where` argument doesn't exist, create a new PRSModelToTrait with this data.
     */
    create: XOR<PRSModelToTraitCreateInput, PRSModelToTraitUncheckedCreateInput>
    /**
     * In case the PRSModelToTrait was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PRSModelToTraitUpdateInput, PRSModelToTraitUncheckedUpdateInput>
  }

  /**
   * PRSModelToTrait delete
   */
  export type PRSModelToTraitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModelToTrait
     */
    select?: PRSModelToTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModelToTrait
     */
    omit?: PRSModelToTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelToTraitInclude<ExtArgs> | null
    /**
     * Filter which PRSModelToTrait to delete.
     */
    where: PRSModelToTraitWhereUniqueInput
  }

  /**
   * PRSModelToTrait deleteMany
   */
  export type PRSModelToTraitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PRSModelToTraits to delete
     */
    where?: PRSModelToTraitWhereInput
    /**
     * Limit how many PRSModelToTraits to delete.
     */
    limit?: number
  }

  /**
   * PRSModelToTrait without action
   */
  export type PRSModelToTraitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModelToTrait
     */
    select?: PRSModelToTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModelToTrait
     */
    omit?: PRSModelToTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelToTraitInclude<ExtArgs> | null
  }


  /**
   * Model ScoringFile
   */

  export type AggregateScoringFile = {
    _count: ScoringFileCountAggregateOutputType | null
    _avg: ScoringFileAvgAggregateOutputType | null
    _sum: ScoringFileSumAggregateOutputType | null
    _min: ScoringFileMinAggregateOutputType | null
    _max: ScoringFileMaxAggregateOutputType | null
  }

  export type ScoringFileAvgAggregateOutputType = {
    id: number | null
    prsModelId: number | null
  }

  export type ScoringFileSumAggregateOutputType = {
    id: number | null
    prsModelId: number | null
  }

  export type ScoringFileMinAggregateOutputType = {
    id: number | null
    assembly: $Enums.AssemblyType | null
    path: string | null
    prsModelId: number | null
  }

  export type ScoringFileMaxAggregateOutputType = {
    id: number | null
    assembly: $Enums.AssemblyType | null
    path: string | null
    prsModelId: number | null
  }

  export type ScoringFileCountAggregateOutputType = {
    id: number
    assembly: number
    path: number
    prsModelId: number
    _all: number
  }


  export type ScoringFileAvgAggregateInputType = {
    id?: true
    prsModelId?: true
  }

  export type ScoringFileSumAggregateInputType = {
    id?: true
    prsModelId?: true
  }

  export type ScoringFileMinAggregateInputType = {
    id?: true
    assembly?: true
    path?: true
    prsModelId?: true
  }

  export type ScoringFileMaxAggregateInputType = {
    id?: true
    assembly?: true
    path?: true
    prsModelId?: true
  }

  export type ScoringFileCountAggregateInputType = {
    id?: true
    assembly?: true
    path?: true
    prsModelId?: true
    _all?: true
  }

  export type ScoringFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScoringFile to aggregate.
     */
    where?: ScoringFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoringFiles to fetch.
     */
    orderBy?: ScoringFileOrderByWithRelationInput | ScoringFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScoringFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoringFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoringFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScoringFiles
    **/
    _count?: true | ScoringFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScoringFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScoringFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScoringFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScoringFileMaxAggregateInputType
  }

  export type GetScoringFileAggregateType<T extends ScoringFileAggregateArgs> = {
        [P in keyof T & keyof AggregateScoringFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScoringFile[P]>
      : GetScalarType<T[P], AggregateScoringFile[P]>
  }




  export type ScoringFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScoringFileWhereInput
    orderBy?: ScoringFileOrderByWithAggregationInput | ScoringFileOrderByWithAggregationInput[]
    by: ScoringFileScalarFieldEnum[] | ScoringFileScalarFieldEnum
    having?: ScoringFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScoringFileCountAggregateInputType | true
    _avg?: ScoringFileAvgAggregateInputType
    _sum?: ScoringFileSumAggregateInputType
    _min?: ScoringFileMinAggregateInputType
    _max?: ScoringFileMaxAggregateInputType
  }

  export type ScoringFileGroupByOutputType = {
    id: number
    assembly: $Enums.AssemblyType
    path: string
    prsModelId: number
    _count: ScoringFileCountAggregateOutputType | null
    _avg: ScoringFileAvgAggregateOutputType | null
    _sum: ScoringFileSumAggregateOutputType | null
    _min: ScoringFileMinAggregateOutputType | null
    _max: ScoringFileMaxAggregateOutputType | null
  }

  type GetScoringFileGroupByPayload<T extends ScoringFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScoringFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScoringFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScoringFileGroupByOutputType[P]>
            : GetScalarType<T[P], ScoringFileGroupByOutputType[P]>
        }
      >
    >


  export type ScoringFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assembly?: boolean
    path?: boolean
    prsModelId?: boolean
    prsModel?: boolean | PRSModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scoringFile"]>



  export type ScoringFileSelectScalar = {
    id?: boolean
    assembly?: boolean
    path?: boolean
    prsModelId?: boolean
  }

  export type ScoringFileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assembly" | "path" | "prsModelId", ExtArgs["result"]["scoringFile"]>
  export type ScoringFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prsModel?: boolean | PRSModelDefaultArgs<ExtArgs>
  }

  export type $ScoringFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScoringFile"
    objects: {
      prsModel: Prisma.$PRSModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      assembly: $Enums.AssemblyType
      path: string
      prsModelId: number
    }, ExtArgs["result"]["scoringFile"]>
    composites: {}
  }

  type ScoringFileGetPayload<S extends boolean | null | undefined | ScoringFileDefaultArgs> = $Result.GetResult<Prisma.$ScoringFilePayload, S>

  type ScoringFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScoringFileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScoringFileCountAggregateInputType | true
    }

  export interface ScoringFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScoringFile'], meta: { name: 'ScoringFile' } }
    /**
     * Find zero or one ScoringFile that matches the filter.
     * @param {ScoringFileFindUniqueArgs} args - Arguments to find a ScoringFile
     * @example
     * // Get one ScoringFile
     * const scoringFile = await prisma.scoringFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScoringFileFindUniqueArgs>(args: SelectSubset<T, ScoringFileFindUniqueArgs<ExtArgs>>): Prisma__ScoringFileClient<$Result.GetResult<Prisma.$ScoringFilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScoringFile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScoringFileFindUniqueOrThrowArgs} args - Arguments to find a ScoringFile
     * @example
     * // Get one ScoringFile
     * const scoringFile = await prisma.scoringFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScoringFileFindUniqueOrThrowArgs>(args: SelectSubset<T, ScoringFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScoringFileClient<$Result.GetResult<Prisma.$ScoringFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScoringFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoringFileFindFirstArgs} args - Arguments to find a ScoringFile
     * @example
     * // Get one ScoringFile
     * const scoringFile = await prisma.scoringFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScoringFileFindFirstArgs>(args?: SelectSubset<T, ScoringFileFindFirstArgs<ExtArgs>>): Prisma__ScoringFileClient<$Result.GetResult<Prisma.$ScoringFilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScoringFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoringFileFindFirstOrThrowArgs} args - Arguments to find a ScoringFile
     * @example
     * // Get one ScoringFile
     * const scoringFile = await prisma.scoringFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScoringFileFindFirstOrThrowArgs>(args?: SelectSubset<T, ScoringFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScoringFileClient<$Result.GetResult<Prisma.$ScoringFilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScoringFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoringFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScoringFiles
     * const scoringFiles = await prisma.scoringFile.findMany()
     * 
     * // Get first 10 ScoringFiles
     * const scoringFiles = await prisma.scoringFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scoringFileWithIdOnly = await prisma.scoringFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScoringFileFindManyArgs>(args?: SelectSubset<T, ScoringFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScoringFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScoringFile.
     * @param {ScoringFileCreateArgs} args - Arguments to create a ScoringFile.
     * @example
     * // Create one ScoringFile
     * const ScoringFile = await prisma.scoringFile.create({
     *   data: {
     *     // ... data to create a ScoringFile
     *   }
     * })
     * 
     */
    create<T extends ScoringFileCreateArgs>(args: SelectSubset<T, ScoringFileCreateArgs<ExtArgs>>): Prisma__ScoringFileClient<$Result.GetResult<Prisma.$ScoringFilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScoringFiles.
     * @param {ScoringFileCreateManyArgs} args - Arguments to create many ScoringFiles.
     * @example
     * // Create many ScoringFiles
     * const scoringFile = await prisma.scoringFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScoringFileCreateManyArgs>(args?: SelectSubset<T, ScoringFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ScoringFile.
     * @param {ScoringFileDeleteArgs} args - Arguments to delete one ScoringFile.
     * @example
     * // Delete one ScoringFile
     * const ScoringFile = await prisma.scoringFile.delete({
     *   where: {
     *     // ... filter to delete one ScoringFile
     *   }
     * })
     * 
     */
    delete<T extends ScoringFileDeleteArgs>(args: SelectSubset<T, ScoringFileDeleteArgs<ExtArgs>>): Prisma__ScoringFileClient<$Result.GetResult<Prisma.$ScoringFilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScoringFile.
     * @param {ScoringFileUpdateArgs} args - Arguments to update one ScoringFile.
     * @example
     * // Update one ScoringFile
     * const scoringFile = await prisma.scoringFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScoringFileUpdateArgs>(args: SelectSubset<T, ScoringFileUpdateArgs<ExtArgs>>): Prisma__ScoringFileClient<$Result.GetResult<Prisma.$ScoringFilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScoringFiles.
     * @param {ScoringFileDeleteManyArgs} args - Arguments to filter ScoringFiles to delete.
     * @example
     * // Delete a few ScoringFiles
     * const { count } = await prisma.scoringFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScoringFileDeleteManyArgs>(args?: SelectSubset<T, ScoringFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScoringFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoringFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScoringFiles
     * const scoringFile = await prisma.scoringFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScoringFileUpdateManyArgs>(args: SelectSubset<T, ScoringFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScoringFile.
     * @param {ScoringFileUpsertArgs} args - Arguments to update or create a ScoringFile.
     * @example
     * // Update or create a ScoringFile
     * const scoringFile = await prisma.scoringFile.upsert({
     *   create: {
     *     // ... data to create a ScoringFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScoringFile we want to update
     *   }
     * })
     */
    upsert<T extends ScoringFileUpsertArgs>(args: SelectSubset<T, ScoringFileUpsertArgs<ExtArgs>>): Prisma__ScoringFileClient<$Result.GetResult<Prisma.$ScoringFilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScoringFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoringFileCountArgs} args - Arguments to filter ScoringFiles to count.
     * @example
     * // Count the number of ScoringFiles
     * const count = await prisma.scoringFile.count({
     *   where: {
     *     // ... the filter for the ScoringFiles we want to count
     *   }
     * })
    **/
    count<T extends ScoringFileCountArgs>(
      args?: Subset<T, ScoringFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScoringFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScoringFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoringFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScoringFileAggregateArgs>(args: Subset<T, ScoringFileAggregateArgs>): Prisma.PrismaPromise<GetScoringFileAggregateType<T>>

    /**
     * Group by ScoringFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoringFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScoringFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScoringFileGroupByArgs['orderBy'] }
        : { orderBy?: ScoringFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScoringFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScoringFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScoringFile model
   */
  readonly fields: ScoringFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScoringFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScoringFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prsModel<T extends PRSModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PRSModelDefaultArgs<ExtArgs>>): Prisma__PRSModelClient<$Result.GetResult<Prisma.$PRSModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScoringFile model
   */
  interface ScoringFileFieldRefs {
    readonly id: FieldRef<"ScoringFile", 'Int'>
    readonly assembly: FieldRef<"ScoringFile", 'AssemblyType'>
    readonly path: FieldRef<"ScoringFile", 'String'>
    readonly prsModelId: FieldRef<"ScoringFile", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ScoringFile findUnique
   */
  export type ScoringFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringFile
     */
    select?: ScoringFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringFile
     */
    omit?: ScoringFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringFileInclude<ExtArgs> | null
    /**
     * Filter, which ScoringFile to fetch.
     */
    where: ScoringFileWhereUniqueInput
  }

  /**
   * ScoringFile findUniqueOrThrow
   */
  export type ScoringFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringFile
     */
    select?: ScoringFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringFile
     */
    omit?: ScoringFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringFileInclude<ExtArgs> | null
    /**
     * Filter, which ScoringFile to fetch.
     */
    where: ScoringFileWhereUniqueInput
  }

  /**
   * ScoringFile findFirst
   */
  export type ScoringFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringFile
     */
    select?: ScoringFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringFile
     */
    omit?: ScoringFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringFileInclude<ExtArgs> | null
    /**
     * Filter, which ScoringFile to fetch.
     */
    where?: ScoringFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoringFiles to fetch.
     */
    orderBy?: ScoringFileOrderByWithRelationInput | ScoringFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScoringFiles.
     */
    cursor?: ScoringFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoringFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoringFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScoringFiles.
     */
    distinct?: ScoringFileScalarFieldEnum | ScoringFileScalarFieldEnum[]
  }

  /**
   * ScoringFile findFirstOrThrow
   */
  export type ScoringFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringFile
     */
    select?: ScoringFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringFile
     */
    omit?: ScoringFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringFileInclude<ExtArgs> | null
    /**
     * Filter, which ScoringFile to fetch.
     */
    where?: ScoringFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoringFiles to fetch.
     */
    orderBy?: ScoringFileOrderByWithRelationInput | ScoringFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScoringFiles.
     */
    cursor?: ScoringFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoringFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoringFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScoringFiles.
     */
    distinct?: ScoringFileScalarFieldEnum | ScoringFileScalarFieldEnum[]
  }

  /**
   * ScoringFile findMany
   */
  export type ScoringFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringFile
     */
    select?: ScoringFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringFile
     */
    omit?: ScoringFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringFileInclude<ExtArgs> | null
    /**
     * Filter, which ScoringFiles to fetch.
     */
    where?: ScoringFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoringFiles to fetch.
     */
    orderBy?: ScoringFileOrderByWithRelationInput | ScoringFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScoringFiles.
     */
    cursor?: ScoringFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoringFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoringFiles.
     */
    skip?: number
    distinct?: ScoringFileScalarFieldEnum | ScoringFileScalarFieldEnum[]
  }

  /**
   * ScoringFile create
   */
  export type ScoringFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringFile
     */
    select?: ScoringFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringFile
     */
    omit?: ScoringFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringFileInclude<ExtArgs> | null
    /**
     * The data needed to create a ScoringFile.
     */
    data: XOR<ScoringFileCreateInput, ScoringFileUncheckedCreateInput>
  }

  /**
   * ScoringFile createMany
   */
  export type ScoringFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScoringFiles.
     */
    data: ScoringFileCreateManyInput | ScoringFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScoringFile update
   */
  export type ScoringFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringFile
     */
    select?: ScoringFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringFile
     */
    omit?: ScoringFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringFileInclude<ExtArgs> | null
    /**
     * The data needed to update a ScoringFile.
     */
    data: XOR<ScoringFileUpdateInput, ScoringFileUncheckedUpdateInput>
    /**
     * Choose, which ScoringFile to update.
     */
    where: ScoringFileWhereUniqueInput
  }

  /**
   * ScoringFile updateMany
   */
  export type ScoringFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScoringFiles.
     */
    data: XOR<ScoringFileUpdateManyMutationInput, ScoringFileUncheckedUpdateManyInput>
    /**
     * Filter which ScoringFiles to update
     */
    where?: ScoringFileWhereInput
    /**
     * Limit how many ScoringFiles to update.
     */
    limit?: number
  }

  /**
   * ScoringFile upsert
   */
  export type ScoringFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringFile
     */
    select?: ScoringFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringFile
     */
    omit?: ScoringFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringFileInclude<ExtArgs> | null
    /**
     * The filter to search for the ScoringFile to update in case it exists.
     */
    where: ScoringFileWhereUniqueInput
    /**
     * In case the ScoringFile found by the `where` argument doesn't exist, create a new ScoringFile with this data.
     */
    create: XOR<ScoringFileCreateInput, ScoringFileUncheckedCreateInput>
    /**
     * In case the ScoringFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScoringFileUpdateInput, ScoringFileUncheckedUpdateInput>
  }

  /**
   * ScoringFile delete
   */
  export type ScoringFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringFile
     */
    select?: ScoringFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringFile
     */
    omit?: ScoringFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringFileInclude<ExtArgs> | null
    /**
     * Filter which ScoringFile to delete.
     */
    where: ScoringFileWhereUniqueInput
  }

  /**
   * ScoringFile deleteMany
   */
  export type ScoringFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScoringFiles to delete
     */
    where?: ScoringFileWhereInput
    /**
     * Limit how many ScoringFiles to delete.
     */
    limit?: number
  }

  /**
   * ScoringFile without action
   */
  export type ScoringFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringFile
     */
    select?: ScoringFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringFile
     */
    omit?: ScoringFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringFileInclude<ExtArgs> | null
  }


  /**
   * Model Publication
   */

  export type AggregatePublication = {
    _count: PublicationCountAggregateOutputType | null
    _avg: PublicationAvgAggregateOutputType | null
    _sum: PublicationSumAggregateOutputType | null
    _min: PublicationMinAggregateOutputType | null
    _max: PublicationMaxAggregateOutputType | null
  }

  export type PublicationAvgAggregateOutputType = {
    id: number | null
    year: number | null
  }

  export type PublicationSumAggregateOutputType = {
    id: number | null
    year: number | null
  }

  export type PublicationMinAggregateOutputType = {
    id: number | null
    title: string | null
    journal: string | null
    author: string | null
    date: Date | null
    year: number | null
    PMID: string | null
    DOI: string | null
    pgpId: string | null
  }

  export type PublicationMaxAggregateOutputType = {
    id: number | null
    title: string | null
    journal: string | null
    author: string | null
    date: Date | null
    year: number | null
    PMID: string | null
    DOI: string | null
    pgpId: string | null
  }

  export type PublicationCountAggregateOutputType = {
    id: number
    title: number
    journal: number
    author: number
    date: number
    year: number
    PMID: number
    DOI: number
    pgpId: number
    _all: number
  }


  export type PublicationAvgAggregateInputType = {
    id?: true
    year?: true
  }

  export type PublicationSumAggregateInputType = {
    id?: true
    year?: true
  }

  export type PublicationMinAggregateInputType = {
    id?: true
    title?: true
    journal?: true
    author?: true
    date?: true
    year?: true
    PMID?: true
    DOI?: true
    pgpId?: true
  }

  export type PublicationMaxAggregateInputType = {
    id?: true
    title?: true
    journal?: true
    author?: true
    date?: true
    year?: true
    PMID?: true
    DOI?: true
    pgpId?: true
  }

  export type PublicationCountAggregateInputType = {
    id?: true
    title?: true
    journal?: true
    author?: true
    date?: true
    year?: true
    PMID?: true
    DOI?: true
    pgpId?: true
    _all?: true
  }

  export type PublicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Publication to aggregate.
     */
    where?: PublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Publications
    **/
    _count?: true | PublicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PublicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PublicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublicationMaxAggregateInputType
  }

  export type GetPublicationAggregateType<T extends PublicationAggregateArgs> = {
        [P in keyof T & keyof AggregatePublication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublication[P]>
      : GetScalarType<T[P], AggregatePublication[P]>
  }




  export type PublicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicationWhereInput
    orderBy?: PublicationOrderByWithAggregationInput | PublicationOrderByWithAggregationInput[]
    by: PublicationScalarFieldEnum[] | PublicationScalarFieldEnum
    having?: PublicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublicationCountAggregateInputType | true
    _avg?: PublicationAvgAggregateInputType
    _sum?: PublicationSumAggregateInputType
    _min?: PublicationMinAggregateInputType
    _max?: PublicationMaxAggregateInputType
  }

  export type PublicationGroupByOutputType = {
    id: number
    title: string
    journal: string
    author: string
    date: Date | null
    year: number
    PMID: string | null
    DOI: string | null
    pgpId: string | null
    _count: PublicationCountAggregateOutputType | null
    _avg: PublicationAvgAggregateOutputType | null
    _sum: PublicationSumAggregateOutputType | null
    _min: PublicationMinAggregateOutputType | null
    _max: PublicationMaxAggregateOutputType | null
  }

  type GetPublicationGroupByPayload<T extends PublicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PublicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicationGroupByOutputType[P]>
            : GetScalarType<T[P], PublicationGroupByOutputType[P]>
        }
      >
    >


  export type PublicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    journal?: boolean
    author?: boolean
    date?: boolean
    year?: boolean
    PMID?: boolean
    DOI?: boolean
    pgpId?: boolean
    modelEvaluations?: boolean | Publication$modelEvaluationsArgs<ExtArgs>
    prsModels?: boolean | Publication$prsModelsArgs<ExtArgs>
    _count?: boolean | PublicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publication"]>



  export type PublicationSelectScalar = {
    id?: boolean
    title?: boolean
    journal?: boolean
    author?: boolean
    date?: boolean
    year?: boolean
    PMID?: boolean
    DOI?: boolean
    pgpId?: boolean
  }

  export type PublicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "journal" | "author" | "date" | "year" | "PMID" | "DOI" | "pgpId", ExtArgs["result"]["publication"]>
  export type PublicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modelEvaluations?: boolean | Publication$modelEvaluationsArgs<ExtArgs>
    prsModels?: boolean | Publication$prsModelsArgs<ExtArgs>
    _count?: boolean | PublicationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PublicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Publication"
    objects: {
      modelEvaluations: Prisma.$ModelEvaluationPayload<ExtArgs>[]
      prsModels: Prisma.$PRSModelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      journal: string
      author: string
      date: Date | null
      year: number
      PMID: string | null
      DOI: string | null
      pgpId: string | null
    }, ExtArgs["result"]["publication"]>
    composites: {}
  }

  type PublicationGetPayload<S extends boolean | null | undefined | PublicationDefaultArgs> = $Result.GetResult<Prisma.$PublicationPayload, S>

  type PublicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PublicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PublicationCountAggregateInputType | true
    }

  export interface PublicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Publication'], meta: { name: 'Publication' } }
    /**
     * Find zero or one Publication that matches the filter.
     * @param {PublicationFindUniqueArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PublicationFindUniqueArgs>(args: SelectSubset<T, PublicationFindUniqueArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Publication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PublicationFindUniqueOrThrowArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PublicationFindUniqueOrThrowArgs>(args: SelectSubset<T, PublicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationFindFirstArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PublicationFindFirstArgs>(args?: SelectSubset<T, PublicationFindFirstArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationFindFirstOrThrowArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PublicationFindFirstOrThrowArgs>(args?: SelectSubset<T, PublicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Publications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publications
     * const publications = await prisma.publication.findMany()
     * 
     * // Get first 10 Publications
     * const publications = await prisma.publication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publicationWithIdOnly = await prisma.publication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PublicationFindManyArgs>(args?: SelectSubset<T, PublicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Publication.
     * @param {PublicationCreateArgs} args - Arguments to create a Publication.
     * @example
     * // Create one Publication
     * const Publication = await prisma.publication.create({
     *   data: {
     *     // ... data to create a Publication
     *   }
     * })
     * 
     */
    create<T extends PublicationCreateArgs>(args: SelectSubset<T, PublicationCreateArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Publications.
     * @param {PublicationCreateManyArgs} args - Arguments to create many Publications.
     * @example
     * // Create many Publications
     * const publication = await prisma.publication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PublicationCreateManyArgs>(args?: SelectSubset<T, PublicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Publication.
     * @param {PublicationDeleteArgs} args - Arguments to delete one Publication.
     * @example
     * // Delete one Publication
     * const Publication = await prisma.publication.delete({
     *   where: {
     *     // ... filter to delete one Publication
     *   }
     * })
     * 
     */
    delete<T extends PublicationDeleteArgs>(args: SelectSubset<T, PublicationDeleteArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Publication.
     * @param {PublicationUpdateArgs} args - Arguments to update one Publication.
     * @example
     * // Update one Publication
     * const publication = await prisma.publication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PublicationUpdateArgs>(args: SelectSubset<T, PublicationUpdateArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Publications.
     * @param {PublicationDeleteManyArgs} args - Arguments to filter Publications to delete.
     * @example
     * // Delete a few Publications
     * const { count } = await prisma.publication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PublicationDeleteManyArgs>(args?: SelectSubset<T, PublicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publications
     * const publication = await prisma.publication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PublicationUpdateManyArgs>(args: SelectSubset<T, PublicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Publication.
     * @param {PublicationUpsertArgs} args - Arguments to update or create a Publication.
     * @example
     * // Update or create a Publication
     * const publication = await prisma.publication.upsert({
     *   create: {
     *     // ... data to create a Publication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publication we want to update
     *   }
     * })
     */
    upsert<T extends PublicationUpsertArgs>(args: SelectSubset<T, PublicationUpsertArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationCountArgs} args - Arguments to filter Publications to count.
     * @example
     * // Count the number of Publications
     * const count = await prisma.publication.count({
     *   where: {
     *     // ... the filter for the Publications we want to count
     *   }
     * })
    **/
    count<T extends PublicationCountArgs>(
      args?: Subset<T, PublicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublicationAggregateArgs>(args: Subset<T, PublicationAggregateArgs>): Prisma.PrismaPromise<GetPublicationAggregateType<T>>

    /**
     * Group by Publication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PublicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublicationGroupByArgs['orderBy'] }
        : { orderBy?: PublicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Publication model
   */
  readonly fields: PublicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Publication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PublicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    modelEvaluations<T extends Publication$modelEvaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Publication$modelEvaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prsModels<T extends Publication$prsModelsArgs<ExtArgs> = {}>(args?: Subset<T, Publication$prsModelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PRSModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Publication model
   */
  interface PublicationFieldRefs {
    readonly id: FieldRef<"Publication", 'Int'>
    readonly title: FieldRef<"Publication", 'String'>
    readonly journal: FieldRef<"Publication", 'String'>
    readonly author: FieldRef<"Publication", 'String'>
    readonly date: FieldRef<"Publication", 'DateTime'>
    readonly year: FieldRef<"Publication", 'Int'>
    readonly PMID: FieldRef<"Publication", 'String'>
    readonly DOI: FieldRef<"Publication", 'String'>
    readonly pgpId: FieldRef<"Publication", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Publication findUnique
   */
  export type PublicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publication to fetch.
     */
    where: PublicationWhereUniqueInput
  }

  /**
   * Publication findUniqueOrThrow
   */
  export type PublicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publication to fetch.
     */
    where: PublicationWhereUniqueInput
  }

  /**
   * Publication findFirst
   */
  export type PublicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publication to fetch.
     */
    where?: PublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Publications.
     */
    cursor?: PublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Publications.
     */
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }

  /**
   * Publication findFirstOrThrow
   */
  export type PublicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publication to fetch.
     */
    where?: PublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Publications.
     */
    cursor?: PublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Publications.
     */
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }

  /**
   * Publication findMany
   */
  export type PublicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publications to fetch.
     */
    where?: PublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Publications.
     */
    cursor?: PublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }

  /**
   * Publication create
   */
  export type PublicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Publication.
     */
    data: XOR<PublicationCreateInput, PublicationUncheckedCreateInput>
  }

  /**
   * Publication createMany
   */
  export type PublicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Publications.
     */
    data: PublicationCreateManyInput | PublicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Publication update
   */
  export type PublicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Publication.
     */
    data: XOR<PublicationUpdateInput, PublicationUncheckedUpdateInput>
    /**
     * Choose, which Publication to update.
     */
    where: PublicationWhereUniqueInput
  }

  /**
   * Publication updateMany
   */
  export type PublicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Publications.
     */
    data: XOR<PublicationUpdateManyMutationInput, PublicationUncheckedUpdateManyInput>
    /**
     * Filter which Publications to update
     */
    where?: PublicationWhereInput
    /**
     * Limit how many Publications to update.
     */
    limit?: number
  }

  /**
   * Publication upsert
   */
  export type PublicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Publication to update in case it exists.
     */
    where: PublicationWhereUniqueInput
    /**
     * In case the Publication found by the `where` argument doesn't exist, create a new Publication with this data.
     */
    create: XOR<PublicationCreateInput, PublicationUncheckedCreateInput>
    /**
     * In case the Publication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PublicationUpdateInput, PublicationUncheckedUpdateInput>
  }

  /**
   * Publication delete
   */
  export type PublicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter which Publication to delete.
     */
    where: PublicationWhereUniqueInput
  }

  /**
   * Publication deleteMany
   */
  export type PublicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Publications to delete
     */
    where?: PublicationWhereInput
    /**
     * Limit how many Publications to delete.
     */
    limit?: number
  }

  /**
   * Publication.modelEvaluations
   */
  export type Publication$modelEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEvaluation
     */
    select?: ModelEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEvaluation
     */
    omit?: ModelEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEvaluationInclude<ExtArgs> | null
    where?: ModelEvaluationWhereInput
    orderBy?: ModelEvaluationOrderByWithRelationInput | ModelEvaluationOrderByWithRelationInput[]
    cursor?: ModelEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelEvaluationScalarFieldEnum | ModelEvaluationScalarFieldEnum[]
  }

  /**
   * Publication.prsModels
   */
  export type Publication$prsModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSModel
     */
    select?: PRSModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSModel
     */
    omit?: PRSModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSModelInclude<ExtArgs> | null
    where?: PRSModelWhereInput
    orderBy?: PRSModelOrderByWithRelationInput | PRSModelOrderByWithRelationInput[]
    cursor?: PRSModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PRSModelScalarFieldEnum | PRSModelScalarFieldEnum[]
  }

  /**
   * Publication without action
   */
  export type PublicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Publication
     */
    omit?: PublicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
  }


  /**
   * Model ModelEvaluation
   */

  export type AggregateModelEvaluation = {
    _count: ModelEvaluationCountAggregateOutputType | null
    _avg: ModelEvaluationAvgAggregateOutputType | null
    _sum: ModelEvaluationSumAggregateOutputType | null
    _min: ModelEvaluationMinAggregateOutputType | null
    _max: ModelEvaluationMaxAggregateOutputType | null
  }

  export type ModelEvaluationAvgAggregateOutputType = {
    id: number | null
    prsModelId: number | null
    publicationId: number | null
    evaluationPopulationSampleId: number | null
  }

  export type ModelEvaluationSumAggregateOutputType = {
    id: number | null
    prsModelId: number | null
    publicationId: number | null
    evaluationPopulationSampleId: number | null
  }

  export type ModelEvaluationMinAggregateOutputType = {
    id: number | null
    reportedTrait: string | null
    covariates: string | null
    ppmId: string | null
    prsModelId: number | null
    publicationId: number | null
    evaluationPopulationSampleId: number | null
  }

  export type ModelEvaluationMaxAggregateOutputType = {
    id: number | null
    reportedTrait: string | null
    covariates: string | null
    ppmId: string | null
    prsModelId: number | null
    publicationId: number | null
    evaluationPopulationSampleId: number | null
  }

  export type ModelEvaluationCountAggregateOutputType = {
    id: number
    reportedTrait: number
    covariates: number
    ppmId: number
    prsModelId: number
    publicationId: number
    evaluationPopulationSampleId: number
    _all: number
  }


  export type ModelEvaluationAvgAggregateInputType = {
    id?: true
    prsModelId?: true
    publicationId?: true
    evaluationPopulationSampleId?: true
  }

  export type ModelEvaluationSumAggregateInputType = {
    id?: true
    prsModelId?: true
    publicationId?: true
    evaluationPopulationSampleId?: true
  }

  export type ModelEvaluationMinAggregateInputType = {
    id?: true
    reportedTrait?: true
    covariates?: true
    ppmId?: true
    prsModelId?: true
    publicationId?: true
    evaluationPopulationSampleId?: true
  }

  export type ModelEvaluationMaxAggregateInputType = {
    id?: true
    reportedTrait?: true
    covariates?: true
    ppmId?: true
    prsModelId?: true
    publicationId?: true
    evaluationPopulationSampleId?: true
  }

  export type ModelEvaluationCountAggregateInputType = {
    id?: true
    reportedTrait?: true
    covariates?: true
    ppmId?: true
    prsModelId?: true
    publicationId?: true
    evaluationPopulationSampleId?: true
    _all?: true
  }

  export type ModelEvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelEvaluation to aggregate.
     */
    where?: ModelEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelEvaluations to fetch.
     */
    orderBy?: ModelEvaluationOrderByWithRelationInput | ModelEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModelEvaluations
    **/
    _count?: true | ModelEvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModelEvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModelEvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelEvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelEvaluationMaxAggregateInputType
  }

  export type GetModelEvaluationAggregateType<T extends ModelEvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateModelEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModelEvaluation[P]>
      : GetScalarType<T[P], AggregateModelEvaluation[P]>
  }




  export type ModelEvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelEvaluationWhereInput
    orderBy?: ModelEvaluationOrderByWithAggregationInput | ModelEvaluationOrderByWithAggregationInput[]
    by: ModelEvaluationScalarFieldEnum[] | ModelEvaluationScalarFieldEnum
    having?: ModelEvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelEvaluationCountAggregateInputType | true
    _avg?: ModelEvaluationAvgAggregateInputType
    _sum?: ModelEvaluationSumAggregateInputType
    _min?: ModelEvaluationMinAggregateInputType
    _max?: ModelEvaluationMaxAggregateInputType
  }

  export type ModelEvaluationGroupByOutputType = {
    id: number
    reportedTrait: string
    covariates: string | null
    ppmId: string | null
    prsModelId: number
    publicationId: number
    evaluationPopulationSampleId: number
    _count: ModelEvaluationCountAggregateOutputType | null
    _avg: ModelEvaluationAvgAggregateOutputType | null
    _sum: ModelEvaluationSumAggregateOutputType | null
    _min: ModelEvaluationMinAggregateOutputType | null
    _max: ModelEvaluationMaxAggregateOutputType | null
  }

  type GetModelEvaluationGroupByPayload<T extends ModelEvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelEvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelEvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelEvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], ModelEvaluationGroupByOutputType[P]>
        }
      >
    >


  export type ModelEvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportedTrait?: boolean
    covariates?: boolean
    ppmId?: boolean
    prsModelId?: boolean
    publicationId?: boolean
    evaluationPopulationSampleId?: boolean
    evaluationPopulationSample?: boolean | EvaluationPopulationSampleDefaultArgs<ExtArgs>
    prsModel?: boolean | PRSModelDefaultArgs<ExtArgs>
    publication?: boolean | PublicationDefaultArgs<ExtArgs>
    metricEvaluations?: boolean | ModelEvaluation$metricEvaluationsArgs<ExtArgs>
    _count?: boolean | ModelEvaluationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modelEvaluation"]>



  export type ModelEvaluationSelectScalar = {
    id?: boolean
    reportedTrait?: boolean
    covariates?: boolean
    ppmId?: boolean
    prsModelId?: boolean
    publicationId?: boolean
    evaluationPopulationSampleId?: boolean
  }

  export type ModelEvaluationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reportedTrait" | "covariates" | "ppmId" | "prsModelId" | "publicationId" | "evaluationPopulationSampleId", ExtArgs["result"]["modelEvaluation"]>
  export type ModelEvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluationPopulationSample?: boolean | EvaluationPopulationSampleDefaultArgs<ExtArgs>
    prsModel?: boolean | PRSModelDefaultArgs<ExtArgs>
    publication?: boolean | PublicationDefaultArgs<ExtArgs>
    metricEvaluations?: boolean | ModelEvaluation$metricEvaluationsArgs<ExtArgs>
    _count?: boolean | ModelEvaluationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ModelEvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModelEvaluation"
    objects: {
      evaluationPopulationSample: Prisma.$EvaluationPopulationSamplePayload<ExtArgs>
      prsModel: Prisma.$PRSModelPayload<ExtArgs>
      publication: Prisma.$PublicationPayload<ExtArgs>
      metricEvaluations: Prisma.$PerformanceMetricEvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reportedTrait: string
      covariates: string | null
      ppmId: string | null
      prsModelId: number
      publicationId: number
      evaluationPopulationSampleId: number
    }, ExtArgs["result"]["modelEvaluation"]>
    composites: {}
  }

  type ModelEvaluationGetPayload<S extends boolean | null | undefined | ModelEvaluationDefaultArgs> = $Result.GetResult<Prisma.$ModelEvaluationPayload, S>

  type ModelEvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModelEvaluationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModelEvaluationCountAggregateInputType | true
    }

  export interface ModelEvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModelEvaluation'], meta: { name: 'ModelEvaluation' } }
    /**
     * Find zero or one ModelEvaluation that matches the filter.
     * @param {ModelEvaluationFindUniqueArgs} args - Arguments to find a ModelEvaluation
     * @example
     * // Get one ModelEvaluation
     * const modelEvaluation = await prisma.modelEvaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelEvaluationFindUniqueArgs>(args: SelectSubset<T, ModelEvaluationFindUniqueArgs<ExtArgs>>): Prisma__ModelEvaluationClient<$Result.GetResult<Prisma.$ModelEvaluationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModelEvaluation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModelEvaluationFindUniqueOrThrowArgs} args - Arguments to find a ModelEvaluation
     * @example
     * // Get one ModelEvaluation
     * const modelEvaluation = await prisma.modelEvaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelEvaluationFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelEvaluationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelEvaluationClient<$Result.GetResult<Prisma.$ModelEvaluationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModelEvaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelEvaluationFindFirstArgs} args - Arguments to find a ModelEvaluation
     * @example
     * // Get one ModelEvaluation
     * const modelEvaluation = await prisma.modelEvaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelEvaluationFindFirstArgs>(args?: SelectSubset<T, ModelEvaluationFindFirstArgs<ExtArgs>>): Prisma__ModelEvaluationClient<$Result.GetResult<Prisma.$ModelEvaluationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModelEvaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelEvaluationFindFirstOrThrowArgs} args - Arguments to find a ModelEvaluation
     * @example
     * // Get one ModelEvaluation
     * const modelEvaluation = await prisma.modelEvaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelEvaluationFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelEvaluationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelEvaluationClient<$Result.GetResult<Prisma.$ModelEvaluationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModelEvaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelEvaluationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModelEvaluations
     * const modelEvaluations = await prisma.modelEvaluation.findMany()
     * 
     * // Get first 10 ModelEvaluations
     * const modelEvaluations = await prisma.modelEvaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelEvaluationWithIdOnly = await prisma.modelEvaluation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelEvaluationFindManyArgs>(args?: SelectSubset<T, ModelEvaluationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModelEvaluation.
     * @param {ModelEvaluationCreateArgs} args - Arguments to create a ModelEvaluation.
     * @example
     * // Create one ModelEvaluation
     * const ModelEvaluation = await prisma.modelEvaluation.create({
     *   data: {
     *     // ... data to create a ModelEvaluation
     *   }
     * })
     * 
     */
    create<T extends ModelEvaluationCreateArgs>(args: SelectSubset<T, ModelEvaluationCreateArgs<ExtArgs>>): Prisma__ModelEvaluationClient<$Result.GetResult<Prisma.$ModelEvaluationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModelEvaluations.
     * @param {ModelEvaluationCreateManyArgs} args - Arguments to create many ModelEvaluations.
     * @example
     * // Create many ModelEvaluations
     * const modelEvaluation = await prisma.modelEvaluation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelEvaluationCreateManyArgs>(args?: SelectSubset<T, ModelEvaluationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ModelEvaluation.
     * @param {ModelEvaluationDeleteArgs} args - Arguments to delete one ModelEvaluation.
     * @example
     * // Delete one ModelEvaluation
     * const ModelEvaluation = await prisma.modelEvaluation.delete({
     *   where: {
     *     // ... filter to delete one ModelEvaluation
     *   }
     * })
     * 
     */
    delete<T extends ModelEvaluationDeleteArgs>(args: SelectSubset<T, ModelEvaluationDeleteArgs<ExtArgs>>): Prisma__ModelEvaluationClient<$Result.GetResult<Prisma.$ModelEvaluationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModelEvaluation.
     * @param {ModelEvaluationUpdateArgs} args - Arguments to update one ModelEvaluation.
     * @example
     * // Update one ModelEvaluation
     * const modelEvaluation = await prisma.modelEvaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelEvaluationUpdateArgs>(args: SelectSubset<T, ModelEvaluationUpdateArgs<ExtArgs>>): Prisma__ModelEvaluationClient<$Result.GetResult<Prisma.$ModelEvaluationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModelEvaluations.
     * @param {ModelEvaluationDeleteManyArgs} args - Arguments to filter ModelEvaluations to delete.
     * @example
     * // Delete a few ModelEvaluations
     * const { count } = await prisma.modelEvaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelEvaluationDeleteManyArgs>(args?: SelectSubset<T, ModelEvaluationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelEvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModelEvaluations
     * const modelEvaluation = await prisma.modelEvaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelEvaluationUpdateManyArgs>(args: SelectSubset<T, ModelEvaluationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModelEvaluation.
     * @param {ModelEvaluationUpsertArgs} args - Arguments to update or create a ModelEvaluation.
     * @example
     * // Update or create a ModelEvaluation
     * const modelEvaluation = await prisma.modelEvaluation.upsert({
     *   create: {
     *     // ... data to create a ModelEvaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModelEvaluation we want to update
     *   }
     * })
     */
    upsert<T extends ModelEvaluationUpsertArgs>(args: SelectSubset<T, ModelEvaluationUpsertArgs<ExtArgs>>): Prisma__ModelEvaluationClient<$Result.GetResult<Prisma.$ModelEvaluationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModelEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelEvaluationCountArgs} args - Arguments to filter ModelEvaluations to count.
     * @example
     * // Count the number of ModelEvaluations
     * const count = await prisma.modelEvaluation.count({
     *   where: {
     *     // ... the filter for the ModelEvaluations we want to count
     *   }
     * })
    **/
    count<T extends ModelEvaluationCountArgs>(
      args?: Subset<T, ModelEvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelEvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModelEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelEvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelEvaluationAggregateArgs>(args: Subset<T, ModelEvaluationAggregateArgs>): Prisma.PrismaPromise<GetModelEvaluationAggregateType<T>>

    /**
     * Group by ModelEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelEvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelEvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelEvaluationGroupByArgs['orderBy'] }
        : { orderBy?: ModelEvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelEvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModelEvaluation model
   */
  readonly fields: ModelEvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModelEvaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelEvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evaluationPopulationSample<T extends EvaluationPopulationSampleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvaluationPopulationSampleDefaultArgs<ExtArgs>>): Prisma__EvaluationPopulationSampleClient<$Result.GetResult<Prisma.$EvaluationPopulationSamplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prsModel<T extends PRSModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PRSModelDefaultArgs<ExtArgs>>): Prisma__PRSModelClient<$Result.GetResult<Prisma.$PRSModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    publication<T extends PublicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PublicationDefaultArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    metricEvaluations<T extends ModelEvaluation$metricEvaluationsArgs<ExtArgs> = {}>(args?: Subset<T, ModelEvaluation$metricEvaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceMetricEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModelEvaluation model
   */
  interface ModelEvaluationFieldRefs {
    readonly id: FieldRef<"ModelEvaluation", 'Int'>
    readonly reportedTrait: FieldRef<"ModelEvaluation", 'String'>
    readonly covariates: FieldRef<"ModelEvaluation", 'String'>
    readonly ppmId: FieldRef<"ModelEvaluation", 'String'>
    readonly prsModelId: FieldRef<"ModelEvaluation", 'Int'>
    readonly publicationId: FieldRef<"ModelEvaluation", 'Int'>
    readonly evaluationPopulationSampleId: FieldRef<"ModelEvaluation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ModelEvaluation findUnique
   */
  export type ModelEvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEvaluation
     */
    select?: ModelEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEvaluation
     */
    omit?: ModelEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ModelEvaluation to fetch.
     */
    where: ModelEvaluationWhereUniqueInput
  }

  /**
   * ModelEvaluation findUniqueOrThrow
   */
  export type ModelEvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEvaluation
     */
    select?: ModelEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEvaluation
     */
    omit?: ModelEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ModelEvaluation to fetch.
     */
    where: ModelEvaluationWhereUniqueInput
  }

  /**
   * ModelEvaluation findFirst
   */
  export type ModelEvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEvaluation
     */
    select?: ModelEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEvaluation
     */
    omit?: ModelEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ModelEvaluation to fetch.
     */
    where?: ModelEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelEvaluations to fetch.
     */
    orderBy?: ModelEvaluationOrderByWithRelationInput | ModelEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelEvaluations.
     */
    cursor?: ModelEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelEvaluations.
     */
    distinct?: ModelEvaluationScalarFieldEnum | ModelEvaluationScalarFieldEnum[]
  }

  /**
   * ModelEvaluation findFirstOrThrow
   */
  export type ModelEvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEvaluation
     */
    select?: ModelEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEvaluation
     */
    omit?: ModelEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ModelEvaluation to fetch.
     */
    where?: ModelEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelEvaluations to fetch.
     */
    orderBy?: ModelEvaluationOrderByWithRelationInput | ModelEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelEvaluations.
     */
    cursor?: ModelEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelEvaluations.
     */
    distinct?: ModelEvaluationScalarFieldEnum | ModelEvaluationScalarFieldEnum[]
  }

  /**
   * ModelEvaluation findMany
   */
  export type ModelEvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEvaluation
     */
    select?: ModelEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEvaluation
     */
    omit?: ModelEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ModelEvaluations to fetch.
     */
    where?: ModelEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelEvaluations to fetch.
     */
    orderBy?: ModelEvaluationOrderByWithRelationInput | ModelEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModelEvaluations.
     */
    cursor?: ModelEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelEvaluations.
     */
    skip?: number
    distinct?: ModelEvaluationScalarFieldEnum | ModelEvaluationScalarFieldEnum[]
  }

  /**
   * ModelEvaluation create
   */
  export type ModelEvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEvaluation
     */
    select?: ModelEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEvaluation
     */
    omit?: ModelEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a ModelEvaluation.
     */
    data: XOR<ModelEvaluationCreateInput, ModelEvaluationUncheckedCreateInput>
  }

  /**
   * ModelEvaluation createMany
   */
  export type ModelEvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModelEvaluations.
     */
    data: ModelEvaluationCreateManyInput | ModelEvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModelEvaluation update
   */
  export type ModelEvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEvaluation
     */
    select?: ModelEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEvaluation
     */
    omit?: ModelEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a ModelEvaluation.
     */
    data: XOR<ModelEvaluationUpdateInput, ModelEvaluationUncheckedUpdateInput>
    /**
     * Choose, which ModelEvaluation to update.
     */
    where: ModelEvaluationWhereUniqueInput
  }

  /**
   * ModelEvaluation updateMany
   */
  export type ModelEvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModelEvaluations.
     */
    data: XOR<ModelEvaluationUpdateManyMutationInput, ModelEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which ModelEvaluations to update
     */
    where?: ModelEvaluationWhereInput
    /**
     * Limit how many ModelEvaluations to update.
     */
    limit?: number
  }

  /**
   * ModelEvaluation upsert
   */
  export type ModelEvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEvaluation
     */
    select?: ModelEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEvaluation
     */
    omit?: ModelEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the ModelEvaluation to update in case it exists.
     */
    where: ModelEvaluationWhereUniqueInput
    /**
     * In case the ModelEvaluation found by the `where` argument doesn't exist, create a new ModelEvaluation with this data.
     */
    create: XOR<ModelEvaluationCreateInput, ModelEvaluationUncheckedCreateInput>
    /**
     * In case the ModelEvaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelEvaluationUpdateInput, ModelEvaluationUncheckedUpdateInput>
  }

  /**
   * ModelEvaluation delete
   */
  export type ModelEvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEvaluation
     */
    select?: ModelEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEvaluation
     */
    omit?: ModelEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEvaluationInclude<ExtArgs> | null
    /**
     * Filter which ModelEvaluation to delete.
     */
    where: ModelEvaluationWhereUniqueInput
  }

  /**
   * ModelEvaluation deleteMany
   */
  export type ModelEvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelEvaluations to delete
     */
    where?: ModelEvaluationWhereInput
    /**
     * Limit how many ModelEvaluations to delete.
     */
    limit?: number
  }

  /**
   * ModelEvaluation.metricEvaluations
   */
  export type ModelEvaluation$metricEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetricEvaluation
     */
    select?: PerformanceMetricEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetricEvaluation
     */
    omit?: PerformanceMetricEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricEvaluationInclude<ExtArgs> | null
    where?: PerformanceMetricEvaluationWhereInput
    orderBy?: PerformanceMetricEvaluationOrderByWithRelationInput | PerformanceMetricEvaluationOrderByWithRelationInput[]
    cursor?: PerformanceMetricEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceMetricEvaluationScalarFieldEnum | PerformanceMetricEvaluationScalarFieldEnum[]
  }

  /**
   * ModelEvaluation without action
   */
  export type ModelEvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEvaluation
     */
    select?: ModelEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEvaluation
     */
    omit?: ModelEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEvaluationInclude<ExtArgs> | null
  }


  /**
   * Model PerformanceMetricEvaluation
   */

  export type AggregatePerformanceMetricEvaluation = {
    _count: PerformanceMetricEvaluationCountAggregateOutputType | null
    _avg: PerformanceMetricEvaluationAvgAggregateOutputType | null
    _sum: PerformanceMetricEvaluationSumAggregateOutputType | null
    _min: PerformanceMetricEvaluationMinAggregateOutputType | null
    _max: PerformanceMetricEvaluationMaxAggregateOutputType | null
  }

  export type PerformanceMetricEvaluationAvgAggregateOutputType = {
    id: number | null
    estimate: number | null
    CILower: number | null
    CIUpper: number | null
    modelEvaluationId: number | null
    performanceMetricId: number | null
  }

  export type PerformanceMetricEvaluationSumAggregateOutputType = {
    id: number | null
    estimate: number | null
    CILower: number | null
    CIUpper: number | null
    modelEvaluationId: number | null
    performanceMetricId: number | null
  }

  export type PerformanceMetricEvaluationMinAggregateOutputType = {
    id: number | null
    estimate: number | null
    CILower: number | null
    CIUpper: number | null
    modelEvaluationId: number | null
    performanceMetricId: number | null
  }

  export type PerformanceMetricEvaluationMaxAggregateOutputType = {
    id: number | null
    estimate: number | null
    CILower: number | null
    CIUpper: number | null
    modelEvaluationId: number | null
    performanceMetricId: number | null
  }

  export type PerformanceMetricEvaluationCountAggregateOutputType = {
    id: number
    estimate: number
    CILower: number
    CIUpper: number
    modelEvaluationId: number
    performanceMetricId: number
    _all: number
  }


  export type PerformanceMetricEvaluationAvgAggregateInputType = {
    id?: true
    estimate?: true
    CILower?: true
    CIUpper?: true
    modelEvaluationId?: true
    performanceMetricId?: true
  }

  export type PerformanceMetricEvaluationSumAggregateInputType = {
    id?: true
    estimate?: true
    CILower?: true
    CIUpper?: true
    modelEvaluationId?: true
    performanceMetricId?: true
  }

  export type PerformanceMetricEvaluationMinAggregateInputType = {
    id?: true
    estimate?: true
    CILower?: true
    CIUpper?: true
    modelEvaluationId?: true
    performanceMetricId?: true
  }

  export type PerformanceMetricEvaluationMaxAggregateInputType = {
    id?: true
    estimate?: true
    CILower?: true
    CIUpper?: true
    modelEvaluationId?: true
    performanceMetricId?: true
  }

  export type PerformanceMetricEvaluationCountAggregateInputType = {
    id?: true
    estimate?: true
    CILower?: true
    CIUpper?: true
    modelEvaluationId?: true
    performanceMetricId?: true
    _all?: true
  }

  export type PerformanceMetricEvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceMetricEvaluation to aggregate.
     */
    where?: PerformanceMetricEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetricEvaluations to fetch.
     */
    orderBy?: PerformanceMetricEvaluationOrderByWithRelationInput | PerformanceMetricEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceMetricEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetricEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetricEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceMetricEvaluations
    **/
    _count?: true | PerformanceMetricEvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceMetricEvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceMetricEvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceMetricEvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceMetricEvaluationMaxAggregateInputType
  }

  export type GetPerformanceMetricEvaluationAggregateType<T extends PerformanceMetricEvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceMetricEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceMetricEvaluation[P]>
      : GetScalarType<T[P], AggregatePerformanceMetricEvaluation[P]>
  }




  export type PerformanceMetricEvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceMetricEvaluationWhereInput
    orderBy?: PerformanceMetricEvaluationOrderByWithAggregationInput | PerformanceMetricEvaluationOrderByWithAggregationInput[]
    by: PerformanceMetricEvaluationScalarFieldEnum[] | PerformanceMetricEvaluationScalarFieldEnum
    having?: PerformanceMetricEvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceMetricEvaluationCountAggregateInputType | true
    _avg?: PerformanceMetricEvaluationAvgAggregateInputType
    _sum?: PerformanceMetricEvaluationSumAggregateInputType
    _min?: PerformanceMetricEvaluationMinAggregateInputType
    _max?: PerformanceMetricEvaluationMaxAggregateInputType
  }

  export type PerformanceMetricEvaluationGroupByOutputType = {
    id: number
    estimate: number
    CILower: number | null
    CIUpper: number | null
    modelEvaluationId: number
    performanceMetricId: number
    _count: PerformanceMetricEvaluationCountAggregateOutputType | null
    _avg: PerformanceMetricEvaluationAvgAggregateOutputType | null
    _sum: PerformanceMetricEvaluationSumAggregateOutputType | null
    _min: PerformanceMetricEvaluationMinAggregateOutputType | null
    _max: PerformanceMetricEvaluationMaxAggregateOutputType | null
  }

  type GetPerformanceMetricEvaluationGroupByPayload<T extends PerformanceMetricEvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceMetricEvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceMetricEvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceMetricEvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceMetricEvaluationGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceMetricEvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estimate?: boolean
    CILower?: boolean
    CIUpper?: boolean
    modelEvaluationId?: boolean
    performanceMetricId?: boolean
    modelEvaluation?: boolean | ModelEvaluationDefaultArgs<ExtArgs>
    performanceMetric?: boolean | PerformanceMetricDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceMetricEvaluation"]>



  export type PerformanceMetricEvaluationSelectScalar = {
    id?: boolean
    estimate?: boolean
    CILower?: boolean
    CIUpper?: boolean
    modelEvaluationId?: boolean
    performanceMetricId?: boolean
  }

  export type PerformanceMetricEvaluationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "estimate" | "CILower" | "CIUpper" | "modelEvaluationId" | "performanceMetricId", ExtArgs["result"]["performanceMetricEvaluation"]>
  export type PerformanceMetricEvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modelEvaluation?: boolean | ModelEvaluationDefaultArgs<ExtArgs>
    performanceMetric?: boolean | PerformanceMetricDefaultArgs<ExtArgs>
  }

  export type $PerformanceMetricEvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceMetricEvaluation"
    objects: {
      modelEvaluation: Prisma.$ModelEvaluationPayload<ExtArgs>
      performanceMetric: Prisma.$PerformanceMetricPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      estimate: number
      CILower: number | null
      CIUpper: number | null
      modelEvaluationId: number
      performanceMetricId: number
    }, ExtArgs["result"]["performanceMetricEvaluation"]>
    composites: {}
  }

  type PerformanceMetricEvaluationGetPayload<S extends boolean | null | undefined | PerformanceMetricEvaluationDefaultArgs> = $Result.GetResult<Prisma.$PerformanceMetricEvaluationPayload, S>

  type PerformanceMetricEvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerformanceMetricEvaluationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformanceMetricEvaluationCountAggregateInputType | true
    }

  export interface PerformanceMetricEvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceMetricEvaluation'], meta: { name: 'PerformanceMetricEvaluation' } }
    /**
     * Find zero or one PerformanceMetricEvaluation that matches the filter.
     * @param {PerformanceMetricEvaluationFindUniqueArgs} args - Arguments to find a PerformanceMetricEvaluation
     * @example
     * // Get one PerformanceMetricEvaluation
     * const performanceMetricEvaluation = await prisma.performanceMetricEvaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceMetricEvaluationFindUniqueArgs>(args: SelectSubset<T, PerformanceMetricEvaluationFindUniqueArgs<ExtArgs>>): Prisma__PerformanceMetricEvaluationClient<$Result.GetResult<Prisma.$PerformanceMetricEvaluationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PerformanceMetricEvaluation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerformanceMetricEvaluationFindUniqueOrThrowArgs} args - Arguments to find a PerformanceMetricEvaluation
     * @example
     * // Get one PerformanceMetricEvaluation
     * const performanceMetricEvaluation = await prisma.performanceMetricEvaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceMetricEvaluationFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceMetricEvaluationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceMetricEvaluationClient<$Result.GetResult<Prisma.$PerformanceMetricEvaluationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceMetricEvaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricEvaluationFindFirstArgs} args - Arguments to find a PerformanceMetricEvaluation
     * @example
     * // Get one PerformanceMetricEvaluation
     * const performanceMetricEvaluation = await prisma.performanceMetricEvaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceMetricEvaluationFindFirstArgs>(args?: SelectSubset<T, PerformanceMetricEvaluationFindFirstArgs<ExtArgs>>): Prisma__PerformanceMetricEvaluationClient<$Result.GetResult<Prisma.$PerformanceMetricEvaluationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceMetricEvaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricEvaluationFindFirstOrThrowArgs} args - Arguments to find a PerformanceMetricEvaluation
     * @example
     * // Get one PerformanceMetricEvaluation
     * const performanceMetricEvaluation = await prisma.performanceMetricEvaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceMetricEvaluationFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceMetricEvaluationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceMetricEvaluationClient<$Result.GetResult<Prisma.$PerformanceMetricEvaluationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PerformanceMetricEvaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricEvaluationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceMetricEvaluations
     * const performanceMetricEvaluations = await prisma.performanceMetricEvaluation.findMany()
     * 
     * // Get first 10 PerformanceMetricEvaluations
     * const performanceMetricEvaluations = await prisma.performanceMetricEvaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceMetricEvaluationWithIdOnly = await prisma.performanceMetricEvaluation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceMetricEvaluationFindManyArgs>(args?: SelectSubset<T, PerformanceMetricEvaluationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceMetricEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PerformanceMetricEvaluation.
     * @param {PerformanceMetricEvaluationCreateArgs} args - Arguments to create a PerformanceMetricEvaluation.
     * @example
     * // Create one PerformanceMetricEvaluation
     * const PerformanceMetricEvaluation = await prisma.performanceMetricEvaluation.create({
     *   data: {
     *     // ... data to create a PerformanceMetricEvaluation
     *   }
     * })
     * 
     */
    create<T extends PerformanceMetricEvaluationCreateArgs>(args: SelectSubset<T, PerformanceMetricEvaluationCreateArgs<ExtArgs>>): Prisma__PerformanceMetricEvaluationClient<$Result.GetResult<Prisma.$PerformanceMetricEvaluationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PerformanceMetricEvaluations.
     * @param {PerformanceMetricEvaluationCreateManyArgs} args - Arguments to create many PerformanceMetricEvaluations.
     * @example
     * // Create many PerformanceMetricEvaluations
     * const performanceMetricEvaluation = await prisma.performanceMetricEvaluation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceMetricEvaluationCreateManyArgs>(args?: SelectSubset<T, PerformanceMetricEvaluationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PerformanceMetricEvaluation.
     * @param {PerformanceMetricEvaluationDeleteArgs} args - Arguments to delete one PerformanceMetricEvaluation.
     * @example
     * // Delete one PerformanceMetricEvaluation
     * const PerformanceMetricEvaluation = await prisma.performanceMetricEvaluation.delete({
     *   where: {
     *     // ... filter to delete one PerformanceMetricEvaluation
     *   }
     * })
     * 
     */
    delete<T extends PerformanceMetricEvaluationDeleteArgs>(args: SelectSubset<T, PerformanceMetricEvaluationDeleteArgs<ExtArgs>>): Prisma__PerformanceMetricEvaluationClient<$Result.GetResult<Prisma.$PerformanceMetricEvaluationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PerformanceMetricEvaluation.
     * @param {PerformanceMetricEvaluationUpdateArgs} args - Arguments to update one PerformanceMetricEvaluation.
     * @example
     * // Update one PerformanceMetricEvaluation
     * const performanceMetricEvaluation = await prisma.performanceMetricEvaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceMetricEvaluationUpdateArgs>(args: SelectSubset<T, PerformanceMetricEvaluationUpdateArgs<ExtArgs>>): Prisma__PerformanceMetricEvaluationClient<$Result.GetResult<Prisma.$PerformanceMetricEvaluationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PerformanceMetricEvaluations.
     * @param {PerformanceMetricEvaluationDeleteManyArgs} args - Arguments to filter PerformanceMetricEvaluations to delete.
     * @example
     * // Delete a few PerformanceMetricEvaluations
     * const { count } = await prisma.performanceMetricEvaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceMetricEvaluationDeleteManyArgs>(args?: SelectSubset<T, PerformanceMetricEvaluationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceMetricEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricEvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceMetricEvaluations
     * const performanceMetricEvaluation = await prisma.performanceMetricEvaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceMetricEvaluationUpdateManyArgs>(args: SelectSubset<T, PerformanceMetricEvaluationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PerformanceMetricEvaluation.
     * @param {PerformanceMetricEvaluationUpsertArgs} args - Arguments to update or create a PerformanceMetricEvaluation.
     * @example
     * // Update or create a PerformanceMetricEvaluation
     * const performanceMetricEvaluation = await prisma.performanceMetricEvaluation.upsert({
     *   create: {
     *     // ... data to create a PerformanceMetricEvaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceMetricEvaluation we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceMetricEvaluationUpsertArgs>(args: SelectSubset<T, PerformanceMetricEvaluationUpsertArgs<ExtArgs>>): Prisma__PerformanceMetricEvaluationClient<$Result.GetResult<Prisma.$PerformanceMetricEvaluationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PerformanceMetricEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricEvaluationCountArgs} args - Arguments to filter PerformanceMetricEvaluations to count.
     * @example
     * // Count the number of PerformanceMetricEvaluations
     * const count = await prisma.performanceMetricEvaluation.count({
     *   where: {
     *     // ... the filter for the PerformanceMetricEvaluations we want to count
     *   }
     * })
    **/
    count<T extends PerformanceMetricEvaluationCountArgs>(
      args?: Subset<T, PerformanceMetricEvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceMetricEvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceMetricEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricEvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceMetricEvaluationAggregateArgs>(args: Subset<T, PerformanceMetricEvaluationAggregateArgs>): Prisma.PrismaPromise<GetPerformanceMetricEvaluationAggregateType<T>>

    /**
     * Group by PerformanceMetricEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricEvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceMetricEvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceMetricEvaluationGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceMetricEvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceMetricEvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceMetricEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceMetricEvaluation model
   */
  readonly fields: PerformanceMetricEvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceMetricEvaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceMetricEvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    modelEvaluation<T extends ModelEvaluationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModelEvaluationDefaultArgs<ExtArgs>>): Prisma__ModelEvaluationClient<$Result.GetResult<Prisma.$ModelEvaluationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    performanceMetric<T extends PerformanceMetricDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PerformanceMetricDefaultArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceMetricEvaluation model
   */
  interface PerformanceMetricEvaluationFieldRefs {
    readonly id: FieldRef<"PerformanceMetricEvaluation", 'Int'>
    readonly estimate: FieldRef<"PerformanceMetricEvaluation", 'Float'>
    readonly CILower: FieldRef<"PerformanceMetricEvaluation", 'Float'>
    readonly CIUpper: FieldRef<"PerformanceMetricEvaluation", 'Float'>
    readonly modelEvaluationId: FieldRef<"PerformanceMetricEvaluation", 'Int'>
    readonly performanceMetricId: FieldRef<"PerformanceMetricEvaluation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceMetricEvaluation findUnique
   */
  export type PerformanceMetricEvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetricEvaluation
     */
    select?: PerformanceMetricEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetricEvaluation
     */
    omit?: PerformanceMetricEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetricEvaluation to fetch.
     */
    where: PerformanceMetricEvaluationWhereUniqueInput
  }

  /**
   * PerformanceMetricEvaluation findUniqueOrThrow
   */
  export type PerformanceMetricEvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetricEvaluation
     */
    select?: PerformanceMetricEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetricEvaluation
     */
    omit?: PerformanceMetricEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetricEvaluation to fetch.
     */
    where: PerformanceMetricEvaluationWhereUniqueInput
  }

  /**
   * PerformanceMetricEvaluation findFirst
   */
  export type PerformanceMetricEvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetricEvaluation
     */
    select?: PerformanceMetricEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetricEvaluation
     */
    omit?: PerformanceMetricEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetricEvaluation to fetch.
     */
    where?: PerformanceMetricEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetricEvaluations to fetch.
     */
    orderBy?: PerformanceMetricEvaluationOrderByWithRelationInput | PerformanceMetricEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceMetricEvaluations.
     */
    cursor?: PerformanceMetricEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetricEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetricEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceMetricEvaluations.
     */
    distinct?: PerformanceMetricEvaluationScalarFieldEnum | PerformanceMetricEvaluationScalarFieldEnum[]
  }

  /**
   * PerformanceMetricEvaluation findFirstOrThrow
   */
  export type PerformanceMetricEvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetricEvaluation
     */
    select?: PerformanceMetricEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetricEvaluation
     */
    omit?: PerformanceMetricEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetricEvaluation to fetch.
     */
    where?: PerformanceMetricEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetricEvaluations to fetch.
     */
    orderBy?: PerformanceMetricEvaluationOrderByWithRelationInput | PerformanceMetricEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceMetricEvaluations.
     */
    cursor?: PerformanceMetricEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetricEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetricEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceMetricEvaluations.
     */
    distinct?: PerformanceMetricEvaluationScalarFieldEnum | PerformanceMetricEvaluationScalarFieldEnum[]
  }

  /**
   * PerformanceMetricEvaluation findMany
   */
  export type PerformanceMetricEvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetricEvaluation
     */
    select?: PerformanceMetricEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetricEvaluation
     */
    omit?: PerformanceMetricEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetricEvaluations to fetch.
     */
    where?: PerformanceMetricEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetricEvaluations to fetch.
     */
    orderBy?: PerformanceMetricEvaluationOrderByWithRelationInput | PerformanceMetricEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceMetricEvaluations.
     */
    cursor?: PerformanceMetricEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetricEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetricEvaluations.
     */
    skip?: number
    distinct?: PerformanceMetricEvaluationScalarFieldEnum | PerformanceMetricEvaluationScalarFieldEnum[]
  }

  /**
   * PerformanceMetricEvaluation create
   */
  export type PerformanceMetricEvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetricEvaluation
     */
    select?: PerformanceMetricEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetricEvaluation
     */
    omit?: PerformanceMetricEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a PerformanceMetricEvaluation.
     */
    data: XOR<PerformanceMetricEvaluationCreateInput, PerformanceMetricEvaluationUncheckedCreateInput>
  }

  /**
   * PerformanceMetricEvaluation createMany
   */
  export type PerformanceMetricEvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceMetricEvaluations.
     */
    data: PerformanceMetricEvaluationCreateManyInput | PerformanceMetricEvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceMetricEvaluation update
   */
  export type PerformanceMetricEvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetricEvaluation
     */
    select?: PerformanceMetricEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetricEvaluation
     */
    omit?: PerformanceMetricEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a PerformanceMetricEvaluation.
     */
    data: XOR<PerformanceMetricEvaluationUpdateInput, PerformanceMetricEvaluationUncheckedUpdateInput>
    /**
     * Choose, which PerformanceMetricEvaluation to update.
     */
    where: PerformanceMetricEvaluationWhereUniqueInput
  }

  /**
   * PerformanceMetricEvaluation updateMany
   */
  export type PerformanceMetricEvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceMetricEvaluations.
     */
    data: XOR<PerformanceMetricEvaluationUpdateManyMutationInput, PerformanceMetricEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceMetricEvaluations to update
     */
    where?: PerformanceMetricEvaluationWhereInput
    /**
     * Limit how many PerformanceMetricEvaluations to update.
     */
    limit?: number
  }

  /**
   * PerformanceMetricEvaluation upsert
   */
  export type PerformanceMetricEvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetricEvaluation
     */
    select?: PerformanceMetricEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetricEvaluation
     */
    omit?: PerformanceMetricEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricEvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the PerformanceMetricEvaluation to update in case it exists.
     */
    where: PerformanceMetricEvaluationWhereUniqueInput
    /**
     * In case the PerformanceMetricEvaluation found by the `where` argument doesn't exist, create a new PerformanceMetricEvaluation with this data.
     */
    create: XOR<PerformanceMetricEvaluationCreateInput, PerformanceMetricEvaluationUncheckedCreateInput>
    /**
     * In case the PerformanceMetricEvaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceMetricEvaluationUpdateInput, PerformanceMetricEvaluationUncheckedUpdateInput>
  }

  /**
   * PerformanceMetricEvaluation delete
   */
  export type PerformanceMetricEvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetricEvaluation
     */
    select?: PerformanceMetricEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetricEvaluation
     */
    omit?: PerformanceMetricEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricEvaluationInclude<ExtArgs> | null
    /**
     * Filter which PerformanceMetricEvaluation to delete.
     */
    where: PerformanceMetricEvaluationWhereUniqueInput
  }

  /**
   * PerformanceMetricEvaluation deleteMany
   */
  export type PerformanceMetricEvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceMetricEvaluations to delete
     */
    where?: PerformanceMetricEvaluationWhereInput
    /**
     * Limit how many PerformanceMetricEvaluations to delete.
     */
    limit?: number
  }

  /**
   * PerformanceMetricEvaluation without action
   */
  export type PerformanceMetricEvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetricEvaluation
     */
    select?: PerformanceMetricEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetricEvaluation
     */
    omit?: PerformanceMetricEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricEvaluationInclude<ExtArgs> | null
  }


  /**
   * Model PerformanceMetric
   */

  export type AggregatePerformanceMetric = {
    _count: PerformanceMetricCountAggregateOutputType | null
    _avg: PerformanceMetricAvgAggregateOutputType | null
    _sum: PerformanceMetricSumAggregateOutputType | null
    _min: PerformanceMetricMinAggregateOutputType | null
    _max: PerformanceMetricMaxAggregateOutputType | null
  }

  export type PerformanceMetricAvgAggregateOutputType = {
    id: number | null
  }

  export type PerformanceMetricSumAggregateOutputType = {
    id: number | null
  }

  export type PerformanceMetricMinAggregateOutputType = {
    id: number | null
    nameShort: string | null
    nameLong: string | null
    type: $Enums.PerformanceMetricType | null
  }

  export type PerformanceMetricMaxAggregateOutputType = {
    id: number | null
    nameShort: string | null
    nameLong: string | null
    type: $Enums.PerformanceMetricType | null
  }

  export type PerformanceMetricCountAggregateOutputType = {
    id: number
    nameShort: number
    nameLong: number
    type: number
    _all: number
  }


  export type PerformanceMetricAvgAggregateInputType = {
    id?: true
  }

  export type PerformanceMetricSumAggregateInputType = {
    id?: true
  }

  export type PerformanceMetricMinAggregateInputType = {
    id?: true
    nameShort?: true
    nameLong?: true
    type?: true
  }

  export type PerformanceMetricMaxAggregateInputType = {
    id?: true
    nameShort?: true
    nameLong?: true
    type?: true
  }

  export type PerformanceMetricCountAggregateInputType = {
    id?: true
    nameShort?: true
    nameLong?: true
    type?: true
    _all?: true
  }

  export type PerformanceMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceMetric to aggregate.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceMetrics
    **/
    _count?: true | PerformanceMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceMetricMaxAggregateInputType
  }

  export type GetPerformanceMetricAggregateType<T extends PerformanceMetricAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceMetric[P]>
      : GetScalarType<T[P], AggregatePerformanceMetric[P]>
  }




  export type PerformanceMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceMetricWhereInput
    orderBy?: PerformanceMetricOrderByWithAggregationInput | PerformanceMetricOrderByWithAggregationInput[]
    by: PerformanceMetricScalarFieldEnum[] | PerformanceMetricScalarFieldEnum
    having?: PerformanceMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceMetricCountAggregateInputType | true
    _avg?: PerformanceMetricAvgAggregateInputType
    _sum?: PerformanceMetricSumAggregateInputType
    _min?: PerformanceMetricMinAggregateInputType
    _max?: PerformanceMetricMaxAggregateInputType
  }

  export type PerformanceMetricGroupByOutputType = {
    id: number
    nameShort: string
    nameLong: string | null
    type: $Enums.PerformanceMetricType
    _count: PerformanceMetricCountAggregateOutputType | null
    _avg: PerformanceMetricAvgAggregateOutputType | null
    _sum: PerformanceMetricSumAggregateOutputType | null
    _min: PerformanceMetricMinAggregateOutputType | null
    _max: PerformanceMetricMaxAggregateOutputType | null
  }

  type GetPerformanceMetricGroupByPayload<T extends PerformanceMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceMetricGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceMetricGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nameShort?: boolean
    nameLong?: boolean
    type?: boolean
    performanceMetricEvaluations?: boolean | PerformanceMetric$performanceMetricEvaluationsArgs<ExtArgs>
    _count?: boolean | PerformanceMetricCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceMetric"]>



  export type PerformanceMetricSelectScalar = {
    id?: boolean
    nameShort?: boolean
    nameLong?: boolean
    type?: boolean
  }

  export type PerformanceMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nameShort" | "nameLong" | "type", ExtArgs["result"]["performanceMetric"]>
  export type PerformanceMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performanceMetricEvaluations?: boolean | PerformanceMetric$performanceMetricEvaluationsArgs<ExtArgs>
    _count?: boolean | PerformanceMetricCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PerformanceMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceMetric"
    objects: {
      performanceMetricEvaluations: Prisma.$PerformanceMetricEvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nameShort: string
      nameLong: string | null
      type: $Enums.PerformanceMetricType
    }, ExtArgs["result"]["performanceMetric"]>
    composites: {}
  }

  type PerformanceMetricGetPayload<S extends boolean | null | undefined | PerformanceMetricDefaultArgs> = $Result.GetResult<Prisma.$PerformanceMetricPayload, S>

  type PerformanceMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerformanceMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformanceMetricCountAggregateInputType | true
    }

  export interface PerformanceMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceMetric'], meta: { name: 'PerformanceMetric' } }
    /**
     * Find zero or one PerformanceMetric that matches the filter.
     * @param {PerformanceMetricFindUniqueArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceMetricFindUniqueArgs>(args: SelectSubset<T, PerformanceMetricFindUniqueArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PerformanceMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerformanceMetricFindUniqueOrThrowArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricFindFirstArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceMetricFindFirstArgs>(args?: SelectSubset<T, PerformanceMetricFindFirstArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricFindFirstOrThrowArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PerformanceMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceMetrics
     * const performanceMetrics = await prisma.performanceMetric.findMany()
     * 
     * // Get first 10 PerformanceMetrics
     * const performanceMetrics = await prisma.performanceMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceMetricWithIdOnly = await prisma.performanceMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceMetricFindManyArgs>(args?: SelectSubset<T, PerformanceMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PerformanceMetric.
     * @param {PerformanceMetricCreateArgs} args - Arguments to create a PerformanceMetric.
     * @example
     * // Create one PerformanceMetric
     * const PerformanceMetric = await prisma.performanceMetric.create({
     *   data: {
     *     // ... data to create a PerformanceMetric
     *   }
     * })
     * 
     */
    create<T extends PerformanceMetricCreateArgs>(args: SelectSubset<T, PerformanceMetricCreateArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PerformanceMetrics.
     * @param {PerformanceMetricCreateManyArgs} args - Arguments to create many PerformanceMetrics.
     * @example
     * // Create many PerformanceMetrics
     * const performanceMetric = await prisma.performanceMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceMetricCreateManyArgs>(args?: SelectSubset<T, PerformanceMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PerformanceMetric.
     * @param {PerformanceMetricDeleteArgs} args - Arguments to delete one PerformanceMetric.
     * @example
     * // Delete one PerformanceMetric
     * const PerformanceMetric = await prisma.performanceMetric.delete({
     *   where: {
     *     // ... filter to delete one PerformanceMetric
     *   }
     * })
     * 
     */
    delete<T extends PerformanceMetricDeleteArgs>(args: SelectSubset<T, PerformanceMetricDeleteArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PerformanceMetric.
     * @param {PerformanceMetricUpdateArgs} args - Arguments to update one PerformanceMetric.
     * @example
     * // Update one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceMetricUpdateArgs>(args: SelectSubset<T, PerformanceMetricUpdateArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PerformanceMetrics.
     * @param {PerformanceMetricDeleteManyArgs} args - Arguments to filter PerformanceMetrics to delete.
     * @example
     * // Delete a few PerformanceMetrics
     * const { count } = await prisma.performanceMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceMetricDeleteManyArgs>(args?: SelectSubset<T, PerformanceMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceMetrics
     * const performanceMetric = await prisma.performanceMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceMetricUpdateManyArgs>(args: SelectSubset<T, PerformanceMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PerformanceMetric.
     * @param {PerformanceMetricUpsertArgs} args - Arguments to update or create a PerformanceMetric.
     * @example
     * // Update or create a PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.upsert({
     *   create: {
     *     // ... data to create a PerformanceMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceMetric we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceMetricUpsertArgs>(args: SelectSubset<T, PerformanceMetricUpsertArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PerformanceMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricCountArgs} args - Arguments to filter PerformanceMetrics to count.
     * @example
     * // Count the number of PerformanceMetrics
     * const count = await prisma.performanceMetric.count({
     *   where: {
     *     // ... the filter for the PerformanceMetrics we want to count
     *   }
     * })
    **/
    count<T extends PerformanceMetricCountArgs>(
      args?: Subset<T, PerformanceMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceMetricAggregateArgs>(args: Subset<T, PerformanceMetricAggregateArgs>): Prisma.PrismaPromise<GetPerformanceMetricAggregateType<T>>

    /**
     * Group by PerformanceMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceMetricGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceMetric model
   */
  readonly fields: PerformanceMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    performanceMetricEvaluations<T extends PerformanceMetric$performanceMetricEvaluationsArgs<ExtArgs> = {}>(args?: Subset<T, PerformanceMetric$performanceMetricEvaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceMetricEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceMetric model
   */
  interface PerformanceMetricFieldRefs {
    readonly id: FieldRef<"PerformanceMetric", 'Int'>
    readonly nameShort: FieldRef<"PerformanceMetric", 'String'>
    readonly nameLong: FieldRef<"PerformanceMetric", 'String'>
    readonly type: FieldRef<"PerformanceMetric", 'PerformanceMetricType'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceMetric findUnique
   */
  export type PerformanceMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric findUniqueOrThrow
   */
  export type PerformanceMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric findFirst
   */
  export type PerformanceMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceMetrics.
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceMetrics.
     */
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }

  /**
   * PerformanceMetric findFirstOrThrow
   */
  export type PerformanceMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceMetrics.
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceMetrics.
     */
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }

  /**
   * PerformanceMetric findMany
   */
  export type PerformanceMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetrics to fetch.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceMetrics.
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }

  /**
   * PerformanceMetric create
   */
  export type PerformanceMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a PerformanceMetric.
     */
    data: XOR<PerformanceMetricCreateInput, PerformanceMetricUncheckedCreateInput>
  }

  /**
   * PerformanceMetric createMany
   */
  export type PerformanceMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceMetrics.
     */
    data: PerformanceMetricCreateManyInput | PerformanceMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceMetric update
   */
  export type PerformanceMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a PerformanceMetric.
     */
    data: XOR<PerformanceMetricUpdateInput, PerformanceMetricUncheckedUpdateInput>
    /**
     * Choose, which PerformanceMetric to update.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric updateMany
   */
  export type PerformanceMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceMetrics.
     */
    data: XOR<PerformanceMetricUpdateManyMutationInput, PerformanceMetricUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceMetrics to update
     */
    where?: PerformanceMetricWhereInput
    /**
     * Limit how many PerformanceMetrics to update.
     */
    limit?: number
  }

  /**
   * PerformanceMetric upsert
   */
  export type PerformanceMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the PerformanceMetric to update in case it exists.
     */
    where: PerformanceMetricWhereUniqueInput
    /**
     * In case the PerformanceMetric found by the `where` argument doesn't exist, create a new PerformanceMetric with this data.
     */
    create: XOR<PerformanceMetricCreateInput, PerformanceMetricUncheckedCreateInput>
    /**
     * In case the PerformanceMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceMetricUpdateInput, PerformanceMetricUncheckedUpdateInput>
  }

  /**
   * PerformanceMetric delete
   */
  export type PerformanceMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter which PerformanceMetric to delete.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric deleteMany
   */
  export type PerformanceMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceMetrics to delete
     */
    where?: PerformanceMetricWhereInput
    /**
     * Limit how many PerformanceMetrics to delete.
     */
    limit?: number
  }

  /**
   * PerformanceMetric.performanceMetricEvaluations
   */
  export type PerformanceMetric$performanceMetricEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetricEvaluation
     */
    select?: PerformanceMetricEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetricEvaluation
     */
    omit?: PerformanceMetricEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricEvaluationInclude<ExtArgs> | null
    where?: PerformanceMetricEvaluationWhereInput
    orderBy?: PerformanceMetricEvaluationOrderByWithRelationInput | PerformanceMetricEvaluationOrderByWithRelationInput[]
    cursor?: PerformanceMetricEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceMetricEvaluationScalarFieldEnum | PerformanceMetricEvaluationScalarFieldEnum[]
  }

  /**
   * PerformanceMetric without action
   */
  export type PerformanceMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
  }


  /**
   * Model EvaluationPopulationSample
   */

  export type AggregateEvaluationPopulationSample = {
    _count: EvaluationPopulationSampleCountAggregateOutputType | null
    _avg: EvaluationPopulationSampleAvgAggregateOutputType | null
    _sum: EvaluationPopulationSampleSumAggregateOutputType | null
    _min: EvaluationPopulationSampleMinAggregateOutputType | null
    _max: EvaluationPopulationSampleMaxAggregateOutputType | null
  }

  export type EvaluationPopulationSampleAvgAggregateOutputType = {
    id: number | null
    numberOfIndividuals: number | null
    numberOfCases: number | null
    numberOfControls: number | null
    percentMale: number | null
    age: number | null
    broadAncestryId: number | null
  }

  export type EvaluationPopulationSampleSumAggregateOutputType = {
    id: number | null
    numberOfIndividuals: number | null
    numberOfCases: number | null
    numberOfControls: number | null
    percentMale: number | null
    age: number | null
    broadAncestryId: number | null
  }

  export type EvaluationPopulationSampleMinAggregateOutputType = {
    id: number | null
    numberOfIndividuals: number | null
    numberOfCases: number | null
    numberOfControls: number | null
    percentMale: number | null
    age: number | null
    ageUnits: string | null
    ancestryBroad: string | null
    ancestryDetails: string | null
    cohort: string | null
    gcId: string | null
    sourcePMID: string | null
    sourceDOI: string | null
    phenotypeFree: string | null
    pssId: string | null
    broadAncestryId: number | null
  }

  export type EvaluationPopulationSampleMaxAggregateOutputType = {
    id: number | null
    numberOfIndividuals: number | null
    numberOfCases: number | null
    numberOfControls: number | null
    percentMale: number | null
    age: number | null
    ageUnits: string | null
    ancestryBroad: string | null
    ancestryDetails: string | null
    cohort: string | null
    gcId: string | null
    sourcePMID: string | null
    sourceDOI: string | null
    phenotypeFree: string | null
    pssId: string | null
    broadAncestryId: number | null
  }

  export type EvaluationPopulationSampleCountAggregateOutputType = {
    id: number
    numberOfIndividuals: number
    numberOfCases: number
    numberOfControls: number
    percentMale: number
    age: number
    ageUnits: number
    ancestryBroad: number
    ancestryDetails: number
    cohort: number
    gcId: number
    sourcePMID: number
    sourceDOI: number
    phenotypeFree: number
    pssId: number
    broadAncestryId: number
    _all: number
  }


  export type EvaluationPopulationSampleAvgAggregateInputType = {
    id?: true
    numberOfIndividuals?: true
    numberOfCases?: true
    numberOfControls?: true
    percentMale?: true
    age?: true
    broadAncestryId?: true
  }

  export type EvaluationPopulationSampleSumAggregateInputType = {
    id?: true
    numberOfIndividuals?: true
    numberOfCases?: true
    numberOfControls?: true
    percentMale?: true
    age?: true
    broadAncestryId?: true
  }

  export type EvaluationPopulationSampleMinAggregateInputType = {
    id?: true
    numberOfIndividuals?: true
    numberOfCases?: true
    numberOfControls?: true
    percentMale?: true
    age?: true
    ageUnits?: true
    ancestryBroad?: true
    ancestryDetails?: true
    cohort?: true
    gcId?: true
    sourcePMID?: true
    sourceDOI?: true
    phenotypeFree?: true
    pssId?: true
    broadAncestryId?: true
  }

  export type EvaluationPopulationSampleMaxAggregateInputType = {
    id?: true
    numberOfIndividuals?: true
    numberOfCases?: true
    numberOfControls?: true
    percentMale?: true
    age?: true
    ageUnits?: true
    ancestryBroad?: true
    ancestryDetails?: true
    cohort?: true
    gcId?: true
    sourcePMID?: true
    sourceDOI?: true
    phenotypeFree?: true
    pssId?: true
    broadAncestryId?: true
  }

  export type EvaluationPopulationSampleCountAggregateInputType = {
    id?: true
    numberOfIndividuals?: true
    numberOfCases?: true
    numberOfControls?: true
    percentMale?: true
    age?: true
    ageUnits?: true
    ancestryBroad?: true
    ancestryDetails?: true
    cohort?: true
    gcId?: true
    sourcePMID?: true
    sourceDOI?: true
    phenotypeFree?: true
    pssId?: true
    broadAncestryId?: true
    _all?: true
  }

  export type EvaluationPopulationSampleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationPopulationSample to aggregate.
     */
    where?: EvaluationPopulationSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationPopulationSamples to fetch.
     */
    orderBy?: EvaluationPopulationSampleOrderByWithRelationInput | EvaluationPopulationSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationPopulationSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationPopulationSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationPopulationSamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvaluationPopulationSamples
    **/
    _count?: true | EvaluationPopulationSampleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluationPopulationSampleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluationPopulationSampleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationPopulationSampleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationPopulationSampleMaxAggregateInputType
  }

  export type GetEvaluationPopulationSampleAggregateType<T extends EvaluationPopulationSampleAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluationPopulationSample]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluationPopulationSample[P]>
      : GetScalarType<T[P], AggregateEvaluationPopulationSample[P]>
  }




  export type EvaluationPopulationSampleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationPopulationSampleWhereInput
    orderBy?: EvaluationPopulationSampleOrderByWithAggregationInput | EvaluationPopulationSampleOrderByWithAggregationInput[]
    by: EvaluationPopulationSampleScalarFieldEnum[] | EvaluationPopulationSampleScalarFieldEnum
    having?: EvaluationPopulationSampleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationPopulationSampleCountAggregateInputType | true
    _avg?: EvaluationPopulationSampleAvgAggregateInputType
    _sum?: EvaluationPopulationSampleSumAggregateInputType
    _min?: EvaluationPopulationSampleMinAggregateInputType
    _max?: EvaluationPopulationSampleMaxAggregateInputType
  }

  export type EvaluationPopulationSampleGroupByOutputType = {
    id: number
    numberOfIndividuals: number
    numberOfCases: number | null
    numberOfControls: number | null
    percentMale: number | null
    age: number | null
    ageUnits: string | null
    ancestryBroad: string
    ancestryDetails: string | null
    cohort: string
    gcId: string | null
    sourcePMID: string | null
    sourceDOI: string | null
    phenotypeFree: string | null
    pssId: string
    broadAncestryId: number
    _count: EvaluationPopulationSampleCountAggregateOutputType | null
    _avg: EvaluationPopulationSampleAvgAggregateOutputType | null
    _sum: EvaluationPopulationSampleSumAggregateOutputType | null
    _min: EvaluationPopulationSampleMinAggregateOutputType | null
    _max: EvaluationPopulationSampleMaxAggregateOutputType | null
  }

  type GetEvaluationPopulationSampleGroupByPayload<T extends EvaluationPopulationSampleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationPopulationSampleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationPopulationSampleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationPopulationSampleGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationPopulationSampleGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationPopulationSampleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numberOfIndividuals?: boolean
    numberOfCases?: boolean
    numberOfControls?: boolean
    percentMale?: boolean
    age?: boolean
    ageUnits?: boolean
    ancestryBroad?: boolean
    ancestryDetails?: boolean
    cohort?: boolean
    gcId?: boolean
    sourcePMID?: boolean
    sourceDOI?: boolean
    phenotypeFree?: boolean
    pssId?: boolean
    broadAncestryId?: boolean
    broadAncestryCategory?: boolean | BroadAncestryCategoryDefaultArgs<ExtArgs>
    modelEvaluations?: boolean | EvaluationPopulationSample$modelEvaluationsArgs<ExtArgs>
    _count?: boolean | EvaluationPopulationSampleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluationPopulationSample"]>



  export type EvaluationPopulationSampleSelectScalar = {
    id?: boolean
    numberOfIndividuals?: boolean
    numberOfCases?: boolean
    numberOfControls?: boolean
    percentMale?: boolean
    age?: boolean
    ageUnits?: boolean
    ancestryBroad?: boolean
    ancestryDetails?: boolean
    cohort?: boolean
    gcId?: boolean
    sourcePMID?: boolean
    sourceDOI?: boolean
    phenotypeFree?: boolean
    pssId?: boolean
    broadAncestryId?: boolean
  }

  export type EvaluationPopulationSampleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "numberOfIndividuals" | "numberOfCases" | "numberOfControls" | "percentMale" | "age" | "ageUnits" | "ancestryBroad" | "ancestryDetails" | "cohort" | "gcId" | "sourcePMID" | "sourceDOI" | "phenotypeFree" | "pssId" | "broadAncestryId", ExtArgs["result"]["evaluationPopulationSample"]>
  export type EvaluationPopulationSampleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    broadAncestryCategory?: boolean | BroadAncestryCategoryDefaultArgs<ExtArgs>
    modelEvaluations?: boolean | EvaluationPopulationSample$modelEvaluationsArgs<ExtArgs>
    _count?: boolean | EvaluationPopulationSampleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EvaluationPopulationSamplePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvaluationPopulationSample"
    objects: {
      broadAncestryCategory: Prisma.$BroadAncestryCategoryPayload<ExtArgs>
      modelEvaluations: Prisma.$ModelEvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      numberOfIndividuals: number
      numberOfCases: number | null
      numberOfControls: number | null
      percentMale: number | null
      age: number | null
      ageUnits: string | null
      ancestryBroad: string
      ancestryDetails: string | null
      cohort: string
      gcId: string | null
      sourcePMID: string | null
      sourceDOI: string | null
      phenotypeFree: string | null
      pssId: string
      broadAncestryId: number
    }, ExtArgs["result"]["evaluationPopulationSample"]>
    composites: {}
  }

  type EvaluationPopulationSampleGetPayload<S extends boolean | null | undefined | EvaluationPopulationSampleDefaultArgs> = $Result.GetResult<Prisma.$EvaluationPopulationSamplePayload, S>

  type EvaluationPopulationSampleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvaluationPopulationSampleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvaluationPopulationSampleCountAggregateInputType | true
    }

  export interface EvaluationPopulationSampleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvaluationPopulationSample'], meta: { name: 'EvaluationPopulationSample' } }
    /**
     * Find zero or one EvaluationPopulationSample that matches the filter.
     * @param {EvaluationPopulationSampleFindUniqueArgs} args - Arguments to find a EvaluationPopulationSample
     * @example
     * // Get one EvaluationPopulationSample
     * const evaluationPopulationSample = await prisma.evaluationPopulationSample.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvaluationPopulationSampleFindUniqueArgs>(args: SelectSubset<T, EvaluationPopulationSampleFindUniqueArgs<ExtArgs>>): Prisma__EvaluationPopulationSampleClient<$Result.GetResult<Prisma.$EvaluationPopulationSamplePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EvaluationPopulationSample that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvaluationPopulationSampleFindUniqueOrThrowArgs} args - Arguments to find a EvaluationPopulationSample
     * @example
     * // Get one EvaluationPopulationSample
     * const evaluationPopulationSample = await prisma.evaluationPopulationSample.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvaluationPopulationSampleFindUniqueOrThrowArgs>(args: SelectSubset<T, EvaluationPopulationSampleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvaluationPopulationSampleClient<$Result.GetResult<Prisma.$EvaluationPopulationSamplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EvaluationPopulationSample that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationPopulationSampleFindFirstArgs} args - Arguments to find a EvaluationPopulationSample
     * @example
     * // Get one EvaluationPopulationSample
     * const evaluationPopulationSample = await prisma.evaluationPopulationSample.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvaluationPopulationSampleFindFirstArgs>(args?: SelectSubset<T, EvaluationPopulationSampleFindFirstArgs<ExtArgs>>): Prisma__EvaluationPopulationSampleClient<$Result.GetResult<Prisma.$EvaluationPopulationSamplePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EvaluationPopulationSample that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationPopulationSampleFindFirstOrThrowArgs} args - Arguments to find a EvaluationPopulationSample
     * @example
     * // Get one EvaluationPopulationSample
     * const evaluationPopulationSample = await prisma.evaluationPopulationSample.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvaluationPopulationSampleFindFirstOrThrowArgs>(args?: SelectSubset<T, EvaluationPopulationSampleFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvaluationPopulationSampleClient<$Result.GetResult<Prisma.$EvaluationPopulationSamplePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EvaluationPopulationSamples that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationPopulationSampleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvaluationPopulationSamples
     * const evaluationPopulationSamples = await prisma.evaluationPopulationSample.findMany()
     * 
     * // Get first 10 EvaluationPopulationSamples
     * const evaluationPopulationSamples = await prisma.evaluationPopulationSample.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationPopulationSampleWithIdOnly = await prisma.evaluationPopulationSample.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvaluationPopulationSampleFindManyArgs>(args?: SelectSubset<T, EvaluationPopulationSampleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPopulationSamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EvaluationPopulationSample.
     * @param {EvaluationPopulationSampleCreateArgs} args - Arguments to create a EvaluationPopulationSample.
     * @example
     * // Create one EvaluationPopulationSample
     * const EvaluationPopulationSample = await prisma.evaluationPopulationSample.create({
     *   data: {
     *     // ... data to create a EvaluationPopulationSample
     *   }
     * })
     * 
     */
    create<T extends EvaluationPopulationSampleCreateArgs>(args: SelectSubset<T, EvaluationPopulationSampleCreateArgs<ExtArgs>>): Prisma__EvaluationPopulationSampleClient<$Result.GetResult<Prisma.$EvaluationPopulationSamplePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EvaluationPopulationSamples.
     * @param {EvaluationPopulationSampleCreateManyArgs} args - Arguments to create many EvaluationPopulationSamples.
     * @example
     * // Create many EvaluationPopulationSamples
     * const evaluationPopulationSample = await prisma.evaluationPopulationSample.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvaluationPopulationSampleCreateManyArgs>(args?: SelectSubset<T, EvaluationPopulationSampleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EvaluationPopulationSample.
     * @param {EvaluationPopulationSampleDeleteArgs} args - Arguments to delete one EvaluationPopulationSample.
     * @example
     * // Delete one EvaluationPopulationSample
     * const EvaluationPopulationSample = await prisma.evaluationPopulationSample.delete({
     *   where: {
     *     // ... filter to delete one EvaluationPopulationSample
     *   }
     * })
     * 
     */
    delete<T extends EvaluationPopulationSampleDeleteArgs>(args: SelectSubset<T, EvaluationPopulationSampleDeleteArgs<ExtArgs>>): Prisma__EvaluationPopulationSampleClient<$Result.GetResult<Prisma.$EvaluationPopulationSamplePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EvaluationPopulationSample.
     * @param {EvaluationPopulationSampleUpdateArgs} args - Arguments to update one EvaluationPopulationSample.
     * @example
     * // Update one EvaluationPopulationSample
     * const evaluationPopulationSample = await prisma.evaluationPopulationSample.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvaluationPopulationSampleUpdateArgs>(args: SelectSubset<T, EvaluationPopulationSampleUpdateArgs<ExtArgs>>): Prisma__EvaluationPopulationSampleClient<$Result.GetResult<Prisma.$EvaluationPopulationSamplePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EvaluationPopulationSamples.
     * @param {EvaluationPopulationSampleDeleteManyArgs} args - Arguments to filter EvaluationPopulationSamples to delete.
     * @example
     * // Delete a few EvaluationPopulationSamples
     * const { count } = await prisma.evaluationPopulationSample.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvaluationPopulationSampleDeleteManyArgs>(args?: SelectSubset<T, EvaluationPopulationSampleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvaluationPopulationSamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationPopulationSampleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvaluationPopulationSamples
     * const evaluationPopulationSample = await prisma.evaluationPopulationSample.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvaluationPopulationSampleUpdateManyArgs>(args: SelectSubset<T, EvaluationPopulationSampleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EvaluationPopulationSample.
     * @param {EvaluationPopulationSampleUpsertArgs} args - Arguments to update or create a EvaluationPopulationSample.
     * @example
     * // Update or create a EvaluationPopulationSample
     * const evaluationPopulationSample = await prisma.evaluationPopulationSample.upsert({
     *   create: {
     *     // ... data to create a EvaluationPopulationSample
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvaluationPopulationSample we want to update
     *   }
     * })
     */
    upsert<T extends EvaluationPopulationSampleUpsertArgs>(args: SelectSubset<T, EvaluationPopulationSampleUpsertArgs<ExtArgs>>): Prisma__EvaluationPopulationSampleClient<$Result.GetResult<Prisma.$EvaluationPopulationSamplePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EvaluationPopulationSamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationPopulationSampleCountArgs} args - Arguments to filter EvaluationPopulationSamples to count.
     * @example
     * // Count the number of EvaluationPopulationSamples
     * const count = await prisma.evaluationPopulationSample.count({
     *   where: {
     *     // ... the filter for the EvaluationPopulationSamples we want to count
     *   }
     * })
    **/
    count<T extends EvaluationPopulationSampleCountArgs>(
      args?: Subset<T, EvaluationPopulationSampleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationPopulationSampleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvaluationPopulationSample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationPopulationSampleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationPopulationSampleAggregateArgs>(args: Subset<T, EvaluationPopulationSampleAggregateArgs>): Prisma.PrismaPromise<GetEvaluationPopulationSampleAggregateType<T>>

    /**
     * Group by EvaluationPopulationSample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationPopulationSampleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationPopulationSampleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationPopulationSampleGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationPopulationSampleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationPopulationSampleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationPopulationSampleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvaluationPopulationSample model
   */
  readonly fields: EvaluationPopulationSampleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvaluationPopulationSample.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationPopulationSampleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    broadAncestryCategory<T extends BroadAncestryCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BroadAncestryCategoryDefaultArgs<ExtArgs>>): Prisma__BroadAncestryCategoryClient<$Result.GetResult<Prisma.$BroadAncestryCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    modelEvaluations<T extends EvaluationPopulationSample$modelEvaluationsArgs<ExtArgs> = {}>(args?: Subset<T, EvaluationPopulationSample$modelEvaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvaluationPopulationSample model
   */
  interface EvaluationPopulationSampleFieldRefs {
    readonly id: FieldRef<"EvaluationPopulationSample", 'Int'>
    readonly numberOfIndividuals: FieldRef<"EvaluationPopulationSample", 'Int'>
    readonly numberOfCases: FieldRef<"EvaluationPopulationSample", 'Int'>
    readonly numberOfControls: FieldRef<"EvaluationPopulationSample", 'Int'>
    readonly percentMale: FieldRef<"EvaluationPopulationSample", 'Float'>
    readonly age: FieldRef<"EvaluationPopulationSample", 'Float'>
    readonly ageUnits: FieldRef<"EvaluationPopulationSample", 'String'>
    readonly ancestryBroad: FieldRef<"EvaluationPopulationSample", 'String'>
    readonly ancestryDetails: FieldRef<"EvaluationPopulationSample", 'String'>
    readonly cohort: FieldRef<"EvaluationPopulationSample", 'String'>
    readonly gcId: FieldRef<"EvaluationPopulationSample", 'String'>
    readonly sourcePMID: FieldRef<"EvaluationPopulationSample", 'String'>
    readonly sourceDOI: FieldRef<"EvaluationPopulationSample", 'String'>
    readonly phenotypeFree: FieldRef<"EvaluationPopulationSample", 'String'>
    readonly pssId: FieldRef<"EvaluationPopulationSample", 'String'>
    readonly broadAncestryId: FieldRef<"EvaluationPopulationSample", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EvaluationPopulationSample findUnique
   */
  export type EvaluationPopulationSampleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPopulationSample
     */
    select?: EvaluationPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationPopulationSample
     */
    omit?: EvaluationPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationPopulationSampleInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationPopulationSample to fetch.
     */
    where: EvaluationPopulationSampleWhereUniqueInput
  }

  /**
   * EvaluationPopulationSample findUniqueOrThrow
   */
  export type EvaluationPopulationSampleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPopulationSample
     */
    select?: EvaluationPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationPopulationSample
     */
    omit?: EvaluationPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationPopulationSampleInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationPopulationSample to fetch.
     */
    where: EvaluationPopulationSampleWhereUniqueInput
  }

  /**
   * EvaluationPopulationSample findFirst
   */
  export type EvaluationPopulationSampleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPopulationSample
     */
    select?: EvaluationPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationPopulationSample
     */
    omit?: EvaluationPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationPopulationSampleInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationPopulationSample to fetch.
     */
    where?: EvaluationPopulationSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationPopulationSamples to fetch.
     */
    orderBy?: EvaluationPopulationSampleOrderByWithRelationInput | EvaluationPopulationSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationPopulationSamples.
     */
    cursor?: EvaluationPopulationSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationPopulationSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationPopulationSamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationPopulationSamples.
     */
    distinct?: EvaluationPopulationSampleScalarFieldEnum | EvaluationPopulationSampleScalarFieldEnum[]
  }

  /**
   * EvaluationPopulationSample findFirstOrThrow
   */
  export type EvaluationPopulationSampleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPopulationSample
     */
    select?: EvaluationPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationPopulationSample
     */
    omit?: EvaluationPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationPopulationSampleInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationPopulationSample to fetch.
     */
    where?: EvaluationPopulationSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationPopulationSamples to fetch.
     */
    orderBy?: EvaluationPopulationSampleOrderByWithRelationInput | EvaluationPopulationSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationPopulationSamples.
     */
    cursor?: EvaluationPopulationSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationPopulationSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationPopulationSamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationPopulationSamples.
     */
    distinct?: EvaluationPopulationSampleScalarFieldEnum | EvaluationPopulationSampleScalarFieldEnum[]
  }

  /**
   * EvaluationPopulationSample findMany
   */
  export type EvaluationPopulationSampleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPopulationSample
     */
    select?: EvaluationPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationPopulationSample
     */
    omit?: EvaluationPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationPopulationSampleInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationPopulationSamples to fetch.
     */
    where?: EvaluationPopulationSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationPopulationSamples to fetch.
     */
    orderBy?: EvaluationPopulationSampleOrderByWithRelationInput | EvaluationPopulationSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvaluationPopulationSamples.
     */
    cursor?: EvaluationPopulationSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationPopulationSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationPopulationSamples.
     */
    skip?: number
    distinct?: EvaluationPopulationSampleScalarFieldEnum | EvaluationPopulationSampleScalarFieldEnum[]
  }

  /**
   * EvaluationPopulationSample create
   */
  export type EvaluationPopulationSampleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPopulationSample
     */
    select?: EvaluationPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationPopulationSample
     */
    omit?: EvaluationPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationPopulationSampleInclude<ExtArgs> | null
    /**
     * The data needed to create a EvaluationPopulationSample.
     */
    data: XOR<EvaluationPopulationSampleCreateInput, EvaluationPopulationSampleUncheckedCreateInput>
  }

  /**
   * EvaluationPopulationSample createMany
   */
  export type EvaluationPopulationSampleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvaluationPopulationSamples.
     */
    data: EvaluationPopulationSampleCreateManyInput | EvaluationPopulationSampleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvaluationPopulationSample update
   */
  export type EvaluationPopulationSampleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPopulationSample
     */
    select?: EvaluationPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationPopulationSample
     */
    omit?: EvaluationPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationPopulationSampleInclude<ExtArgs> | null
    /**
     * The data needed to update a EvaluationPopulationSample.
     */
    data: XOR<EvaluationPopulationSampleUpdateInput, EvaluationPopulationSampleUncheckedUpdateInput>
    /**
     * Choose, which EvaluationPopulationSample to update.
     */
    where: EvaluationPopulationSampleWhereUniqueInput
  }

  /**
   * EvaluationPopulationSample updateMany
   */
  export type EvaluationPopulationSampleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvaluationPopulationSamples.
     */
    data: XOR<EvaluationPopulationSampleUpdateManyMutationInput, EvaluationPopulationSampleUncheckedUpdateManyInput>
    /**
     * Filter which EvaluationPopulationSamples to update
     */
    where?: EvaluationPopulationSampleWhereInput
    /**
     * Limit how many EvaluationPopulationSamples to update.
     */
    limit?: number
  }

  /**
   * EvaluationPopulationSample upsert
   */
  export type EvaluationPopulationSampleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPopulationSample
     */
    select?: EvaluationPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationPopulationSample
     */
    omit?: EvaluationPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationPopulationSampleInclude<ExtArgs> | null
    /**
     * The filter to search for the EvaluationPopulationSample to update in case it exists.
     */
    where: EvaluationPopulationSampleWhereUniqueInput
    /**
     * In case the EvaluationPopulationSample found by the `where` argument doesn't exist, create a new EvaluationPopulationSample with this data.
     */
    create: XOR<EvaluationPopulationSampleCreateInput, EvaluationPopulationSampleUncheckedCreateInput>
    /**
     * In case the EvaluationPopulationSample was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationPopulationSampleUpdateInput, EvaluationPopulationSampleUncheckedUpdateInput>
  }

  /**
   * EvaluationPopulationSample delete
   */
  export type EvaluationPopulationSampleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPopulationSample
     */
    select?: EvaluationPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationPopulationSample
     */
    omit?: EvaluationPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationPopulationSampleInclude<ExtArgs> | null
    /**
     * Filter which EvaluationPopulationSample to delete.
     */
    where: EvaluationPopulationSampleWhereUniqueInput
  }

  /**
   * EvaluationPopulationSample deleteMany
   */
  export type EvaluationPopulationSampleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationPopulationSamples to delete
     */
    where?: EvaluationPopulationSampleWhereInput
    /**
     * Limit how many EvaluationPopulationSamples to delete.
     */
    limit?: number
  }

  /**
   * EvaluationPopulationSample.modelEvaluations
   */
  export type EvaluationPopulationSample$modelEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelEvaluation
     */
    select?: ModelEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelEvaluation
     */
    omit?: ModelEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelEvaluationInclude<ExtArgs> | null
    where?: ModelEvaluationWhereInput
    orderBy?: ModelEvaluationOrderByWithRelationInput | ModelEvaluationOrderByWithRelationInput[]
    cursor?: ModelEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelEvaluationScalarFieldEnum | ModelEvaluationScalarFieldEnum[]
  }

  /**
   * EvaluationPopulationSample without action
   */
  export type EvaluationPopulationSampleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPopulationSample
     */
    select?: EvaluationPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationPopulationSample
     */
    omit?: EvaluationPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationPopulationSampleInclude<ExtArgs> | null
  }


  /**
   * Model BroadAncestryCategory
   */

  export type AggregateBroadAncestryCategory = {
    _count: BroadAncestryCategoryCountAggregateOutputType | null
    _avg: BroadAncestryCategoryAvgAggregateOutputType | null
    _sum: BroadAncestryCategorySumAggregateOutputType | null
    _min: BroadAncestryCategoryMinAggregateOutputType | null
    _max: BroadAncestryCategoryMaxAggregateOutputType | null
  }

  export type BroadAncestryCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type BroadAncestryCategorySumAggregateOutputType = {
    id: number | null
  }

  export type BroadAncestryCategoryMinAggregateOutputType = {
    id: number | null
    symbol: string | null
    label: string | null
  }

  export type BroadAncestryCategoryMaxAggregateOutputType = {
    id: number | null
    symbol: string | null
    label: string | null
  }

  export type BroadAncestryCategoryCountAggregateOutputType = {
    id: number
    symbol: number
    label: number
    _all: number
  }


  export type BroadAncestryCategoryAvgAggregateInputType = {
    id?: true
  }

  export type BroadAncestryCategorySumAggregateInputType = {
    id?: true
  }

  export type BroadAncestryCategoryMinAggregateInputType = {
    id?: true
    symbol?: true
    label?: true
  }

  export type BroadAncestryCategoryMaxAggregateInputType = {
    id?: true
    symbol?: true
    label?: true
  }

  export type BroadAncestryCategoryCountAggregateInputType = {
    id?: true
    symbol?: true
    label?: true
    _all?: true
  }

  export type BroadAncestryCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BroadAncestryCategory to aggregate.
     */
    where?: BroadAncestryCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BroadAncestryCategories to fetch.
     */
    orderBy?: BroadAncestryCategoryOrderByWithRelationInput | BroadAncestryCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BroadAncestryCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BroadAncestryCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BroadAncestryCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BroadAncestryCategories
    **/
    _count?: true | BroadAncestryCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BroadAncestryCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BroadAncestryCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BroadAncestryCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BroadAncestryCategoryMaxAggregateInputType
  }

  export type GetBroadAncestryCategoryAggregateType<T extends BroadAncestryCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBroadAncestryCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBroadAncestryCategory[P]>
      : GetScalarType<T[P], AggregateBroadAncestryCategory[P]>
  }




  export type BroadAncestryCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BroadAncestryCategoryWhereInput
    orderBy?: BroadAncestryCategoryOrderByWithAggregationInput | BroadAncestryCategoryOrderByWithAggregationInput[]
    by: BroadAncestryCategoryScalarFieldEnum[] | BroadAncestryCategoryScalarFieldEnum
    having?: BroadAncestryCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BroadAncestryCategoryCountAggregateInputType | true
    _avg?: BroadAncestryCategoryAvgAggregateInputType
    _sum?: BroadAncestryCategorySumAggregateInputType
    _min?: BroadAncestryCategoryMinAggregateInputType
    _max?: BroadAncestryCategoryMaxAggregateInputType
  }

  export type BroadAncestryCategoryGroupByOutputType = {
    id: number
    symbol: string
    label: string
    _count: BroadAncestryCategoryCountAggregateOutputType | null
    _avg: BroadAncestryCategoryAvgAggregateOutputType | null
    _sum: BroadAncestryCategorySumAggregateOutputType | null
    _min: BroadAncestryCategoryMinAggregateOutputType | null
    _max: BroadAncestryCategoryMaxAggregateOutputType | null
  }

  type GetBroadAncestryCategoryGroupByPayload<T extends BroadAncestryCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BroadAncestryCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BroadAncestryCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BroadAncestryCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], BroadAncestryCategoryGroupByOutputType[P]>
        }
      >
    >


  export type BroadAncestryCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    label?: boolean
    broadAncestryInModels?: boolean | BroadAncestryCategory$broadAncestryInModelsArgs<ExtArgs>
    broadAncestryInRefPops?: boolean | BroadAncestryCategory$broadAncestryInRefPopsArgs<ExtArgs>
    DevelopmentPopulationSamples?: boolean | BroadAncestryCategory$DevelopmentPopulationSamplesArgs<ExtArgs>
    EvaluationPopulationSamples?: boolean | BroadAncestryCategory$EvaluationPopulationSamplesArgs<ExtArgs>
    _count?: boolean | BroadAncestryCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["broadAncestryCategory"]>



  export type BroadAncestryCategorySelectScalar = {
    id?: boolean
    symbol?: boolean
    label?: boolean
  }

  export type BroadAncestryCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "symbol" | "label", ExtArgs["result"]["broadAncestryCategory"]>
  export type BroadAncestryCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    broadAncestryInModels?: boolean | BroadAncestryCategory$broadAncestryInModelsArgs<ExtArgs>
    broadAncestryInRefPops?: boolean | BroadAncestryCategory$broadAncestryInRefPopsArgs<ExtArgs>
    DevelopmentPopulationSamples?: boolean | BroadAncestryCategory$DevelopmentPopulationSamplesArgs<ExtArgs>
    EvaluationPopulationSamples?: boolean | BroadAncestryCategory$EvaluationPopulationSamplesArgs<ExtArgs>
    _count?: boolean | BroadAncestryCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BroadAncestryCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BroadAncestryCategory"
    objects: {
      broadAncestryInModels: Prisma.$BroadAncestryInModelPayload<ExtArgs>[]
      broadAncestryInRefPops: Prisma.$BroadAncestryInRefPopPayload<ExtArgs>[]
      DevelopmentPopulationSamples: Prisma.$DevelopmentPopulationSamplePayload<ExtArgs>[]
      EvaluationPopulationSamples: Prisma.$EvaluationPopulationSamplePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      symbol: string
      label: string
    }, ExtArgs["result"]["broadAncestryCategory"]>
    composites: {}
  }

  type BroadAncestryCategoryGetPayload<S extends boolean | null | undefined | BroadAncestryCategoryDefaultArgs> = $Result.GetResult<Prisma.$BroadAncestryCategoryPayload, S>

  type BroadAncestryCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BroadAncestryCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BroadAncestryCategoryCountAggregateInputType | true
    }

  export interface BroadAncestryCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BroadAncestryCategory'], meta: { name: 'BroadAncestryCategory' } }
    /**
     * Find zero or one BroadAncestryCategory that matches the filter.
     * @param {BroadAncestryCategoryFindUniqueArgs} args - Arguments to find a BroadAncestryCategory
     * @example
     * // Get one BroadAncestryCategory
     * const broadAncestryCategory = await prisma.broadAncestryCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BroadAncestryCategoryFindUniqueArgs>(args: SelectSubset<T, BroadAncestryCategoryFindUniqueArgs<ExtArgs>>): Prisma__BroadAncestryCategoryClient<$Result.GetResult<Prisma.$BroadAncestryCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BroadAncestryCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BroadAncestryCategoryFindUniqueOrThrowArgs} args - Arguments to find a BroadAncestryCategory
     * @example
     * // Get one BroadAncestryCategory
     * const broadAncestryCategory = await prisma.broadAncestryCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BroadAncestryCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, BroadAncestryCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BroadAncestryCategoryClient<$Result.GetResult<Prisma.$BroadAncestryCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BroadAncestryCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryCategoryFindFirstArgs} args - Arguments to find a BroadAncestryCategory
     * @example
     * // Get one BroadAncestryCategory
     * const broadAncestryCategory = await prisma.broadAncestryCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BroadAncestryCategoryFindFirstArgs>(args?: SelectSubset<T, BroadAncestryCategoryFindFirstArgs<ExtArgs>>): Prisma__BroadAncestryCategoryClient<$Result.GetResult<Prisma.$BroadAncestryCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BroadAncestryCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryCategoryFindFirstOrThrowArgs} args - Arguments to find a BroadAncestryCategory
     * @example
     * // Get one BroadAncestryCategory
     * const broadAncestryCategory = await prisma.broadAncestryCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BroadAncestryCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, BroadAncestryCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BroadAncestryCategoryClient<$Result.GetResult<Prisma.$BroadAncestryCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BroadAncestryCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BroadAncestryCategories
     * const broadAncestryCategories = await prisma.broadAncestryCategory.findMany()
     * 
     * // Get first 10 BroadAncestryCategories
     * const broadAncestryCategories = await prisma.broadAncestryCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const broadAncestryCategoryWithIdOnly = await prisma.broadAncestryCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BroadAncestryCategoryFindManyArgs>(args?: SelectSubset<T, BroadAncestryCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BroadAncestryCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BroadAncestryCategory.
     * @param {BroadAncestryCategoryCreateArgs} args - Arguments to create a BroadAncestryCategory.
     * @example
     * // Create one BroadAncestryCategory
     * const BroadAncestryCategory = await prisma.broadAncestryCategory.create({
     *   data: {
     *     // ... data to create a BroadAncestryCategory
     *   }
     * })
     * 
     */
    create<T extends BroadAncestryCategoryCreateArgs>(args: SelectSubset<T, BroadAncestryCategoryCreateArgs<ExtArgs>>): Prisma__BroadAncestryCategoryClient<$Result.GetResult<Prisma.$BroadAncestryCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BroadAncestryCategories.
     * @param {BroadAncestryCategoryCreateManyArgs} args - Arguments to create many BroadAncestryCategories.
     * @example
     * // Create many BroadAncestryCategories
     * const broadAncestryCategory = await prisma.broadAncestryCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BroadAncestryCategoryCreateManyArgs>(args?: SelectSubset<T, BroadAncestryCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BroadAncestryCategory.
     * @param {BroadAncestryCategoryDeleteArgs} args - Arguments to delete one BroadAncestryCategory.
     * @example
     * // Delete one BroadAncestryCategory
     * const BroadAncestryCategory = await prisma.broadAncestryCategory.delete({
     *   where: {
     *     // ... filter to delete one BroadAncestryCategory
     *   }
     * })
     * 
     */
    delete<T extends BroadAncestryCategoryDeleteArgs>(args: SelectSubset<T, BroadAncestryCategoryDeleteArgs<ExtArgs>>): Prisma__BroadAncestryCategoryClient<$Result.GetResult<Prisma.$BroadAncestryCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BroadAncestryCategory.
     * @param {BroadAncestryCategoryUpdateArgs} args - Arguments to update one BroadAncestryCategory.
     * @example
     * // Update one BroadAncestryCategory
     * const broadAncestryCategory = await prisma.broadAncestryCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BroadAncestryCategoryUpdateArgs>(args: SelectSubset<T, BroadAncestryCategoryUpdateArgs<ExtArgs>>): Prisma__BroadAncestryCategoryClient<$Result.GetResult<Prisma.$BroadAncestryCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BroadAncestryCategories.
     * @param {BroadAncestryCategoryDeleteManyArgs} args - Arguments to filter BroadAncestryCategories to delete.
     * @example
     * // Delete a few BroadAncestryCategories
     * const { count } = await prisma.broadAncestryCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BroadAncestryCategoryDeleteManyArgs>(args?: SelectSubset<T, BroadAncestryCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BroadAncestryCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BroadAncestryCategories
     * const broadAncestryCategory = await prisma.broadAncestryCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BroadAncestryCategoryUpdateManyArgs>(args: SelectSubset<T, BroadAncestryCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BroadAncestryCategory.
     * @param {BroadAncestryCategoryUpsertArgs} args - Arguments to update or create a BroadAncestryCategory.
     * @example
     * // Update or create a BroadAncestryCategory
     * const broadAncestryCategory = await prisma.broadAncestryCategory.upsert({
     *   create: {
     *     // ... data to create a BroadAncestryCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BroadAncestryCategory we want to update
     *   }
     * })
     */
    upsert<T extends BroadAncestryCategoryUpsertArgs>(args: SelectSubset<T, BroadAncestryCategoryUpsertArgs<ExtArgs>>): Prisma__BroadAncestryCategoryClient<$Result.GetResult<Prisma.$BroadAncestryCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BroadAncestryCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryCategoryCountArgs} args - Arguments to filter BroadAncestryCategories to count.
     * @example
     * // Count the number of BroadAncestryCategories
     * const count = await prisma.broadAncestryCategory.count({
     *   where: {
     *     // ... the filter for the BroadAncestryCategories we want to count
     *   }
     * })
    **/
    count<T extends BroadAncestryCategoryCountArgs>(
      args?: Subset<T, BroadAncestryCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BroadAncestryCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BroadAncestryCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BroadAncestryCategoryAggregateArgs>(args: Subset<T, BroadAncestryCategoryAggregateArgs>): Prisma.PrismaPromise<GetBroadAncestryCategoryAggregateType<T>>

    /**
     * Group by BroadAncestryCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BroadAncestryCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BroadAncestryCategoryGroupByArgs['orderBy'] }
        : { orderBy?: BroadAncestryCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BroadAncestryCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBroadAncestryCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BroadAncestryCategory model
   */
  readonly fields: BroadAncestryCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BroadAncestryCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BroadAncestryCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    broadAncestryInModels<T extends BroadAncestryCategory$broadAncestryInModelsArgs<ExtArgs> = {}>(args?: Subset<T, BroadAncestryCategory$broadAncestryInModelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BroadAncestryInModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    broadAncestryInRefPops<T extends BroadAncestryCategory$broadAncestryInRefPopsArgs<ExtArgs> = {}>(args?: Subset<T, BroadAncestryCategory$broadAncestryInRefPopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BroadAncestryInRefPopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DevelopmentPopulationSamples<T extends BroadAncestryCategory$DevelopmentPopulationSamplesArgs<ExtArgs> = {}>(args?: Subset<T, BroadAncestryCategory$DevelopmentPopulationSamplesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevelopmentPopulationSamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    EvaluationPopulationSamples<T extends BroadAncestryCategory$EvaluationPopulationSamplesArgs<ExtArgs> = {}>(args?: Subset<T, BroadAncestryCategory$EvaluationPopulationSamplesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPopulationSamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BroadAncestryCategory model
   */
  interface BroadAncestryCategoryFieldRefs {
    readonly id: FieldRef<"BroadAncestryCategory", 'Int'>
    readonly symbol: FieldRef<"BroadAncestryCategory", 'String'>
    readonly label: FieldRef<"BroadAncestryCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BroadAncestryCategory findUnique
   */
  export type BroadAncestryCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryCategory
     */
    select?: BroadAncestryCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryCategory
     */
    omit?: BroadAncestryCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BroadAncestryCategory to fetch.
     */
    where: BroadAncestryCategoryWhereUniqueInput
  }

  /**
   * BroadAncestryCategory findUniqueOrThrow
   */
  export type BroadAncestryCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryCategory
     */
    select?: BroadAncestryCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryCategory
     */
    omit?: BroadAncestryCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BroadAncestryCategory to fetch.
     */
    where: BroadAncestryCategoryWhereUniqueInput
  }

  /**
   * BroadAncestryCategory findFirst
   */
  export type BroadAncestryCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryCategory
     */
    select?: BroadAncestryCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryCategory
     */
    omit?: BroadAncestryCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BroadAncestryCategory to fetch.
     */
    where?: BroadAncestryCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BroadAncestryCategories to fetch.
     */
    orderBy?: BroadAncestryCategoryOrderByWithRelationInput | BroadAncestryCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BroadAncestryCategories.
     */
    cursor?: BroadAncestryCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BroadAncestryCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BroadAncestryCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BroadAncestryCategories.
     */
    distinct?: BroadAncestryCategoryScalarFieldEnum | BroadAncestryCategoryScalarFieldEnum[]
  }

  /**
   * BroadAncestryCategory findFirstOrThrow
   */
  export type BroadAncestryCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryCategory
     */
    select?: BroadAncestryCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryCategory
     */
    omit?: BroadAncestryCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BroadAncestryCategory to fetch.
     */
    where?: BroadAncestryCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BroadAncestryCategories to fetch.
     */
    orderBy?: BroadAncestryCategoryOrderByWithRelationInput | BroadAncestryCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BroadAncestryCategories.
     */
    cursor?: BroadAncestryCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BroadAncestryCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BroadAncestryCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BroadAncestryCategories.
     */
    distinct?: BroadAncestryCategoryScalarFieldEnum | BroadAncestryCategoryScalarFieldEnum[]
  }

  /**
   * BroadAncestryCategory findMany
   */
  export type BroadAncestryCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryCategory
     */
    select?: BroadAncestryCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryCategory
     */
    omit?: BroadAncestryCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BroadAncestryCategories to fetch.
     */
    where?: BroadAncestryCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BroadAncestryCategories to fetch.
     */
    orderBy?: BroadAncestryCategoryOrderByWithRelationInput | BroadAncestryCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BroadAncestryCategories.
     */
    cursor?: BroadAncestryCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BroadAncestryCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BroadAncestryCategories.
     */
    skip?: number
    distinct?: BroadAncestryCategoryScalarFieldEnum | BroadAncestryCategoryScalarFieldEnum[]
  }

  /**
   * BroadAncestryCategory create
   */
  export type BroadAncestryCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryCategory
     */
    select?: BroadAncestryCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryCategory
     */
    omit?: BroadAncestryCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a BroadAncestryCategory.
     */
    data: XOR<BroadAncestryCategoryCreateInput, BroadAncestryCategoryUncheckedCreateInput>
  }

  /**
   * BroadAncestryCategory createMany
   */
  export type BroadAncestryCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BroadAncestryCategories.
     */
    data: BroadAncestryCategoryCreateManyInput | BroadAncestryCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BroadAncestryCategory update
   */
  export type BroadAncestryCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryCategory
     */
    select?: BroadAncestryCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryCategory
     */
    omit?: BroadAncestryCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a BroadAncestryCategory.
     */
    data: XOR<BroadAncestryCategoryUpdateInput, BroadAncestryCategoryUncheckedUpdateInput>
    /**
     * Choose, which BroadAncestryCategory to update.
     */
    where: BroadAncestryCategoryWhereUniqueInput
  }

  /**
   * BroadAncestryCategory updateMany
   */
  export type BroadAncestryCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BroadAncestryCategories.
     */
    data: XOR<BroadAncestryCategoryUpdateManyMutationInput, BroadAncestryCategoryUncheckedUpdateManyInput>
    /**
     * Filter which BroadAncestryCategories to update
     */
    where?: BroadAncestryCategoryWhereInput
    /**
     * Limit how many BroadAncestryCategories to update.
     */
    limit?: number
  }

  /**
   * BroadAncestryCategory upsert
   */
  export type BroadAncestryCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryCategory
     */
    select?: BroadAncestryCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryCategory
     */
    omit?: BroadAncestryCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the BroadAncestryCategory to update in case it exists.
     */
    where: BroadAncestryCategoryWhereUniqueInput
    /**
     * In case the BroadAncestryCategory found by the `where` argument doesn't exist, create a new BroadAncestryCategory with this data.
     */
    create: XOR<BroadAncestryCategoryCreateInput, BroadAncestryCategoryUncheckedCreateInput>
    /**
     * In case the BroadAncestryCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BroadAncestryCategoryUpdateInput, BroadAncestryCategoryUncheckedUpdateInput>
  }

  /**
   * BroadAncestryCategory delete
   */
  export type BroadAncestryCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryCategory
     */
    select?: BroadAncestryCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryCategory
     */
    omit?: BroadAncestryCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryCategoryInclude<ExtArgs> | null
    /**
     * Filter which BroadAncestryCategory to delete.
     */
    where: BroadAncestryCategoryWhereUniqueInput
  }

  /**
   * BroadAncestryCategory deleteMany
   */
  export type BroadAncestryCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BroadAncestryCategories to delete
     */
    where?: BroadAncestryCategoryWhereInput
    /**
     * Limit how many BroadAncestryCategories to delete.
     */
    limit?: number
  }

  /**
   * BroadAncestryCategory.broadAncestryInModels
   */
  export type BroadAncestryCategory$broadAncestryInModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInModel
     */
    select?: BroadAncestryInModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInModel
     */
    omit?: BroadAncestryInModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInModelInclude<ExtArgs> | null
    where?: BroadAncestryInModelWhereInput
    orderBy?: BroadAncestryInModelOrderByWithRelationInput | BroadAncestryInModelOrderByWithRelationInput[]
    cursor?: BroadAncestryInModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BroadAncestryInModelScalarFieldEnum | BroadAncestryInModelScalarFieldEnum[]
  }

  /**
   * BroadAncestryCategory.broadAncestryInRefPops
   */
  export type BroadAncestryCategory$broadAncestryInRefPopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInRefPop
     */
    select?: BroadAncestryInRefPopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInRefPop
     */
    omit?: BroadAncestryInRefPopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInRefPopInclude<ExtArgs> | null
    where?: BroadAncestryInRefPopWhereInput
    orderBy?: BroadAncestryInRefPopOrderByWithRelationInput | BroadAncestryInRefPopOrderByWithRelationInput[]
    cursor?: BroadAncestryInRefPopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BroadAncestryInRefPopScalarFieldEnum | BroadAncestryInRefPopScalarFieldEnum[]
  }

  /**
   * BroadAncestryCategory.DevelopmentPopulationSamples
   */
  export type BroadAncestryCategory$DevelopmentPopulationSamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPopulationSample
     */
    select?: DevelopmentPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPopulationSample
     */
    omit?: DevelopmentPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevelopmentPopulationSampleInclude<ExtArgs> | null
    where?: DevelopmentPopulationSampleWhereInput
    orderBy?: DevelopmentPopulationSampleOrderByWithRelationInput | DevelopmentPopulationSampleOrderByWithRelationInput[]
    cursor?: DevelopmentPopulationSampleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DevelopmentPopulationSampleScalarFieldEnum | DevelopmentPopulationSampleScalarFieldEnum[]
  }

  /**
   * BroadAncestryCategory.EvaluationPopulationSamples
   */
  export type BroadAncestryCategory$EvaluationPopulationSamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPopulationSample
     */
    select?: EvaluationPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationPopulationSample
     */
    omit?: EvaluationPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationPopulationSampleInclude<ExtArgs> | null
    where?: EvaluationPopulationSampleWhereInput
    orderBy?: EvaluationPopulationSampleOrderByWithRelationInput | EvaluationPopulationSampleOrderByWithRelationInput[]
    cursor?: EvaluationPopulationSampleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationPopulationSampleScalarFieldEnum | EvaluationPopulationSampleScalarFieldEnum[]
  }

  /**
   * BroadAncestryCategory without action
   */
  export type BroadAncestryCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryCategory
     */
    select?: BroadAncestryCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryCategory
     */
    omit?: BroadAncestryCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryCategoryInclude<ExtArgs> | null
  }


  /**
   * Model BroadAncestryInModel
   */

  export type AggregateBroadAncestryInModel = {
    _count: BroadAncestryInModelCountAggregateOutputType | null
    _avg: BroadAncestryInModelAvgAggregateOutputType | null
    _sum: BroadAncestryInModelSumAggregateOutputType | null
    _min: BroadAncestryInModelMinAggregateOutputType | null
    _max: BroadAncestryInModelMaxAggregateOutputType | null
  }

  export type BroadAncestryInModelAvgAggregateOutputType = {
    percentage: number | null
    broadAncestryId: number | null
    prsModelId: number | null
  }

  export type BroadAncestryInModelSumAggregateOutputType = {
    percentage: number | null
    broadAncestryId: number | null
    prsModelId: number | null
  }

  export type BroadAncestryInModelMinAggregateOutputType = {
    percentage: number | null
    broadAncestryId: number | null
    prsModelId: number | null
  }

  export type BroadAncestryInModelMaxAggregateOutputType = {
    percentage: number | null
    broadAncestryId: number | null
    prsModelId: number | null
  }

  export type BroadAncestryInModelCountAggregateOutputType = {
    percentage: number
    broadAncestryId: number
    prsModelId: number
    _all: number
  }


  export type BroadAncestryInModelAvgAggregateInputType = {
    percentage?: true
    broadAncestryId?: true
    prsModelId?: true
  }

  export type BroadAncestryInModelSumAggregateInputType = {
    percentage?: true
    broadAncestryId?: true
    prsModelId?: true
  }

  export type BroadAncestryInModelMinAggregateInputType = {
    percentage?: true
    broadAncestryId?: true
    prsModelId?: true
  }

  export type BroadAncestryInModelMaxAggregateInputType = {
    percentage?: true
    broadAncestryId?: true
    prsModelId?: true
  }

  export type BroadAncestryInModelCountAggregateInputType = {
    percentage?: true
    broadAncestryId?: true
    prsModelId?: true
    _all?: true
  }

  export type BroadAncestryInModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BroadAncestryInModel to aggregate.
     */
    where?: BroadAncestryInModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BroadAncestryInModels to fetch.
     */
    orderBy?: BroadAncestryInModelOrderByWithRelationInput | BroadAncestryInModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BroadAncestryInModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BroadAncestryInModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BroadAncestryInModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BroadAncestryInModels
    **/
    _count?: true | BroadAncestryInModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BroadAncestryInModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BroadAncestryInModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BroadAncestryInModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BroadAncestryInModelMaxAggregateInputType
  }

  export type GetBroadAncestryInModelAggregateType<T extends BroadAncestryInModelAggregateArgs> = {
        [P in keyof T & keyof AggregateBroadAncestryInModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBroadAncestryInModel[P]>
      : GetScalarType<T[P], AggregateBroadAncestryInModel[P]>
  }




  export type BroadAncestryInModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BroadAncestryInModelWhereInput
    orderBy?: BroadAncestryInModelOrderByWithAggregationInput | BroadAncestryInModelOrderByWithAggregationInput[]
    by: BroadAncestryInModelScalarFieldEnum[] | BroadAncestryInModelScalarFieldEnum
    having?: BroadAncestryInModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BroadAncestryInModelCountAggregateInputType | true
    _avg?: BroadAncestryInModelAvgAggregateInputType
    _sum?: BroadAncestryInModelSumAggregateInputType
    _min?: BroadAncestryInModelMinAggregateInputType
    _max?: BroadAncestryInModelMaxAggregateInputType
  }

  export type BroadAncestryInModelGroupByOutputType = {
    percentage: number
    broadAncestryId: number
    prsModelId: number
    _count: BroadAncestryInModelCountAggregateOutputType | null
    _avg: BroadAncestryInModelAvgAggregateOutputType | null
    _sum: BroadAncestryInModelSumAggregateOutputType | null
    _min: BroadAncestryInModelMinAggregateOutputType | null
    _max: BroadAncestryInModelMaxAggregateOutputType | null
  }

  type GetBroadAncestryInModelGroupByPayload<T extends BroadAncestryInModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BroadAncestryInModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BroadAncestryInModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BroadAncestryInModelGroupByOutputType[P]>
            : GetScalarType<T[P], BroadAncestryInModelGroupByOutputType[P]>
        }
      >
    >


  export type BroadAncestryInModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    percentage?: boolean
    broadAncestryId?: boolean
    prsModelId?: boolean
    broadAncestryCategory?: boolean | BroadAncestryCategoryDefaultArgs<ExtArgs>
    prsModel?: boolean | PRSModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["broadAncestryInModel"]>



  export type BroadAncestryInModelSelectScalar = {
    percentage?: boolean
    broadAncestryId?: boolean
    prsModelId?: boolean
  }

  export type BroadAncestryInModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"percentage" | "broadAncestryId" | "prsModelId", ExtArgs["result"]["broadAncestryInModel"]>
  export type BroadAncestryInModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    broadAncestryCategory?: boolean | BroadAncestryCategoryDefaultArgs<ExtArgs>
    prsModel?: boolean | PRSModelDefaultArgs<ExtArgs>
  }

  export type $BroadAncestryInModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BroadAncestryInModel"
    objects: {
      broadAncestryCategory: Prisma.$BroadAncestryCategoryPayload<ExtArgs>
      prsModel: Prisma.$PRSModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      percentage: number
      broadAncestryId: number
      prsModelId: number
    }, ExtArgs["result"]["broadAncestryInModel"]>
    composites: {}
  }

  type BroadAncestryInModelGetPayload<S extends boolean | null | undefined | BroadAncestryInModelDefaultArgs> = $Result.GetResult<Prisma.$BroadAncestryInModelPayload, S>

  type BroadAncestryInModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BroadAncestryInModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BroadAncestryInModelCountAggregateInputType | true
    }

  export interface BroadAncestryInModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BroadAncestryInModel'], meta: { name: 'BroadAncestryInModel' } }
    /**
     * Find zero or one BroadAncestryInModel that matches the filter.
     * @param {BroadAncestryInModelFindUniqueArgs} args - Arguments to find a BroadAncestryInModel
     * @example
     * // Get one BroadAncestryInModel
     * const broadAncestryInModel = await prisma.broadAncestryInModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BroadAncestryInModelFindUniqueArgs>(args: SelectSubset<T, BroadAncestryInModelFindUniqueArgs<ExtArgs>>): Prisma__BroadAncestryInModelClient<$Result.GetResult<Prisma.$BroadAncestryInModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BroadAncestryInModel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BroadAncestryInModelFindUniqueOrThrowArgs} args - Arguments to find a BroadAncestryInModel
     * @example
     * // Get one BroadAncestryInModel
     * const broadAncestryInModel = await prisma.broadAncestryInModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BroadAncestryInModelFindUniqueOrThrowArgs>(args: SelectSubset<T, BroadAncestryInModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BroadAncestryInModelClient<$Result.GetResult<Prisma.$BroadAncestryInModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BroadAncestryInModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryInModelFindFirstArgs} args - Arguments to find a BroadAncestryInModel
     * @example
     * // Get one BroadAncestryInModel
     * const broadAncestryInModel = await prisma.broadAncestryInModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BroadAncestryInModelFindFirstArgs>(args?: SelectSubset<T, BroadAncestryInModelFindFirstArgs<ExtArgs>>): Prisma__BroadAncestryInModelClient<$Result.GetResult<Prisma.$BroadAncestryInModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BroadAncestryInModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryInModelFindFirstOrThrowArgs} args - Arguments to find a BroadAncestryInModel
     * @example
     * // Get one BroadAncestryInModel
     * const broadAncestryInModel = await prisma.broadAncestryInModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BroadAncestryInModelFindFirstOrThrowArgs>(args?: SelectSubset<T, BroadAncestryInModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__BroadAncestryInModelClient<$Result.GetResult<Prisma.$BroadAncestryInModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BroadAncestryInModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryInModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BroadAncestryInModels
     * const broadAncestryInModels = await prisma.broadAncestryInModel.findMany()
     * 
     * // Get first 10 BroadAncestryInModels
     * const broadAncestryInModels = await prisma.broadAncestryInModel.findMany({ take: 10 })
     * 
     * // Only select the `percentage`
     * const broadAncestryInModelWithPercentageOnly = await prisma.broadAncestryInModel.findMany({ select: { percentage: true } })
     * 
     */
    findMany<T extends BroadAncestryInModelFindManyArgs>(args?: SelectSubset<T, BroadAncestryInModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BroadAncestryInModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BroadAncestryInModel.
     * @param {BroadAncestryInModelCreateArgs} args - Arguments to create a BroadAncestryInModel.
     * @example
     * // Create one BroadAncestryInModel
     * const BroadAncestryInModel = await prisma.broadAncestryInModel.create({
     *   data: {
     *     // ... data to create a BroadAncestryInModel
     *   }
     * })
     * 
     */
    create<T extends BroadAncestryInModelCreateArgs>(args: SelectSubset<T, BroadAncestryInModelCreateArgs<ExtArgs>>): Prisma__BroadAncestryInModelClient<$Result.GetResult<Prisma.$BroadAncestryInModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BroadAncestryInModels.
     * @param {BroadAncestryInModelCreateManyArgs} args - Arguments to create many BroadAncestryInModels.
     * @example
     * // Create many BroadAncestryInModels
     * const broadAncestryInModel = await prisma.broadAncestryInModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BroadAncestryInModelCreateManyArgs>(args?: SelectSubset<T, BroadAncestryInModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BroadAncestryInModel.
     * @param {BroadAncestryInModelDeleteArgs} args - Arguments to delete one BroadAncestryInModel.
     * @example
     * // Delete one BroadAncestryInModel
     * const BroadAncestryInModel = await prisma.broadAncestryInModel.delete({
     *   where: {
     *     // ... filter to delete one BroadAncestryInModel
     *   }
     * })
     * 
     */
    delete<T extends BroadAncestryInModelDeleteArgs>(args: SelectSubset<T, BroadAncestryInModelDeleteArgs<ExtArgs>>): Prisma__BroadAncestryInModelClient<$Result.GetResult<Prisma.$BroadAncestryInModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BroadAncestryInModel.
     * @param {BroadAncestryInModelUpdateArgs} args - Arguments to update one BroadAncestryInModel.
     * @example
     * // Update one BroadAncestryInModel
     * const broadAncestryInModel = await prisma.broadAncestryInModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BroadAncestryInModelUpdateArgs>(args: SelectSubset<T, BroadAncestryInModelUpdateArgs<ExtArgs>>): Prisma__BroadAncestryInModelClient<$Result.GetResult<Prisma.$BroadAncestryInModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BroadAncestryInModels.
     * @param {BroadAncestryInModelDeleteManyArgs} args - Arguments to filter BroadAncestryInModels to delete.
     * @example
     * // Delete a few BroadAncestryInModels
     * const { count } = await prisma.broadAncestryInModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BroadAncestryInModelDeleteManyArgs>(args?: SelectSubset<T, BroadAncestryInModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BroadAncestryInModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryInModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BroadAncestryInModels
     * const broadAncestryInModel = await prisma.broadAncestryInModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BroadAncestryInModelUpdateManyArgs>(args: SelectSubset<T, BroadAncestryInModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BroadAncestryInModel.
     * @param {BroadAncestryInModelUpsertArgs} args - Arguments to update or create a BroadAncestryInModel.
     * @example
     * // Update or create a BroadAncestryInModel
     * const broadAncestryInModel = await prisma.broadAncestryInModel.upsert({
     *   create: {
     *     // ... data to create a BroadAncestryInModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BroadAncestryInModel we want to update
     *   }
     * })
     */
    upsert<T extends BroadAncestryInModelUpsertArgs>(args: SelectSubset<T, BroadAncestryInModelUpsertArgs<ExtArgs>>): Prisma__BroadAncestryInModelClient<$Result.GetResult<Prisma.$BroadAncestryInModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BroadAncestryInModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryInModelCountArgs} args - Arguments to filter BroadAncestryInModels to count.
     * @example
     * // Count the number of BroadAncestryInModels
     * const count = await prisma.broadAncestryInModel.count({
     *   where: {
     *     // ... the filter for the BroadAncestryInModels we want to count
     *   }
     * })
    **/
    count<T extends BroadAncestryInModelCountArgs>(
      args?: Subset<T, BroadAncestryInModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BroadAncestryInModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BroadAncestryInModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryInModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BroadAncestryInModelAggregateArgs>(args: Subset<T, BroadAncestryInModelAggregateArgs>): Prisma.PrismaPromise<GetBroadAncestryInModelAggregateType<T>>

    /**
     * Group by BroadAncestryInModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryInModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BroadAncestryInModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BroadAncestryInModelGroupByArgs['orderBy'] }
        : { orderBy?: BroadAncestryInModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BroadAncestryInModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBroadAncestryInModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BroadAncestryInModel model
   */
  readonly fields: BroadAncestryInModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BroadAncestryInModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BroadAncestryInModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    broadAncestryCategory<T extends BroadAncestryCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BroadAncestryCategoryDefaultArgs<ExtArgs>>): Prisma__BroadAncestryCategoryClient<$Result.GetResult<Prisma.$BroadAncestryCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prsModel<T extends PRSModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PRSModelDefaultArgs<ExtArgs>>): Prisma__PRSModelClient<$Result.GetResult<Prisma.$PRSModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BroadAncestryInModel model
   */
  interface BroadAncestryInModelFieldRefs {
    readonly percentage: FieldRef<"BroadAncestryInModel", 'Float'>
    readonly broadAncestryId: FieldRef<"BroadAncestryInModel", 'Int'>
    readonly prsModelId: FieldRef<"BroadAncestryInModel", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BroadAncestryInModel findUnique
   */
  export type BroadAncestryInModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInModel
     */
    select?: BroadAncestryInModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInModel
     */
    omit?: BroadAncestryInModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInModelInclude<ExtArgs> | null
    /**
     * Filter, which BroadAncestryInModel to fetch.
     */
    where: BroadAncestryInModelWhereUniqueInput
  }

  /**
   * BroadAncestryInModel findUniqueOrThrow
   */
  export type BroadAncestryInModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInModel
     */
    select?: BroadAncestryInModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInModel
     */
    omit?: BroadAncestryInModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInModelInclude<ExtArgs> | null
    /**
     * Filter, which BroadAncestryInModel to fetch.
     */
    where: BroadAncestryInModelWhereUniqueInput
  }

  /**
   * BroadAncestryInModel findFirst
   */
  export type BroadAncestryInModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInModel
     */
    select?: BroadAncestryInModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInModel
     */
    omit?: BroadAncestryInModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInModelInclude<ExtArgs> | null
    /**
     * Filter, which BroadAncestryInModel to fetch.
     */
    where?: BroadAncestryInModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BroadAncestryInModels to fetch.
     */
    orderBy?: BroadAncestryInModelOrderByWithRelationInput | BroadAncestryInModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BroadAncestryInModels.
     */
    cursor?: BroadAncestryInModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BroadAncestryInModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BroadAncestryInModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BroadAncestryInModels.
     */
    distinct?: BroadAncestryInModelScalarFieldEnum | BroadAncestryInModelScalarFieldEnum[]
  }

  /**
   * BroadAncestryInModel findFirstOrThrow
   */
  export type BroadAncestryInModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInModel
     */
    select?: BroadAncestryInModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInModel
     */
    omit?: BroadAncestryInModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInModelInclude<ExtArgs> | null
    /**
     * Filter, which BroadAncestryInModel to fetch.
     */
    where?: BroadAncestryInModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BroadAncestryInModels to fetch.
     */
    orderBy?: BroadAncestryInModelOrderByWithRelationInput | BroadAncestryInModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BroadAncestryInModels.
     */
    cursor?: BroadAncestryInModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BroadAncestryInModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BroadAncestryInModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BroadAncestryInModels.
     */
    distinct?: BroadAncestryInModelScalarFieldEnum | BroadAncestryInModelScalarFieldEnum[]
  }

  /**
   * BroadAncestryInModel findMany
   */
  export type BroadAncestryInModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInModel
     */
    select?: BroadAncestryInModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInModel
     */
    omit?: BroadAncestryInModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInModelInclude<ExtArgs> | null
    /**
     * Filter, which BroadAncestryInModels to fetch.
     */
    where?: BroadAncestryInModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BroadAncestryInModels to fetch.
     */
    orderBy?: BroadAncestryInModelOrderByWithRelationInput | BroadAncestryInModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BroadAncestryInModels.
     */
    cursor?: BroadAncestryInModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BroadAncestryInModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BroadAncestryInModels.
     */
    skip?: number
    distinct?: BroadAncestryInModelScalarFieldEnum | BroadAncestryInModelScalarFieldEnum[]
  }

  /**
   * BroadAncestryInModel create
   */
  export type BroadAncestryInModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInModel
     */
    select?: BroadAncestryInModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInModel
     */
    omit?: BroadAncestryInModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInModelInclude<ExtArgs> | null
    /**
     * The data needed to create a BroadAncestryInModel.
     */
    data: XOR<BroadAncestryInModelCreateInput, BroadAncestryInModelUncheckedCreateInput>
  }

  /**
   * BroadAncestryInModel createMany
   */
  export type BroadAncestryInModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BroadAncestryInModels.
     */
    data: BroadAncestryInModelCreateManyInput | BroadAncestryInModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BroadAncestryInModel update
   */
  export type BroadAncestryInModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInModel
     */
    select?: BroadAncestryInModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInModel
     */
    omit?: BroadAncestryInModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInModelInclude<ExtArgs> | null
    /**
     * The data needed to update a BroadAncestryInModel.
     */
    data: XOR<BroadAncestryInModelUpdateInput, BroadAncestryInModelUncheckedUpdateInput>
    /**
     * Choose, which BroadAncestryInModel to update.
     */
    where: BroadAncestryInModelWhereUniqueInput
  }

  /**
   * BroadAncestryInModel updateMany
   */
  export type BroadAncestryInModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BroadAncestryInModels.
     */
    data: XOR<BroadAncestryInModelUpdateManyMutationInput, BroadAncestryInModelUncheckedUpdateManyInput>
    /**
     * Filter which BroadAncestryInModels to update
     */
    where?: BroadAncestryInModelWhereInput
    /**
     * Limit how many BroadAncestryInModels to update.
     */
    limit?: number
  }

  /**
   * BroadAncestryInModel upsert
   */
  export type BroadAncestryInModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInModel
     */
    select?: BroadAncestryInModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInModel
     */
    omit?: BroadAncestryInModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInModelInclude<ExtArgs> | null
    /**
     * The filter to search for the BroadAncestryInModel to update in case it exists.
     */
    where: BroadAncestryInModelWhereUniqueInput
    /**
     * In case the BroadAncestryInModel found by the `where` argument doesn't exist, create a new BroadAncestryInModel with this data.
     */
    create: XOR<BroadAncestryInModelCreateInput, BroadAncestryInModelUncheckedCreateInput>
    /**
     * In case the BroadAncestryInModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BroadAncestryInModelUpdateInput, BroadAncestryInModelUncheckedUpdateInput>
  }

  /**
   * BroadAncestryInModel delete
   */
  export type BroadAncestryInModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInModel
     */
    select?: BroadAncestryInModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInModel
     */
    omit?: BroadAncestryInModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInModelInclude<ExtArgs> | null
    /**
     * Filter which BroadAncestryInModel to delete.
     */
    where: BroadAncestryInModelWhereUniqueInput
  }

  /**
   * BroadAncestryInModel deleteMany
   */
  export type BroadAncestryInModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BroadAncestryInModels to delete
     */
    where?: BroadAncestryInModelWhereInput
    /**
     * Limit how many BroadAncestryInModels to delete.
     */
    limit?: number
  }

  /**
   * BroadAncestryInModel without action
   */
  export type BroadAncestryInModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInModel
     */
    select?: BroadAncestryInModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInModel
     */
    omit?: BroadAncestryInModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInModelInclude<ExtArgs> | null
  }


  /**
   * Model DevelopmentPopulationSample
   */

  export type AggregateDevelopmentPopulationSample = {
    _count: DevelopmentPopulationSampleCountAggregateOutputType | null
    _avg: DevelopmentPopulationSampleAvgAggregateOutputType | null
    _sum: DevelopmentPopulationSampleSumAggregateOutputType | null
    _min: DevelopmentPopulationSampleMinAggregateOutputType | null
    _max: DevelopmentPopulationSampleMaxAggregateOutputType | null
  }

  export type DevelopmentPopulationSampleAvgAggregateOutputType = {
    id: number | null
    numberOfIndividuals: number | null
    numberOfCases: number | null
    numberOfControls: number | null
    percentMale: number | null
    age: number | null
    prsModelId: number | null
    broadAncestryId: number | null
  }

  export type DevelopmentPopulationSampleSumAggregateOutputType = {
    id: number | null
    numberOfIndividuals: number | null
    numberOfCases: number | null
    numberOfControls: number | null
    percentMale: number | null
    age: number | null
    prsModelId: number | null
    broadAncestryId: number | null
  }

  export type DevelopmentPopulationSampleMinAggregateOutputType = {
    id: number | null
    numberOfIndividuals: number | null
    numberOfCases: number | null
    numberOfControls: number | null
    percentMale: number | null
    age: number | null
    ageUnits: string | null
    ancestryBroad: string | null
    ancestryDetails: string | null
    cohort: string | null
    gcId: string | null
    sourcePMID: string | null
    sourceDOI: string | null
    role: $Enums.DevelopmentRoleType | null
    prsModelId: number | null
    broadAncestryId: number | null
  }

  export type DevelopmentPopulationSampleMaxAggregateOutputType = {
    id: number | null
    numberOfIndividuals: number | null
    numberOfCases: number | null
    numberOfControls: number | null
    percentMale: number | null
    age: number | null
    ageUnits: string | null
    ancestryBroad: string | null
    ancestryDetails: string | null
    cohort: string | null
    gcId: string | null
    sourcePMID: string | null
    sourceDOI: string | null
    role: $Enums.DevelopmentRoleType | null
    prsModelId: number | null
    broadAncestryId: number | null
  }

  export type DevelopmentPopulationSampleCountAggregateOutputType = {
    id: number
    numberOfIndividuals: number
    numberOfCases: number
    numberOfControls: number
    percentMale: number
    age: number
    ageUnits: number
    ancestryBroad: number
    ancestryDetails: number
    cohort: number
    gcId: number
    sourcePMID: number
    sourceDOI: number
    role: number
    prsModelId: number
    broadAncestryId: number
    _all: number
  }


  export type DevelopmentPopulationSampleAvgAggregateInputType = {
    id?: true
    numberOfIndividuals?: true
    numberOfCases?: true
    numberOfControls?: true
    percentMale?: true
    age?: true
    prsModelId?: true
    broadAncestryId?: true
  }

  export type DevelopmentPopulationSampleSumAggregateInputType = {
    id?: true
    numberOfIndividuals?: true
    numberOfCases?: true
    numberOfControls?: true
    percentMale?: true
    age?: true
    prsModelId?: true
    broadAncestryId?: true
  }

  export type DevelopmentPopulationSampleMinAggregateInputType = {
    id?: true
    numberOfIndividuals?: true
    numberOfCases?: true
    numberOfControls?: true
    percentMale?: true
    age?: true
    ageUnits?: true
    ancestryBroad?: true
    ancestryDetails?: true
    cohort?: true
    gcId?: true
    sourcePMID?: true
    sourceDOI?: true
    role?: true
    prsModelId?: true
    broadAncestryId?: true
  }

  export type DevelopmentPopulationSampleMaxAggregateInputType = {
    id?: true
    numberOfIndividuals?: true
    numberOfCases?: true
    numberOfControls?: true
    percentMale?: true
    age?: true
    ageUnits?: true
    ancestryBroad?: true
    ancestryDetails?: true
    cohort?: true
    gcId?: true
    sourcePMID?: true
    sourceDOI?: true
    role?: true
    prsModelId?: true
    broadAncestryId?: true
  }

  export type DevelopmentPopulationSampleCountAggregateInputType = {
    id?: true
    numberOfIndividuals?: true
    numberOfCases?: true
    numberOfControls?: true
    percentMale?: true
    age?: true
    ageUnits?: true
    ancestryBroad?: true
    ancestryDetails?: true
    cohort?: true
    gcId?: true
    sourcePMID?: true
    sourceDOI?: true
    role?: true
    prsModelId?: true
    broadAncestryId?: true
    _all?: true
  }

  export type DevelopmentPopulationSampleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DevelopmentPopulationSample to aggregate.
     */
    where?: DevelopmentPopulationSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DevelopmentPopulationSamples to fetch.
     */
    orderBy?: DevelopmentPopulationSampleOrderByWithRelationInput | DevelopmentPopulationSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DevelopmentPopulationSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DevelopmentPopulationSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DevelopmentPopulationSamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DevelopmentPopulationSamples
    **/
    _count?: true | DevelopmentPopulationSampleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DevelopmentPopulationSampleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DevelopmentPopulationSampleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DevelopmentPopulationSampleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DevelopmentPopulationSampleMaxAggregateInputType
  }

  export type GetDevelopmentPopulationSampleAggregateType<T extends DevelopmentPopulationSampleAggregateArgs> = {
        [P in keyof T & keyof AggregateDevelopmentPopulationSample]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevelopmentPopulationSample[P]>
      : GetScalarType<T[P], AggregateDevelopmentPopulationSample[P]>
  }




  export type DevelopmentPopulationSampleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DevelopmentPopulationSampleWhereInput
    orderBy?: DevelopmentPopulationSampleOrderByWithAggregationInput | DevelopmentPopulationSampleOrderByWithAggregationInput[]
    by: DevelopmentPopulationSampleScalarFieldEnum[] | DevelopmentPopulationSampleScalarFieldEnum
    having?: DevelopmentPopulationSampleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DevelopmentPopulationSampleCountAggregateInputType | true
    _avg?: DevelopmentPopulationSampleAvgAggregateInputType
    _sum?: DevelopmentPopulationSampleSumAggregateInputType
    _min?: DevelopmentPopulationSampleMinAggregateInputType
    _max?: DevelopmentPopulationSampleMaxAggregateInputType
  }

  export type DevelopmentPopulationSampleGroupByOutputType = {
    id: number
    numberOfIndividuals: number | null
    numberOfCases: number | null
    numberOfControls: number | null
    percentMale: number | null
    age: number | null
    ageUnits: string | null
    ancestryBroad: string
    ancestryDetails: string | null
    cohort: string
    gcId: string | null
    sourcePMID: string | null
    sourceDOI: string | null
    role: $Enums.DevelopmentRoleType
    prsModelId: number
    broadAncestryId: number
    _count: DevelopmentPopulationSampleCountAggregateOutputType | null
    _avg: DevelopmentPopulationSampleAvgAggregateOutputType | null
    _sum: DevelopmentPopulationSampleSumAggregateOutputType | null
    _min: DevelopmentPopulationSampleMinAggregateOutputType | null
    _max: DevelopmentPopulationSampleMaxAggregateOutputType | null
  }

  type GetDevelopmentPopulationSampleGroupByPayload<T extends DevelopmentPopulationSampleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DevelopmentPopulationSampleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DevelopmentPopulationSampleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DevelopmentPopulationSampleGroupByOutputType[P]>
            : GetScalarType<T[P], DevelopmentPopulationSampleGroupByOutputType[P]>
        }
      >
    >


  export type DevelopmentPopulationSampleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numberOfIndividuals?: boolean
    numberOfCases?: boolean
    numberOfControls?: boolean
    percentMale?: boolean
    age?: boolean
    ageUnits?: boolean
    ancestryBroad?: boolean
    ancestryDetails?: boolean
    cohort?: boolean
    gcId?: boolean
    sourcePMID?: boolean
    sourceDOI?: boolean
    role?: boolean
    prsModelId?: boolean
    broadAncestryId?: boolean
    broadAncestryCategory?: boolean | BroadAncestryCategoryDefaultArgs<ExtArgs>
    prsModel?: boolean | PRSModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["developmentPopulationSample"]>



  export type DevelopmentPopulationSampleSelectScalar = {
    id?: boolean
    numberOfIndividuals?: boolean
    numberOfCases?: boolean
    numberOfControls?: boolean
    percentMale?: boolean
    age?: boolean
    ageUnits?: boolean
    ancestryBroad?: boolean
    ancestryDetails?: boolean
    cohort?: boolean
    gcId?: boolean
    sourcePMID?: boolean
    sourceDOI?: boolean
    role?: boolean
    prsModelId?: boolean
    broadAncestryId?: boolean
  }

  export type DevelopmentPopulationSampleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "numberOfIndividuals" | "numberOfCases" | "numberOfControls" | "percentMale" | "age" | "ageUnits" | "ancestryBroad" | "ancestryDetails" | "cohort" | "gcId" | "sourcePMID" | "sourceDOI" | "role" | "prsModelId" | "broadAncestryId", ExtArgs["result"]["developmentPopulationSample"]>
  export type DevelopmentPopulationSampleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    broadAncestryCategory?: boolean | BroadAncestryCategoryDefaultArgs<ExtArgs>
    prsModel?: boolean | PRSModelDefaultArgs<ExtArgs>
  }

  export type $DevelopmentPopulationSamplePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DevelopmentPopulationSample"
    objects: {
      broadAncestryCategory: Prisma.$BroadAncestryCategoryPayload<ExtArgs>
      prsModel: Prisma.$PRSModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      numberOfIndividuals: number | null
      numberOfCases: number | null
      numberOfControls: number | null
      percentMale: number | null
      age: number | null
      ageUnits: string | null
      ancestryBroad: string
      ancestryDetails: string | null
      cohort: string
      gcId: string | null
      sourcePMID: string | null
      sourceDOI: string | null
      role: $Enums.DevelopmentRoleType
      prsModelId: number
      broadAncestryId: number
    }, ExtArgs["result"]["developmentPopulationSample"]>
    composites: {}
  }

  type DevelopmentPopulationSampleGetPayload<S extends boolean | null | undefined | DevelopmentPopulationSampleDefaultArgs> = $Result.GetResult<Prisma.$DevelopmentPopulationSamplePayload, S>

  type DevelopmentPopulationSampleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DevelopmentPopulationSampleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DevelopmentPopulationSampleCountAggregateInputType | true
    }

  export interface DevelopmentPopulationSampleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DevelopmentPopulationSample'], meta: { name: 'DevelopmentPopulationSample' } }
    /**
     * Find zero or one DevelopmentPopulationSample that matches the filter.
     * @param {DevelopmentPopulationSampleFindUniqueArgs} args - Arguments to find a DevelopmentPopulationSample
     * @example
     * // Get one DevelopmentPopulationSample
     * const developmentPopulationSample = await prisma.developmentPopulationSample.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DevelopmentPopulationSampleFindUniqueArgs>(args: SelectSubset<T, DevelopmentPopulationSampleFindUniqueArgs<ExtArgs>>): Prisma__DevelopmentPopulationSampleClient<$Result.GetResult<Prisma.$DevelopmentPopulationSamplePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DevelopmentPopulationSample that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DevelopmentPopulationSampleFindUniqueOrThrowArgs} args - Arguments to find a DevelopmentPopulationSample
     * @example
     * // Get one DevelopmentPopulationSample
     * const developmentPopulationSample = await prisma.developmentPopulationSample.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DevelopmentPopulationSampleFindUniqueOrThrowArgs>(args: SelectSubset<T, DevelopmentPopulationSampleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DevelopmentPopulationSampleClient<$Result.GetResult<Prisma.$DevelopmentPopulationSamplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DevelopmentPopulationSample that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevelopmentPopulationSampleFindFirstArgs} args - Arguments to find a DevelopmentPopulationSample
     * @example
     * // Get one DevelopmentPopulationSample
     * const developmentPopulationSample = await prisma.developmentPopulationSample.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DevelopmentPopulationSampleFindFirstArgs>(args?: SelectSubset<T, DevelopmentPopulationSampleFindFirstArgs<ExtArgs>>): Prisma__DevelopmentPopulationSampleClient<$Result.GetResult<Prisma.$DevelopmentPopulationSamplePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DevelopmentPopulationSample that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevelopmentPopulationSampleFindFirstOrThrowArgs} args - Arguments to find a DevelopmentPopulationSample
     * @example
     * // Get one DevelopmentPopulationSample
     * const developmentPopulationSample = await prisma.developmentPopulationSample.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DevelopmentPopulationSampleFindFirstOrThrowArgs>(args?: SelectSubset<T, DevelopmentPopulationSampleFindFirstOrThrowArgs<ExtArgs>>): Prisma__DevelopmentPopulationSampleClient<$Result.GetResult<Prisma.$DevelopmentPopulationSamplePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DevelopmentPopulationSamples that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevelopmentPopulationSampleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DevelopmentPopulationSamples
     * const developmentPopulationSamples = await prisma.developmentPopulationSample.findMany()
     * 
     * // Get first 10 DevelopmentPopulationSamples
     * const developmentPopulationSamples = await prisma.developmentPopulationSample.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const developmentPopulationSampleWithIdOnly = await prisma.developmentPopulationSample.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DevelopmentPopulationSampleFindManyArgs>(args?: SelectSubset<T, DevelopmentPopulationSampleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevelopmentPopulationSamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DevelopmentPopulationSample.
     * @param {DevelopmentPopulationSampleCreateArgs} args - Arguments to create a DevelopmentPopulationSample.
     * @example
     * // Create one DevelopmentPopulationSample
     * const DevelopmentPopulationSample = await prisma.developmentPopulationSample.create({
     *   data: {
     *     // ... data to create a DevelopmentPopulationSample
     *   }
     * })
     * 
     */
    create<T extends DevelopmentPopulationSampleCreateArgs>(args: SelectSubset<T, DevelopmentPopulationSampleCreateArgs<ExtArgs>>): Prisma__DevelopmentPopulationSampleClient<$Result.GetResult<Prisma.$DevelopmentPopulationSamplePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DevelopmentPopulationSamples.
     * @param {DevelopmentPopulationSampleCreateManyArgs} args - Arguments to create many DevelopmentPopulationSamples.
     * @example
     * // Create many DevelopmentPopulationSamples
     * const developmentPopulationSample = await prisma.developmentPopulationSample.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DevelopmentPopulationSampleCreateManyArgs>(args?: SelectSubset<T, DevelopmentPopulationSampleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DevelopmentPopulationSample.
     * @param {DevelopmentPopulationSampleDeleteArgs} args - Arguments to delete one DevelopmentPopulationSample.
     * @example
     * // Delete one DevelopmentPopulationSample
     * const DevelopmentPopulationSample = await prisma.developmentPopulationSample.delete({
     *   where: {
     *     // ... filter to delete one DevelopmentPopulationSample
     *   }
     * })
     * 
     */
    delete<T extends DevelopmentPopulationSampleDeleteArgs>(args: SelectSubset<T, DevelopmentPopulationSampleDeleteArgs<ExtArgs>>): Prisma__DevelopmentPopulationSampleClient<$Result.GetResult<Prisma.$DevelopmentPopulationSamplePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DevelopmentPopulationSample.
     * @param {DevelopmentPopulationSampleUpdateArgs} args - Arguments to update one DevelopmentPopulationSample.
     * @example
     * // Update one DevelopmentPopulationSample
     * const developmentPopulationSample = await prisma.developmentPopulationSample.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DevelopmentPopulationSampleUpdateArgs>(args: SelectSubset<T, DevelopmentPopulationSampleUpdateArgs<ExtArgs>>): Prisma__DevelopmentPopulationSampleClient<$Result.GetResult<Prisma.$DevelopmentPopulationSamplePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DevelopmentPopulationSamples.
     * @param {DevelopmentPopulationSampleDeleteManyArgs} args - Arguments to filter DevelopmentPopulationSamples to delete.
     * @example
     * // Delete a few DevelopmentPopulationSamples
     * const { count } = await prisma.developmentPopulationSample.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DevelopmentPopulationSampleDeleteManyArgs>(args?: SelectSubset<T, DevelopmentPopulationSampleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DevelopmentPopulationSamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevelopmentPopulationSampleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DevelopmentPopulationSamples
     * const developmentPopulationSample = await prisma.developmentPopulationSample.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DevelopmentPopulationSampleUpdateManyArgs>(args: SelectSubset<T, DevelopmentPopulationSampleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DevelopmentPopulationSample.
     * @param {DevelopmentPopulationSampleUpsertArgs} args - Arguments to update or create a DevelopmentPopulationSample.
     * @example
     * // Update or create a DevelopmentPopulationSample
     * const developmentPopulationSample = await prisma.developmentPopulationSample.upsert({
     *   create: {
     *     // ... data to create a DevelopmentPopulationSample
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DevelopmentPopulationSample we want to update
     *   }
     * })
     */
    upsert<T extends DevelopmentPopulationSampleUpsertArgs>(args: SelectSubset<T, DevelopmentPopulationSampleUpsertArgs<ExtArgs>>): Prisma__DevelopmentPopulationSampleClient<$Result.GetResult<Prisma.$DevelopmentPopulationSamplePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DevelopmentPopulationSamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevelopmentPopulationSampleCountArgs} args - Arguments to filter DevelopmentPopulationSamples to count.
     * @example
     * // Count the number of DevelopmentPopulationSamples
     * const count = await prisma.developmentPopulationSample.count({
     *   where: {
     *     // ... the filter for the DevelopmentPopulationSamples we want to count
     *   }
     * })
    **/
    count<T extends DevelopmentPopulationSampleCountArgs>(
      args?: Subset<T, DevelopmentPopulationSampleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DevelopmentPopulationSampleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DevelopmentPopulationSample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevelopmentPopulationSampleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DevelopmentPopulationSampleAggregateArgs>(args: Subset<T, DevelopmentPopulationSampleAggregateArgs>): Prisma.PrismaPromise<GetDevelopmentPopulationSampleAggregateType<T>>

    /**
     * Group by DevelopmentPopulationSample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevelopmentPopulationSampleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DevelopmentPopulationSampleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DevelopmentPopulationSampleGroupByArgs['orderBy'] }
        : { orderBy?: DevelopmentPopulationSampleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DevelopmentPopulationSampleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDevelopmentPopulationSampleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DevelopmentPopulationSample model
   */
  readonly fields: DevelopmentPopulationSampleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DevelopmentPopulationSample.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DevelopmentPopulationSampleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    broadAncestryCategory<T extends BroadAncestryCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BroadAncestryCategoryDefaultArgs<ExtArgs>>): Prisma__BroadAncestryCategoryClient<$Result.GetResult<Prisma.$BroadAncestryCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prsModel<T extends PRSModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PRSModelDefaultArgs<ExtArgs>>): Prisma__PRSModelClient<$Result.GetResult<Prisma.$PRSModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DevelopmentPopulationSample model
   */
  interface DevelopmentPopulationSampleFieldRefs {
    readonly id: FieldRef<"DevelopmentPopulationSample", 'Int'>
    readonly numberOfIndividuals: FieldRef<"DevelopmentPopulationSample", 'Int'>
    readonly numberOfCases: FieldRef<"DevelopmentPopulationSample", 'Int'>
    readonly numberOfControls: FieldRef<"DevelopmentPopulationSample", 'Int'>
    readonly percentMale: FieldRef<"DevelopmentPopulationSample", 'Float'>
    readonly age: FieldRef<"DevelopmentPopulationSample", 'Float'>
    readonly ageUnits: FieldRef<"DevelopmentPopulationSample", 'String'>
    readonly ancestryBroad: FieldRef<"DevelopmentPopulationSample", 'String'>
    readonly ancestryDetails: FieldRef<"DevelopmentPopulationSample", 'String'>
    readonly cohort: FieldRef<"DevelopmentPopulationSample", 'String'>
    readonly gcId: FieldRef<"DevelopmentPopulationSample", 'String'>
    readonly sourcePMID: FieldRef<"DevelopmentPopulationSample", 'String'>
    readonly sourceDOI: FieldRef<"DevelopmentPopulationSample", 'String'>
    readonly role: FieldRef<"DevelopmentPopulationSample", 'DevelopmentRoleType'>
    readonly prsModelId: FieldRef<"DevelopmentPopulationSample", 'Int'>
    readonly broadAncestryId: FieldRef<"DevelopmentPopulationSample", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DevelopmentPopulationSample findUnique
   */
  export type DevelopmentPopulationSampleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPopulationSample
     */
    select?: DevelopmentPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPopulationSample
     */
    omit?: DevelopmentPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevelopmentPopulationSampleInclude<ExtArgs> | null
    /**
     * Filter, which DevelopmentPopulationSample to fetch.
     */
    where: DevelopmentPopulationSampleWhereUniqueInput
  }

  /**
   * DevelopmentPopulationSample findUniqueOrThrow
   */
  export type DevelopmentPopulationSampleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPopulationSample
     */
    select?: DevelopmentPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPopulationSample
     */
    omit?: DevelopmentPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevelopmentPopulationSampleInclude<ExtArgs> | null
    /**
     * Filter, which DevelopmentPopulationSample to fetch.
     */
    where: DevelopmentPopulationSampleWhereUniqueInput
  }

  /**
   * DevelopmentPopulationSample findFirst
   */
  export type DevelopmentPopulationSampleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPopulationSample
     */
    select?: DevelopmentPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPopulationSample
     */
    omit?: DevelopmentPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevelopmentPopulationSampleInclude<ExtArgs> | null
    /**
     * Filter, which DevelopmentPopulationSample to fetch.
     */
    where?: DevelopmentPopulationSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DevelopmentPopulationSamples to fetch.
     */
    orderBy?: DevelopmentPopulationSampleOrderByWithRelationInput | DevelopmentPopulationSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DevelopmentPopulationSamples.
     */
    cursor?: DevelopmentPopulationSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DevelopmentPopulationSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DevelopmentPopulationSamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DevelopmentPopulationSamples.
     */
    distinct?: DevelopmentPopulationSampleScalarFieldEnum | DevelopmentPopulationSampleScalarFieldEnum[]
  }

  /**
   * DevelopmentPopulationSample findFirstOrThrow
   */
  export type DevelopmentPopulationSampleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPopulationSample
     */
    select?: DevelopmentPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPopulationSample
     */
    omit?: DevelopmentPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevelopmentPopulationSampleInclude<ExtArgs> | null
    /**
     * Filter, which DevelopmentPopulationSample to fetch.
     */
    where?: DevelopmentPopulationSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DevelopmentPopulationSamples to fetch.
     */
    orderBy?: DevelopmentPopulationSampleOrderByWithRelationInput | DevelopmentPopulationSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DevelopmentPopulationSamples.
     */
    cursor?: DevelopmentPopulationSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DevelopmentPopulationSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DevelopmentPopulationSamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DevelopmentPopulationSamples.
     */
    distinct?: DevelopmentPopulationSampleScalarFieldEnum | DevelopmentPopulationSampleScalarFieldEnum[]
  }

  /**
   * DevelopmentPopulationSample findMany
   */
  export type DevelopmentPopulationSampleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPopulationSample
     */
    select?: DevelopmentPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPopulationSample
     */
    omit?: DevelopmentPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevelopmentPopulationSampleInclude<ExtArgs> | null
    /**
     * Filter, which DevelopmentPopulationSamples to fetch.
     */
    where?: DevelopmentPopulationSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DevelopmentPopulationSamples to fetch.
     */
    orderBy?: DevelopmentPopulationSampleOrderByWithRelationInput | DevelopmentPopulationSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DevelopmentPopulationSamples.
     */
    cursor?: DevelopmentPopulationSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DevelopmentPopulationSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DevelopmentPopulationSamples.
     */
    skip?: number
    distinct?: DevelopmentPopulationSampleScalarFieldEnum | DevelopmentPopulationSampleScalarFieldEnum[]
  }

  /**
   * DevelopmentPopulationSample create
   */
  export type DevelopmentPopulationSampleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPopulationSample
     */
    select?: DevelopmentPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPopulationSample
     */
    omit?: DevelopmentPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevelopmentPopulationSampleInclude<ExtArgs> | null
    /**
     * The data needed to create a DevelopmentPopulationSample.
     */
    data: XOR<DevelopmentPopulationSampleCreateInput, DevelopmentPopulationSampleUncheckedCreateInput>
  }

  /**
   * DevelopmentPopulationSample createMany
   */
  export type DevelopmentPopulationSampleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DevelopmentPopulationSamples.
     */
    data: DevelopmentPopulationSampleCreateManyInput | DevelopmentPopulationSampleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DevelopmentPopulationSample update
   */
  export type DevelopmentPopulationSampleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPopulationSample
     */
    select?: DevelopmentPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPopulationSample
     */
    omit?: DevelopmentPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevelopmentPopulationSampleInclude<ExtArgs> | null
    /**
     * The data needed to update a DevelopmentPopulationSample.
     */
    data: XOR<DevelopmentPopulationSampleUpdateInput, DevelopmentPopulationSampleUncheckedUpdateInput>
    /**
     * Choose, which DevelopmentPopulationSample to update.
     */
    where: DevelopmentPopulationSampleWhereUniqueInput
  }

  /**
   * DevelopmentPopulationSample updateMany
   */
  export type DevelopmentPopulationSampleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DevelopmentPopulationSamples.
     */
    data: XOR<DevelopmentPopulationSampleUpdateManyMutationInput, DevelopmentPopulationSampleUncheckedUpdateManyInput>
    /**
     * Filter which DevelopmentPopulationSamples to update
     */
    where?: DevelopmentPopulationSampleWhereInput
    /**
     * Limit how many DevelopmentPopulationSamples to update.
     */
    limit?: number
  }

  /**
   * DevelopmentPopulationSample upsert
   */
  export type DevelopmentPopulationSampleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPopulationSample
     */
    select?: DevelopmentPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPopulationSample
     */
    omit?: DevelopmentPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevelopmentPopulationSampleInclude<ExtArgs> | null
    /**
     * The filter to search for the DevelopmentPopulationSample to update in case it exists.
     */
    where: DevelopmentPopulationSampleWhereUniqueInput
    /**
     * In case the DevelopmentPopulationSample found by the `where` argument doesn't exist, create a new DevelopmentPopulationSample with this data.
     */
    create: XOR<DevelopmentPopulationSampleCreateInput, DevelopmentPopulationSampleUncheckedCreateInput>
    /**
     * In case the DevelopmentPopulationSample was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DevelopmentPopulationSampleUpdateInput, DevelopmentPopulationSampleUncheckedUpdateInput>
  }

  /**
   * DevelopmentPopulationSample delete
   */
  export type DevelopmentPopulationSampleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPopulationSample
     */
    select?: DevelopmentPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPopulationSample
     */
    omit?: DevelopmentPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevelopmentPopulationSampleInclude<ExtArgs> | null
    /**
     * Filter which DevelopmentPopulationSample to delete.
     */
    where: DevelopmentPopulationSampleWhereUniqueInput
  }

  /**
   * DevelopmentPopulationSample deleteMany
   */
  export type DevelopmentPopulationSampleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DevelopmentPopulationSamples to delete
     */
    where?: DevelopmentPopulationSampleWhereInput
    /**
     * Limit how many DevelopmentPopulationSamples to delete.
     */
    limit?: number
  }

  /**
   * DevelopmentPopulationSample without action
   */
  export type DevelopmentPopulationSampleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPopulationSample
     */
    select?: DevelopmentPopulationSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPopulationSample
     */
    omit?: DevelopmentPopulationSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevelopmentPopulationSampleInclude<ExtArgs> | null
  }


  /**
   * Model BroadAncestryInRefPop
   */

  export type AggregateBroadAncestryInRefPop = {
    _count: BroadAncestryInRefPopCountAggregateOutputType | null
    _avg: BroadAncestryInRefPopAvgAggregateOutputType | null
    _sum: BroadAncestryInRefPopSumAggregateOutputType | null
    _min: BroadAncestryInRefPopMinAggregateOutputType | null
    _max: BroadAncestryInRefPopMaxAggregateOutputType | null
  }

  export type BroadAncestryInRefPopAvgAggregateOutputType = {
    percentage: number | null
    broadAncestryId: number | null
    referencePopulationId: number | null
  }

  export type BroadAncestryInRefPopSumAggregateOutputType = {
    percentage: number | null
    broadAncestryId: number | null
    referencePopulationId: number | null
  }

  export type BroadAncestryInRefPopMinAggregateOutputType = {
    percentage: number | null
    broadAncestryId: number | null
    referencePopulationId: number | null
  }

  export type BroadAncestryInRefPopMaxAggregateOutputType = {
    percentage: number | null
    broadAncestryId: number | null
    referencePopulationId: number | null
  }

  export type BroadAncestryInRefPopCountAggregateOutputType = {
    percentage: number
    broadAncestryId: number
    referencePopulationId: number
    _all: number
  }


  export type BroadAncestryInRefPopAvgAggregateInputType = {
    percentage?: true
    broadAncestryId?: true
    referencePopulationId?: true
  }

  export type BroadAncestryInRefPopSumAggregateInputType = {
    percentage?: true
    broadAncestryId?: true
    referencePopulationId?: true
  }

  export type BroadAncestryInRefPopMinAggregateInputType = {
    percentage?: true
    broadAncestryId?: true
    referencePopulationId?: true
  }

  export type BroadAncestryInRefPopMaxAggregateInputType = {
    percentage?: true
    broadAncestryId?: true
    referencePopulationId?: true
  }

  export type BroadAncestryInRefPopCountAggregateInputType = {
    percentage?: true
    broadAncestryId?: true
    referencePopulationId?: true
    _all?: true
  }

  export type BroadAncestryInRefPopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BroadAncestryInRefPop to aggregate.
     */
    where?: BroadAncestryInRefPopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BroadAncestryInRefPops to fetch.
     */
    orderBy?: BroadAncestryInRefPopOrderByWithRelationInput | BroadAncestryInRefPopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BroadAncestryInRefPopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BroadAncestryInRefPops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BroadAncestryInRefPops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BroadAncestryInRefPops
    **/
    _count?: true | BroadAncestryInRefPopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BroadAncestryInRefPopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BroadAncestryInRefPopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BroadAncestryInRefPopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BroadAncestryInRefPopMaxAggregateInputType
  }

  export type GetBroadAncestryInRefPopAggregateType<T extends BroadAncestryInRefPopAggregateArgs> = {
        [P in keyof T & keyof AggregateBroadAncestryInRefPop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBroadAncestryInRefPop[P]>
      : GetScalarType<T[P], AggregateBroadAncestryInRefPop[P]>
  }




  export type BroadAncestryInRefPopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BroadAncestryInRefPopWhereInput
    orderBy?: BroadAncestryInRefPopOrderByWithAggregationInput | BroadAncestryInRefPopOrderByWithAggregationInput[]
    by: BroadAncestryInRefPopScalarFieldEnum[] | BroadAncestryInRefPopScalarFieldEnum
    having?: BroadAncestryInRefPopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BroadAncestryInRefPopCountAggregateInputType | true
    _avg?: BroadAncestryInRefPopAvgAggregateInputType
    _sum?: BroadAncestryInRefPopSumAggregateInputType
    _min?: BroadAncestryInRefPopMinAggregateInputType
    _max?: BroadAncestryInRefPopMaxAggregateInputType
  }

  export type BroadAncestryInRefPopGroupByOutputType = {
    percentage: number
    broadAncestryId: number
    referencePopulationId: number
    _count: BroadAncestryInRefPopCountAggregateOutputType | null
    _avg: BroadAncestryInRefPopAvgAggregateOutputType | null
    _sum: BroadAncestryInRefPopSumAggregateOutputType | null
    _min: BroadAncestryInRefPopMinAggregateOutputType | null
    _max: BroadAncestryInRefPopMaxAggregateOutputType | null
  }

  type GetBroadAncestryInRefPopGroupByPayload<T extends BroadAncestryInRefPopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BroadAncestryInRefPopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BroadAncestryInRefPopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BroadAncestryInRefPopGroupByOutputType[P]>
            : GetScalarType<T[P], BroadAncestryInRefPopGroupByOutputType[P]>
        }
      >
    >


  export type BroadAncestryInRefPopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    percentage?: boolean
    broadAncestryId?: boolean
    referencePopulationId?: boolean
    broadAncestryCategory?: boolean | BroadAncestryCategoryDefaultArgs<ExtArgs>
    referencePopulation?: boolean | ReferencePopulationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["broadAncestryInRefPop"]>



  export type BroadAncestryInRefPopSelectScalar = {
    percentage?: boolean
    broadAncestryId?: boolean
    referencePopulationId?: boolean
  }

  export type BroadAncestryInRefPopOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"percentage" | "broadAncestryId" | "referencePopulationId", ExtArgs["result"]["broadAncestryInRefPop"]>
  export type BroadAncestryInRefPopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    broadAncestryCategory?: boolean | BroadAncestryCategoryDefaultArgs<ExtArgs>
    referencePopulation?: boolean | ReferencePopulationDefaultArgs<ExtArgs>
  }

  export type $BroadAncestryInRefPopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BroadAncestryInRefPop"
    objects: {
      broadAncestryCategory: Prisma.$BroadAncestryCategoryPayload<ExtArgs>
      referencePopulation: Prisma.$ReferencePopulationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      percentage: number
      broadAncestryId: number
      referencePopulationId: number
    }, ExtArgs["result"]["broadAncestryInRefPop"]>
    composites: {}
  }

  type BroadAncestryInRefPopGetPayload<S extends boolean | null | undefined | BroadAncestryInRefPopDefaultArgs> = $Result.GetResult<Prisma.$BroadAncestryInRefPopPayload, S>

  type BroadAncestryInRefPopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BroadAncestryInRefPopFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BroadAncestryInRefPopCountAggregateInputType | true
    }

  export interface BroadAncestryInRefPopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BroadAncestryInRefPop'], meta: { name: 'BroadAncestryInRefPop' } }
    /**
     * Find zero or one BroadAncestryInRefPop that matches the filter.
     * @param {BroadAncestryInRefPopFindUniqueArgs} args - Arguments to find a BroadAncestryInRefPop
     * @example
     * // Get one BroadAncestryInRefPop
     * const broadAncestryInRefPop = await prisma.broadAncestryInRefPop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BroadAncestryInRefPopFindUniqueArgs>(args: SelectSubset<T, BroadAncestryInRefPopFindUniqueArgs<ExtArgs>>): Prisma__BroadAncestryInRefPopClient<$Result.GetResult<Prisma.$BroadAncestryInRefPopPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BroadAncestryInRefPop that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BroadAncestryInRefPopFindUniqueOrThrowArgs} args - Arguments to find a BroadAncestryInRefPop
     * @example
     * // Get one BroadAncestryInRefPop
     * const broadAncestryInRefPop = await prisma.broadAncestryInRefPop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BroadAncestryInRefPopFindUniqueOrThrowArgs>(args: SelectSubset<T, BroadAncestryInRefPopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BroadAncestryInRefPopClient<$Result.GetResult<Prisma.$BroadAncestryInRefPopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BroadAncestryInRefPop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryInRefPopFindFirstArgs} args - Arguments to find a BroadAncestryInRefPop
     * @example
     * // Get one BroadAncestryInRefPop
     * const broadAncestryInRefPop = await prisma.broadAncestryInRefPop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BroadAncestryInRefPopFindFirstArgs>(args?: SelectSubset<T, BroadAncestryInRefPopFindFirstArgs<ExtArgs>>): Prisma__BroadAncestryInRefPopClient<$Result.GetResult<Prisma.$BroadAncestryInRefPopPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BroadAncestryInRefPop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryInRefPopFindFirstOrThrowArgs} args - Arguments to find a BroadAncestryInRefPop
     * @example
     * // Get one BroadAncestryInRefPop
     * const broadAncestryInRefPop = await prisma.broadAncestryInRefPop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BroadAncestryInRefPopFindFirstOrThrowArgs>(args?: SelectSubset<T, BroadAncestryInRefPopFindFirstOrThrowArgs<ExtArgs>>): Prisma__BroadAncestryInRefPopClient<$Result.GetResult<Prisma.$BroadAncestryInRefPopPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BroadAncestryInRefPops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryInRefPopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BroadAncestryInRefPops
     * const broadAncestryInRefPops = await prisma.broadAncestryInRefPop.findMany()
     * 
     * // Get first 10 BroadAncestryInRefPops
     * const broadAncestryInRefPops = await prisma.broadAncestryInRefPop.findMany({ take: 10 })
     * 
     * // Only select the `percentage`
     * const broadAncestryInRefPopWithPercentageOnly = await prisma.broadAncestryInRefPop.findMany({ select: { percentage: true } })
     * 
     */
    findMany<T extends BroadAncestryInRefPopFindManyArgs>(args?: SelectSubset<T, BroadAncestryInRefPopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BroadAncestryInRefPopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BroadAncestryInRefPop.
     * @param {BroadAncestryInRefPopCreateArgs} args - Arguments to create a BroadAncestryInRefPop.
     * @example
     * // Create one BroadAncestryInRefPop
     * const BroadAncestryInRefPop = await prisma.broadAncestryInRefPop.create({
     *   data: {
     *     // ... data to create a BroadAncestryInRefPop
     *   }
     * })
     * 
     */
    create<T extends BroadAncestryInRefPopCreateArgs>(args: SelectSubset<T, BroadAncestryInRefPopCreateArgs<ExtArgs>>): Prisma__BroadAncestryInRefPopClient<$Result.GetResult<Prisma.$BroadAncestryInRefPopPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BroadAncestryInRefPops.
     * @param {BroadAncestryInRefPopCreateManyArgs} args - Arguments to create many BroadAncestryInRefPops.
     * @example
     * // Create many BroadAncestryInRefPops
     * const broadAncestryInRefPop = await prisma.broadAncestryInRefPop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BroadAncestryInRefPopCreateManyArgs>(args?: SelectSubset<T, BroadAncestryInRefPopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BroadAncestryInRefPop.
     * @param {BroadAncestryInRefPopDeleteArgs} args - Arguments to delete one BroadAncestryInRefPop.
     * @example
     * // Delete one BroadAncestryInRefPop
     * const BroadAncestryInRefPop = await prisma.broadAncestryInRefPop.delete({
     *   where: {
     *     // ... filter to delete one BroadAncestryInRefPop
     *   }
     * })
     * 
     */
    delete<T extends BroadAncestryInRefPopDeleteArgs>(args: SelectSubset<T, BroadAncestryInRefPopDeleteArgs<ExtArgs>>): Prisma__BroadAncestryInRefPopClient<$Result.GetResult<Prisma.$BroadAncestryInRefPopPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BroadAncestryInRefPop.
     * @param {BroadAncestryInRefPopUpdateArgs} args - Arguments to update one BroadAncestryInRefPop.
     * @example
     * // Update one BroadAncestryInRefPop
     * const broadAncestryInRefPop = await prisma.broadAncestryInRefPop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BroadAncestryInRefPopUpdateArgs>(args: SelectSubset<T, BroadAncestryInRefPopUpdateArgs<ExtArgs>>): Prisma__BroadAncestryInRefPopClient<$Result.GetResult<Prisma.$BroadAncestryInRefPopPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BroadAncestryInRefPops.
     * @param {BroadAncestryInRefPopDeleteManyArgs} args - Arguments to filter BroadAncestryInRefPops to delete.
     * @example
     * // Delete a few BroadAncestryInRefPops
     * const { count } = await prisma.broadAncestryInRefPop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BroadAncestryInRefPopDeleteManyArgs>(args?: SelectSubset<T, BroadAncestryInRefPopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BroadAncestryInRefPops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryInRefPopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BroadAncestryInRefPops
     * const broadAncestryInRefPop = await prisma.broadAncestryInRefPop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BroadAncestryInRefPopUpdateManyArgs>(args: SelectSubset<T, BroadAncestryInRefPopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BroadAncestryInRefPop.
     * @param {BroadAncestryInRefPopUpsertArgs} args - Arguments to update or create a BroadAncestryInRefPop.
     * @example
     * // Update or create a BroadAncestryInRefPop
     * const broadAncestryInRefPop = await prisma.broadAncestryInRefPop.upsert({
     *   create: {
     *     // ... data to create a BroadAncestryInRefPop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BroadAncestryInRefPop we want to update
     *   }
     * })
     */
    upsert<T extends BroadAncestryInRefPopUpsertArgs>(args: SelectSubset<T, BroadAncestryInRefPopUpsertArgs<ExtArgs>>): Prisma__BroadAncestryInRefPopClient<$Result.GetResult<Prisma.$BroadAncestryInRefPopPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BroadAncestryInRefPops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryInRefPopCountArgs} args - Arguments to filter BroadAncestryInRefPops to count.
     * @example
     * // Count the number of BroadAncestryInRefPops
     * const count = await prisma.broadAncestryInRefPop.count({
     *   where: {
     *     // ... the filter for the BroadAncestryInRefPops we want to count
     *   }
     * })
    **/
    count<T extends BroadAncestryInRefPopCountArgs>(
      args?: Subset<T, BroadAncestryInRefPopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BroadAncestryInRefPopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BroadAncestryInRefPop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryInRefPopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BroadAncestryInRefPopAggregateArgs>(args: Subset<T, BroadAncestryInRefPopAggregateArgs>): Prisma.PrismaPromise<GetBroadAncestryInRefPopAggregateType<T>>

    /**
     * Group by BroadAncestryInRefPop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadAncestryInRefPopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BroadAncestryInRefPopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BroadAncestryInRefPopGroupByArgs['orderBy'] }
        : { orderBy?: BroadAncestryInRefPopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BroadAncestryInRefPopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBroadAncestryInRefPopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BroadAncestryInRefPop model
   */
  readonly fields: BroadAncestryInRefPopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BroadAncestryInRefPop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BroadAncestryInRefPopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    broadAncestryCategory<T extends BroadAncestryCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BroadAncestryCategoryDefaultArgs<ExtArgs>>): Prisma__BroadAncestryCategoryClient<$Result.GetResult<Prisma.$BroadAncestryCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    referencePopulation<T extends ReferencePopulationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReferencePopulationDefaultArgs<ExtArgs>>): Prisma__ReferencePopulationClient<$Result.GetResult<Prisma.$ReferencePopulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BroadAncestryInRefPop model
   */
  interface BroadAncestryInRefPopFieldRefs {
    readonly percentage: FieldRef<"BroadAncestryInRefPop", 'Float'>
    readonly broadAncestryId: FieldRef<"BroadAncestryInRefPop", 'Int'>
    readonly referencePopulationId: FieldRef<"BroadAncestryInRefPop", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BroadAncestryInRefPop findUnique
   */
  export type BroadAncestryInRefPopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInRefPop
     */
    select?: BroadAncestryInRefPopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInRefPop
     */
    omit?: BroadAncestryInRefPopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInRefPopInclude<ExtArgs> | null
    /**
     * Filter, which BroadAncestryInRefPop to fetch.
     */
    where: BroadAncestryInRefPopWhereUniqueInput
  }

  /**
   * BroadAncestryInRefPop findUniqueOrThrow
   */
  export type BroadAncestryInRefPopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInRefPop
     */
    select?: BroadAncestryInRefPopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInRefPop
     */
    omit?: BroadAncestryInRefPopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInRefPopInclude<ExtArgs> | null
    /**
     * Filter, which BroadAncestryInRefPop to fetch.
     */
    where: BroadAncestryInRefPopWhereUniqueInput
  }

  /**
   * BroadAncestryInRefPop findFirst
   */
  export type BroadAncestryInRefPopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInRefPop
     */
    select?: BroadAncestryInRefPopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInRefPop
     */
    omit?: BroadAncestryInRefPopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInRefPopInclude<ExtArgs> | null
    /**
     * Filter, which BroadAncestryInRefPop to fetch.
     */
    where?: BroadAncestryInRefPopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BroadAncestryInRefPops to fetch.
     */
    orderBy?: BroadAncestryInRefPopOrderByWithRelationInput | BroadAncestryInRefPopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BroadAncestryInRefPops.
     */
    cursor?: BroadAncestryInRefPopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BroadAncestryInRefPops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BroadAncestryInRefPops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BroadAncestryInRefPops.
     */
    distinct?: BroadAncestryInRefPopScalarFieldEnum | BroadAncestryInRefPopScalarFieldEnum[]
  }

  /**
   * BroadAncestryInRefPop findFirstOrThrow
   */
  export type BroadAncestryInRefPopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInRefPop
     */
    select?: BroadAncestryInRefPopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInRefPop
     */
    omit?: BroadAncestryInRefPopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInRefPopInclude<ExtArgs> | null
    /**
     * Filter, which BroadAncestryInRefPop to fetch.
     */
    where?: BroadAncestryInRefPopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BroadAncestryInRefPops to fetch.
     */
    orderBy?: BroadAncestryInRefPopOrderByWithRelationInput | BroadAncestryInRefPopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BroadAncestryInRefPops.
     */
    cursor?: BroadAncestryInRefPopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BroadAncestryInRefPops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BroadAncestryInRefPops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BroadAncestryInRefPops.
     */
    distinct?: BroadAncestryInRefPopScalarFieldEnum | BroadAncestryInRefPopScalarFieldEnum[]
  }

  /**
   * BroadAncestryInRefPop findMany
   */
  export type BroadAncestryInRefPopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInRefPop
     */
    select?: BroadAncestryInRefPopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInRefPop
     */
    omit?: BroadAncestryInRefPopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInRefPopInclude<ExtArgs> | null
    /**
     * Filter, which BroadAncestryInRefPops to fetch.
     */
    where?: BroadAncestryInRefPopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BroadAncestryInRefPops to fetch.
     */
    orderBy?: BroadAncestryInRefPopOrderByWithRelationInput | BroadAncestryInRefPopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BroadAncestryInRefPops.
     */
    cursor?: BroadAncestryInRefPopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BroadAncestryInRefPops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BroadAncestryInRefPops.
     */
    skip?: number
    distinct?: BroadAncestryInRefPopScalarFieldEnum | BroadAncestryInRefPopScalarFieldEnum[]
  }

  /**
   * BroadAncestryInRefPop create
   */
  export type BroadAncestryInRefPopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInRefPop
     */
    select?: BroadAncestryInRefPopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInRefPop
     */
    omit?: BroadAncestryInRefPopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInRefPopInclude<ExtArgs> | null
    /**
     * The data needed to create a BroadAncestryInRefPop.
     */
    data: XOR<BroadAncestryInRefPopCreateInput, BroadAncestryInRefPopUncheckedCreateInput>
  }

  /**
   * BroadAncestryInRefPop createMany
   */
  export type BroadAncestryInRefPopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BroadAncestryInRefPops.
     */
    data: BroadAncestryInRefPopCreateManyInput | BroadAncestryInRefPopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BroadAncestryInRefPop update
   */
  export type BroadAncestryInRefPopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInRefPop
     */
    select?: BroadAncestryInRefPopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInRefPop
     */
    omit?: BroadAncestryInRefPopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInRefPopInclude<ExtArgs> | null
    /**
     * The data needed to update a BroadAncestryInRefPop.
     */
    data: XOR<BroadAncestryInRefPopUpdateInput, BroadAncestryInRefPopUncheckedUpdateInput>
    /**
     * Choose, which BroadAncestryInRefPop to update.
     */
    where: BroadAncestryInRefPopWhereUniqueInput
  }

  /**
   * BroadAncestryInRefPop updateMany
   */
  export type BroadAncestryInRefPopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BroadAncestryInRefPops.
     */
    data: XOR<BroadAncestryInRefPopUpdateManyMutationInput, BroadAncestryInRefPopUncheckedUpdateManyInput>
    /**
     * Filter which BroadAncestryInRefPops to update
     */
    where?: BroadAncestryInRefPopWhereInput
    /**
     * Limit how many BroadAncestryInRefPops to update.
     */
    limit?: number
  }

  /**
   * BroadAncestryInRefPop upsert
   */
  export type BroadAncestryInRefPopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInRefPop
     */
    select?: BroadAncestryInRefPopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInRefPop
     */
    omit?: BroadAncestryInRefPopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInRefPopInclude<ExtArgs> | null
    /**
     * The filter to search for the BroadAncestryInRefPop to update in case it exists.
     */
    where: BroadAncestryInRefPopWhereUniqueInput
    /**
     * In case the BroadAncestryInRefPop found by the `where` argument doesn't exist, create a new BroadAncestryInRefPop with this data.
     */
    create: XOR<BroadAncestryInRefPopCreateInput, BroadAncestryInRefPopUncheckedCreateInput>
    /**
     * In case the BroadAncestryInRefPop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BroadAncestryInRefPopUpdateInput, BroadAncestryInRefPopUncheckedUpdateInput>
  }

  /**
   * BroadAncestryInRefPop delete
   */
  export type BroadAncestryInRefPopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInRefPop
     */
    select?: BroadAncestryInRefPopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInRefPop
     */
    omit?: BroadAncestryInRefPopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInRefPopInclude<ExtArgs> | null
    /**
     * Filter which BroadAncestryInRefPop to delete.
     */
    where: BroadAncestryInRefPopWhereUniqueInput
  }

  /**
   * BroadAncestryInRefPop deleteMany
   */
  export type BroadAncestryInRefPopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BroadAncestryInRefPops to delete
     */
    where?: BroadAncestryInRefPopWhereInput
    /**
     * Limit how many BroadAncestryInRefPops to delete.
     */
    limit?: number
  }

  /**
   * BroadAncestryInRefPop without action
   */
  export type BroadAncestryInRefPopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInRefPop
     */
    select?: BroadAncestryInRefPopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInRefPop
     */
    omit?: BroadAncestryInRefPopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInRefPopInclude<ExtArgs> | null
  }


  /**
   * Model ReferencePopulation
   */

  export type AggregateReferencePopulation = {
    _count: ReferencePopulationCountAggregateOutputType | null
    _avg: ReferencePopulationAvgAggregateOutputType | null
    _sum: ReferencePopulationSumAggregateOutputType | null
    _min: ReferencePopulationMinAggregateOutputType | null
    _max: ReferencePopulationMaxAggregateOutputType | null
  }

  export type ReferencePopulationAvgAggregateOutputType = {
    id: number | null
    numberOfindividuals: number | null
    numberOfvariants: number | null
  }

  export type ReferencePopulationSumAggregateOutputType = {
    id: number | null
    numberOfindividuals: number | null
    numberOfvariants: number | null
  }

  export type ReferencePopulationMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    studyURL: string | null
    assembly: $Enums.AssemblyType | null
    numberOfindividuals: number | null
    numberOfvariants: number | null
    studyName: string | null
    date: Date | null
    path: string | null
  }

  export type ReferencePopulationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    studyURL: string | null
    assembly: $Enums.AssemblyType | null
    numberOfindividuals: number | null
    numberOfvariants: number | null
    studyName: string | null
    date: Date | null
    path: string | null
  }

  export type ReferencePopulationCountAggregateOutputType = {
    id: number
    name: number
    description: number
    studyURL: number
    assembly: number
    numberOfindividuals: number
    numberOfvariants: number
    studyName: number
    date: number
    path: number
    _all: number
  }


  export type ReferencePopulationAvgAggregateInputType = {
    id?: true
    numberOfindividuals?: true
    numberOfvariants?: true
  }

  export type ReferencePopulationSumAggregateInputType = {
    id?: true
    numberOfindividuals?: true
    numberOfvariants?: true
  }

  export type ReferencePopulationMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    studyURL?: true
    assembly?: true
    numberOfindividuals?: true
    numberOfvariants?: true
    studyName?: true
    date?: true
    path?: true
  }

  export type ReferencePopulationMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    studyURL?: true
    assembly?: true
    numberOfindividuals?: true
    numberOfvariants?: true
    studyName?: true
    date?: true
    path?: true
  }

  export type ReferencePopulationCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    studyURL?: true
    assembly?: true
    numberOfindividuals?: true
    numberOfvariants?: true
    studyName?: true
    date?: true
    path?: true
    _all?: true
  }

  export type ReferencePopulationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferencePopulation to aggregate.
     */
    where?: ReferencePopulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferencePopulations to fetch.
     */
    orderBy?: ReferencePopulationOrderByWithRelationInput | ReferencePopulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferencePopulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferencePopulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferencePopulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferencePopulations
    **/
    _count?: true | ReferencePopulationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferencePopulationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferencePopulationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferencePopulationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferencePopulationMaxAggregateInputType
  }

  export type GetReferencePopulationAggregateType<T extends ReferencePopulationAggregateArgs> = {
        [P in keyof T & keyof AggregateReferencePopulation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferencePopulation[P]>
      : GetScalarType<T[P], AggregateReferencePopulation[P]>
  }




  export type ReferencePopulationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferencePopulationWhereInput
    orderBy?: ReferencePopulationOrderByWithAggregationInput | ReferencePopulationOrderByWithAggregationInput[]
    by: ReferencePopulationScalarFieldEnum[] | ReferencePopulationScalarFieldEnum
    having?: ReferencePopulationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferencePopulationCountAggregateInputType | true
    _avg?: ReferencePopulationAvgAggregateInputType
    _sum?: ReferencePopulationSumAggregateInputType
    _min?: ReferencePopulationMinAggregateInputType
    _max?: ReferencePopulationMaxAggregateInputType
  }

  export type ReferencePopulationGroupByOutputType = {
    id: number
    name: string
    description: string | null
    studyURL: string | null
    assembly: $Enums.AssemblyType
    numberOfindividuals: number | null
    numberOfvariants: number | null
    studyName: string
    date: Date
    path: string
    _count: ReferencePopulationCountAggregateOutputType | null
    _avg: ReferencePopulationAvgAggregateOutputType | null
    _sum: ReferencePopulationSumAggregateOutputType | null
    _min: ReferencePopulationMinAggregateOutputType | null
    _max: ReferencePopulationMaxAggregateOutputType | null
  }

  type GetReferencePopulationGroupByPayload<T extends ReferencePopulationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferencePopulationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferencePopulationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferencePopulationGroupByOutputType[P]>
            : GetScalarType<T[P], ReferencePopulationGroupByOutputType[P]>
        }
      >
    >


  export type ReferencePopulationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    studyURL?: boolean
    assembly?: boolean
    numberOfindividuals?: boolean
    numberOfvariants?: boolean
    studyName?: boolean
    date?: boolean
    path?: boolean
    broadAncestryCategories?: boolean | ReferencePopulation$broadAncestryCategoriesArgs<ExtArgs>
    prsAnalyses?: boolean | ReferencePopulation$prsAnalysesArgs<ExtArgs>
    _count?: boolean | ReferencePopulationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referencePopulation"]>



  export type ReferencePopulationSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    studyURL?: boolean
    assembly?: boolean
    numberOfindividuals?: boolean
    numberOfvariants?: boolean
    studyName?: boolean
    date?: boolean
    path?: boolean
  }

  export type ReferencePopulationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "studyURL" | "assembly" | "numberOfindividuals" | "numberOfvariants" | "studyName" | "date" | "path", ExtArgs["result"]["referencePopulation"]>
  export type ReferencePopulationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    broadAncestryCategories?: boolean | ReferencePopulation$broadAncestryCategoriesArgs<ExtArgs>
    prsAnalyses?: boolean | ReferencePopulation$prsAnalysesArgs<ExtArgs>
    _count?: boolean | ReferencePopulationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ReferencePopulationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferencePopulation"
    objects: {
      broadAncestryCategories: Prisma.$BroadAncestryInRefPopPayload<ExtArgs>[]
      prsAnalyses: Prisma.$PRSAnalysisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      studyURL: string | null
      assembly: $Enums.AssemblyType
      numberOfindividuals: number | null
      numberOfvariants: number | null
      studyName: string
      date: Date
      path: string
    }, ExtArgs["result"]["referencePopulation"]>
    composites: {}
  }

  type ReferencePopulationGetPayload<S extends boolean | null | undefined | ReferencePopulationDefaultArgs> = $Result.GetResult<Prisma.$ReferencePopulationPayload, S>

  type ReferencePopulationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferencePopulationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferencePopulationCountAggregateInputType | true
    }

  export interface ReferencePopulationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferencePopulation'], meta: { name: 'ReferencePopulation' } }
    /**
     * Find zero or one ReferencePopulation that matches the filter.
     * @param {ReferencePopulationFindUniqueArgs} args - Arguments to find a ReferencePopulation
     * @example
     * // Get one ReferencePopulation
     * const referencePopulation = await prisma.referencePopulation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferencePopulationFindUniqueArgs>(args: SelectSubset<T, ReferencePopulationFindUniqueArgs<ExtArgs>>): Prisma__ReferencePopulationClient<$Result.GetResult<Prisma.$ReferencePopulationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReferencePopulation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferencePopulationFindUniqueOrThrowArgs} args - Arguments to find a ReferencePopulation
     * @example
     * // Get one ReferencePopulation
     * const referencePopulation = await prisma.referencePopulation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferencePopulationFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferencePopulationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferencePopulationClient<$Result.GetResult<Prisma.$ReferencePopulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReferencePopulation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferencePopulationFindFirstArgs} args - Arguments to find a ReferencePopulation
     * @example
     * // Get one ReferencePopulation
     * const referencePopulation = await prisma.referencePopulation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferencePopulationFindFirstArgs>(args?: SelectSubset<T, ReferencePopulationFindFirstArgs<ExtArgs>>): Prisma__ReferencePopulationClient<$Result.GetResult<Prisma.$ReferencePopulationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReferencePopulation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferencePopulationFindFirstOrThrowArgs} args - Arguments to find a ReferencePopulation
     * @example
     * // Get one ReferencePopulation
     * const referencePopulation = await prisma.referencePopulation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferencePopulationFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferencePopulationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferencePopulationClient<$Result.GetResult<Prisma.$ReferencePopulationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReferencePopulations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferencePopulationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferencePopulations
     * const referencePopulations = await prisma.referencePopulation.findMany()
     * 
     * // Get first 10 ReferencePopulations
     * const referencePopulations = await prisma.referencePopulation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referencePopulationWithIdOnly = await prisma.referencePopulation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferencePopulationFindManyArgs>(args?: SelectSubset<T, ReferencePopulationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferencePopulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReferencePopulation.
     * @param {ReferencePopulationCreateArgs} args - Arguments to create a ReferencePopulation.
     * @example
     * // Create one ReferencePopulation
     * const ReferencePopulation = await prisma.referencePopulation.create({
     *   data: {
     *     // ... data to create a ReferencePopulation
     *   }
     * })
     * 
     */
    create<T extends ReferencePopulationCreateArgs>(args: SelectSubset<T, ReferencePopulationCreateArgs<ExtArgs>>): Prisma__ReferencePopulationClient<$Result.GetResult<Prisma.$ReferencePopulationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReferencePopulations.
     * @param {ReferencePopulationCreateManyArgs} args - Arguments to create many ReferencePopulations.
     * @example
     * // Create many ReferencePopulations
     * const referencePopulation = await prisma.referencePopulation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferencePopulationCreateManyArgs>(args?: SelectSubset<T, ReferencePopulationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReferencePopulation.
     * @param {ReferencePopulationDeleteArgs} args - Arguments to delete one ReferencePopulation.
     * @example
     * // Delete one ReferencePopulation
     * const ReferencePopulation = await prisma.referencePopulation.delete({
     *   where: {
     *     // ... filter to delete one ReferencePopulation
     *   }
     * })
     * 
     */
    delete<T extends ReferencePopulationDeleteArgs>(args: SelectSubset<T, ReferencePopulationDeleteArgs<ExtArgs>>): Prisma__ReferencePopulationClient<$Result.GetResult<Prisma.$ReferencePopulationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReferencePopulation.
     * @param {ReferencePopulationUpdateArgs} args - Arguments to update one ReferencePopulation.
     * @example
     * // Update one ReferencePopulation
     * const referencePopulation = await prisma.referencePopulation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferencePopulationUpdateArgs>(args: SelectSubset<T, ReferencePopulationUpdateArgs<ExtArgs>>): Prisma__ReferencePopulationClient<$Result.GetResult<Prisma.$ReferencePopulationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReferencePopulations.
     * @param {ReferencePopulationDeleteManyArgs} args - Arguments to filter ReferencePopulations to delete.
     * @example
     * // Delete a few ReferencePopulations
     * const { count } = await prisma.referencePopulation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferencePopulationDeleteManyArgs>(args?: SelectSubset<T, ReferencePopulationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferencePopulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferencePopulationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferencePopulations
     * const referencePopulation = await prisma.referencePopulation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferencePopulationUpdateManyArgs>(args: SelectSubset<T, ReferencePopulationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferencePopulation.
     * @param {ReferencePopulationUpsertArgs} args - Arguments to update or create a ReferencePopulation.
     * @example
     * // Update or create a ReferencePopulation
     * const referencePopulation = await prisma.referencePopulation.upsert({
     *   create: {
     *     // ... data to create a ReferencePopulation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferencePopulation we want to update
     *   }
     * })
     */
    upsert<T extends ReferencePopulationUpsertArgs>(args: SelectSubset<T, ReferencePopulationUpsertArgs<ExtArgs>>): Prisma__ReferencePopulationClient<$Result.GetResult<Prisma.$ReferencePopulationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReferencePopulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferencePopulationCountArgs} args - Arguments to filter ReferencePopulations to count.
     * @example
     * // Count the number of ReferencePopulations
     * const count = await prisma.referencePopulation.count({
     *   where: {
     *     // ... the filter for the ReferencePopulations we want to count
     *   }
     * })
    **/
    count<T extends ReferencePopulationCountArgs>(
      args?: Subset<T, ReferencePopulationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferencePopulationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferencePopulation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferencePopulationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferencePopulationAggregateArgs>(args: Subset<T, ReferencePopulationAggregateArgs>): Prisma.PrismaPromise<GetReferencePopulationAggregateType<T>>

    /**
     * Group by ReferencePopulation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferencePopulationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferencePopulationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferencePopulationGroupByArgs['orderBy'] }
        : { orderBy?: ReferencePopulationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferencePopulationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferencePopulationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferencePopulation model
   */
  readonly fields: ReferencePopulationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferencePopulation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferencePopulationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    broadAncestryCategories<T extends ReferencePopulation$broadAncestryCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, ReferencePopulation$broadAncestryCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BroadAncestryInRefPopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prsAnalyses<T extends ReferencePopulation$prsAnalysesArgs<ExtArgs> = {}>(args?: Subset<T, ReferencePopulation$prsAnalysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PRSAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferencePopulation model
   */
  interface ReferencePopulationFieldRefs {
    readonly id: FieldRef<"ReferencePopulation", 'Int'>
    readonly name: FieldRef<"ReferencePopulation", 'String'>
    readonly description: FieldRef<"ReferencePopulation", 'String'>
    readonly studyURL: FieldRef<"ReferencePopulation", 'String'>
    readonly assembly: FieldRef<"ReferencePopulation", 'AssemblyType'>
    readonly numberOfindividuals: FieldRef<"ReferencePopulation", 'Int'>
    readonly numberOfvariants: FieldRef<"ReferencePopulation", 'Int'>
    readonly studyName: FieldRef<"ReferencePopulation", 'String'>
    readonly date: FieldRef<"ReferencePopulation", 'DateTime'>
    readonly path: FieldRef<"ReferencePopulation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReferencePopulation findUnique
   */
  export type ReferencePopulationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferencePopulation
     */
    select?: ReferencePopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferencePopulation
     */
    omit?: ReferencePopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferencePopulationInclude<ExtArgs> | null
    /**
     * Filter, which ReferencePopulation to fetch.
     */
    where: ReferencePopulationWhereUniqueInput
  }

  /**
   * ReferencePopulation findUniqueOrThrow
   */
  export type ReferencePopulationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferencePopulation
     */
    select?: ReferencePopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferencePopulation
     */
    omit?: ReferencePopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferencePopulationInclude<ExtArgs> | null
    /**
     * Filter, which ReferencePopulation to fetch.
     */
    where: ReferencePopulationWhereUniqueInput
  }

  /**
   * ReferencePopulation findFirst
   */
  export type ReferencePopulationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferencePopulation
     */
    select?: ReferencePopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferencePopulation
     */
    omit?: ReferencePopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferencePopulationInclude<ExtArgs> | null
    /**
     * Filter, which ReferencePopulation to fetch.
     */
    where?: ReferencePopulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferencePopulations to fetch.
     */
    orderBy?: ReferencePopulationOrderByWithRelationInput | ReferencePopulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferencePopulations.
     */
    cursor?: ReferencePopulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferencePopulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferencePopulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferencePopulations.
     */
    distinct?: ReferencePopulationScalarFieldEnum | ReferencePopulationScalarFieldEnum[]
  }

  /**
   * ReferencePopulation findFirstOrThrow
   */
  export type ReferencePopulationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferencePopulation
     */
    select?: ReferencePopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferencePopulation
     */
    omit?: ReferencePopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferencePopulationInclude<ExtArgs> | null
    /**
     * Filter, which ReferencePopulation to fetch.
     */
    where?: ReferencePopulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferencePopulations to fetch.
     */
    orderBy?: ReferencePopulationOrderByWithRelationInput | ReferencePopulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferencePopulations.
     */
    cursor?: ReferencePopulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferencePopulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferencePopulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferencePopulations.
     */
    distinct?: ReferencePopulationScalarFieldEnum | ReferencePopulationScalarFieldEnum[]
  }

  /**
   * ReferencePopulation findMany
   */
  export type ReferencePopulationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferencePopulation
     */
    select?: ReferencePopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferencePopulation
     */
    omit?: ReferencePopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferencePopulationInclude<ExtArgs> | null
    /**
     * Filter, which ReferencePopulations to fetch.
     */
    where?: ReferencePopulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferencePopulations to fetch.
     */
    orderBy?: ReferencePopulationOrderByWithRelationInput | ReferencePopulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferencePopulations.
     */
    cursor?: ReferencePopulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferencePopulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferencePopulations.
     */
    skip?: number
    distinct?: ReferencePopulationScalarFieldEnum | ReferencePopulationScalarFieldEnum[]
  }

  /**
   * ReferencePopulation create
   */
  export type ReferencePopulationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferencePopulation
     */
    select?: ReferencePopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferencePopulation
     */
    omit?: ReferencePopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferencePopulationInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferencePopulation.
     */
    data: XOR<ReferencePopulationCreateInput, ReferencePopulationUncheckedCreateInput>
  }

  /**
   * ReferencePopulation createMany
   */
  export type ReferencePopulationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferencePopulations.
     */
    data: ReferencePopulationCreateManyInput | ReferencePopulationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferencePopulation update
   */
  export type ReferencePopulationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferencePopulation
     */
    select?: ReferencePopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferencePopulation
     */
    omit?: ReferencePopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferencePopulationInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferencePopulation.
     */
    data: XOR<ReferencePopulationUpdateInput, ReferencePopulationUncheckedUpdateInput>
    /**
     * Choose, which ReferencePopulation to update.
     */
    where: ReferencePopulationWhereUniqueInput
  }

  /**
   * ReferencePopulation updateMany
   */
  export type ReferencePopulationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferencePopulations.
     */
    data: XOR<ReferencePopulationUpdateManyMutationInput, ReferencePopulationUncheckedUpdateManyInput>
    /**
     * Filter which ReferencePopulations to update
     */
    where?: ReferencePopulationWhereInput
    /**
     * Limit how many ReferencePopulations to update.
     */
    limit?: number
  }

  /**
   * ReferencePopulation upsert
   */
  export type ReferencePopulationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferencePopulation
     */
    select?: ReferencePopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferencePopulation
     */
    omit?: ReferencePopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferencePopulationInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferencePopulation to update in case it exists.
     */
    where: ReferencePopulationWhereUniqueInput
    /**
     * In case the ReferencePopulation found by the `where` argument doesn't exist, create a new ReferencePopulation with this data.
     */
    create: XOR<ReferencePopulationCreateInput, ReferencePopulationUncheckedCreateInput>
    /**
     * In case the ReferencePopulation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferencePopulationUpdateInput, ReferencePopulationUncheckedUpdateInput>
  }

  /**
   * ReferencePopulation delete
   */
  export type ReferencePopulationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferencePopulation
     */
    select?: ReferencePopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferencePopulation
     */
    omit?: ReferencePopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferencePopulationInclude<ExtArgs> | null
    /**
     * Filter which ReferencePopulation to delete.
     */
    where: ReferencePopulationWhereUniqueInput
  }

  /**
   * ReferencePopulation deleteMany
   */
  export type ReferencePopulationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferencePopulations to delete
     */
    where?: ReferencePopulationWhereInput
    /**
     * Limit how many ReferencePopulations to delete.
     */
    limit?: number
  }

  /**
   * ReferencePopulation.broadAncestryCategories
   */
  export type ReferencePopulation$broadAncestryCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadAncestryInRefPop
     */
    select?: BroadAncestryInRefPopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadAncestryInRefPop
     */
    omit?: BroadAncestryInRefPopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadAncestryInRefPopInclude<ExtArgs> | null
    where?: BroadAncestryInRefPopWhereInput
    orderBy?: BroadAncestryInRefPopOrderByWithRelationInput | BroadAncestryInRefPopOrderByWithRelationInput[]
    cursor?: BroadAncestryInRefPopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BroadAncestryInRefPopScalarFieldEnum | BroadAncestryInRefPopScalarFieldEnum[]
  }

  /**
   * ReferencePopulation.prsAnalyses
   */
  export type ReferencePopulation$prsAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSAnalysis
     */
    select?: PRSAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSAnalysis
     */
    omit?: PRSAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSAnalysisInclude<ExtArgs> | null
    where?: PRSAnalysisWhereInput
    orderBy?: PRSAnalysisOrderByWithRelationInput | PRSAnalysisOrderByWithRelationInput[]
    cursor?: PRSAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PRSAnalysisScalarFieldEnum | PRSAnalysisScalarFieldEnum[]
  }

  /**
   * ReferencePopulation without action
   */
  export type ReferencePopulationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferencePopulation
     */
    select?: ReferencePopulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferencePopulation
     */
    omit?: ReferencePopulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferencePopulationInclude<ExtArgs> | null
  }


  /**
   * Model PRSAnalysis
   */

  export type AggregatePRSAnalysis = {
    _count: PRSAnalysisCountAggregateOutputType | null
    _avg: PRSAnalysisAvgAggregateOutputType | null
    _sum: PRSAnalysisSumAggregateOutputType | null
    _min: PRSAnalysisMinAggregateOutputType | null
    _max: PRSAnalysisMaxAggregateOutputType | null
  }

  export type PRSAnalysisAvgAggregateOutputType = {
    id: number | null
    ancestryThreshold: number | null
    overlapThreshold: number | null
    patientId: number | null
    referencePopulationId: number | null
  }

  export type PRSAnalysisSumAggregateOutputType = {
    id: number | null
    ancestryThreshold: number | null
    overlapThreshold: number | null
    patientId: number | null
    referencePopulationId: number | null
  }

  export type PRSAnalysisMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    userId: string | null
    date: string | null
    status: string | null
    HTMLResultPath: string | null
    ancestryThreshold: number | null
    overlapThreshold: number | null
    ancestryAdjustment: $Enums.AncestryAdjustmentType | null
    assembly: $Enums.AssemblyType | null
    patientId: number | null
    referencePopulationId: number | null
  }

  export type PRSAnalysisMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    userId: string | null
    date: string | null
    status: string | null
    HTMLResultPath: string | null
    ancestryThreshold: number | null
    overlapThreshold: number | null
    ancestryAdjustment: $Enums.AncestryAdjustmentType | null
    assembly: $Enums.AssemblyType | null
    patientId: number | null
    referencePopulationId: number | null
  }

  export type PRSAnalysisCountAggregateOutputType = {
    id: number
    name: number
    description: number
    userId: number
    date: number
    status: number
    HTMLResultPath: number
    ancestryThreshold: number
    overlapThreshold: number
    ancestryAdjustment: number
    assembly: number
    patientId: number
    referencePopulationId: number
    _all: number
  }


  export type PRSAnalysisAvgAggregateInputType = {
    id?: true
    ancestryThreshold?: true
    overlapThreshold?: true
    patientId?: true
    referencePopulationId?: true
  }

  export type PRSAnalysisSumAggregateInputType = {
    id?: true
    ancestryThreshold?: true
    overlapThreshold?: true
    patientId?: true
    referencePopulationId?: true
  }

  export type PRSAnalysisMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    date?: true
    status?: true
    HTMLResultPath?: true
    ancestryThreshold?: true
    overlapThreshold?: true
    ancestryAdjustment?: true
    assembly?: true
    patientId?: true
    referencePopulationId?: true
  }

  export type PRSAnalysisMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    date?: true
    status?: true
    HTMLResultPath?: true
    ancestryThreshold?: true
    overlapThreshold?: true
    ancestryAdjustment?: true
    assembly?: true
    patientId?: true
    referencePopulationId?: true
  }

  export type PRSAnalysisCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    date?: true
    status?: true
    HTMLResultPath?: true
    ancestryThreshold?: true
    overlapThreshold?: true
    ancestryAdjustment?: true
    assembly?: true
    patientId?: true
    referencePopulationId?: true
    _all?: true
  }

  export type PRSAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PRSAnalysis to aggregate.
     */
    where?: PRSAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRSAnalyses to fetch.
     */
    orderBy?: PRSAnalysisOrderByWithRelationInput | PRSAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PRSAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRSAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRSAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PRSAnalyses
    **/
    _count?: true | PRSAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PRSAnalysisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PRSAnalysisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PRSAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PRSAnalysisMaxAggregateInputType
  }

  export type GetPRSAnalysisAggregateType<T extends PRSAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregatePRSAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePRSAnalysis[P]>
      : GetScalarType<T[P], AggregatePRSAnalysis[P]>
  }




  export type PRSAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PRSAnalysisWhereInput
    orderBy?: PRSAnalysisOrderByWithAggregationInput | PRSAnalysisOrderByWithAggregationInput[]
    by: PRSAnalysisScalarFieldEnum[] | PRSAnalysisScalarFieldEnum
    having?: PRSAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PRSAnalysisCountAggregateInputType | true
    _avg?: PRSAnalysisAvgAggregateInputType
    _sum?: PRSAnalysisSumAggregateInputType
    _min?: PRSAnalysisMinAggregateInputType
    _max?: PRSAnalysisMaxAggregateInputType
  }

  export type PRSAnalysisGroupByOutputType = {
    id: number
    name: string
    description: string | null
    userId: string | null
    date: string
    status: string
    HTMLResultPath: string
    ancestryThreshold: number
    overlapThreshold: number
    ancestryAdjustment: $Enums.AncestryAdjustmentType
    assembly: $Enums.AssemblyType
    patientId: number
    referencePopulationId: number
    _count: PRSAnalysisCountAggregateOutputType | null
    _avg: PRSAnalysisAvgAggregateOutputType | null
    _sum: PRSAnalysisSumAggregateOutputType | null
    _min: PRSAnalysisMinAggregateOutputType | null
    _max: PRSAnalysisMaxAggregateOutputType | null
  }

  type GetPRSAnalysisGroupByPayload<T extends PRSAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PRSAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PRSAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PRSAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], PRSAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type PRSAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    date?: boolean
    status?: boolean
    HTMLResultPath?: boolean
    ancestryThreshold?: boolean
    overlapThreshold?: boolean
    ancestryAdjustment?: boolean
    assembly?: boolean
    patientId?: boolean
    referencePopulationId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    referencePopulation?: boolean | ReferencePopulationDefaultArgs<ExtArgs>
    prioritizedModels?: boolean | PRSAnalysis$prioritizedModelsArgs<ExtArgs>
    _count?: boolean | PRSAnalysisCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pRSAnalysis"]>



  export type PRSAnalysisSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    date?: boolean
    status?: boolean
    HTMLResultPath?: boolean
    ancestryThreshold?: boolean
    overlapThreshold?: boolean
    ancestryAdjustment?: boolean
    assembly?: boolean
    patientId?: boolean
    referencePopulationId?: boolean
  }

  export type PRSAnalysisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "userId" | "date" | "status" | "HTMLResultPath" | "ancestryThreshold" | "overlapThreshold" | "ancestryAdjustment" | "assembly" | "patientId" | "referencePopulationId", ExtArgs["result"]["pRSAnalysis"]>
  export type PRSAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    referencePopulation?: boolean | ReferencePopulationDefaultArgs<ExtArgs>
    prioritizedModels?: boolean | PRSAnalysis$prioritizedModelsArgs<ExtArgs>
    _count?: boolean | PRSAnalysisCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PRSAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PRSAnalysis"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      referencePopulation: Prisma.$ReferencePopulationPayload<ExtArgs>
      prioritizedModels: Prisma.$PrioritizedModelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      userId: string | null
      date: string
      status: string
      HTMLResultPath: string
      ancestryThreshold: number
      overlapThreshold: number
      ancestryAdjustment: $Enums.AncestryAdjustmentType
      assembly: $Enums.AssemblyType
      patientId: number
      referencePopulationId: number
    }, ExtArgs["result"]["pRSAnalysis"]>
    composites: {}
  }

  type PRSAnalysisGetPayload<S extends boolean | null | undefined | PRSAnalysisDefaultArgs> = $Result.GetResult<Prisma.$PRSAnalysisPayload, S>

  type PRSAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PRSAnalysisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PRSAnalysisCountAggregateInputType | true
    }

  export interface PRSAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PRSAnalysis'], meta: { name: 'PRSAnalysis' } }
    /**
     * Find zero or one PRSAnalysis that matches the filter.
     * @param {PRSAnalysisFindUniqueArgs} args - Arguments to find a PRSAnalysis
     * @example
     * // Get one PRSAnalysis
     * const pRSAnalysis = await prisma.pRSAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PRSAnalysisFindUniqueArgs>(args: SelectSubset<T, PRSAnalysisFindUniqueArgs<ExtArgs>>): Prisma__PRSAnalysisClient<$Result.GetResult<Prisma.$PRSAnalysisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PRSAnalysis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PRSAnalysisFindUniqueOrThrowArgs} args - Arguments to find a PRSAnalysis
     * @example
     * // Get one PRSAnalysis
     * const pRSAnalysis = await prisma.pRSAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PRSAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, PRSAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PRSAnalysisClient<$Result.GetResult<Prisma.$PRSAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PRSAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSAnalysisFindFirstArgs} args - Arguments to find a PRSAnalysis
     * @example
     * // Get one PRSAnalysis
     * const pRSAnalysis = await prisma.pRSAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PRSAnalysisFindFirstArgs>(args?: SelectSubset<T, PRSAnalysisFindFirstArgs<ExtArgs>>): Prisma__PRSAnalysisClient<$Result.GetResult<Prisma.$PRSAnalysisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PRSAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSAnalysisFindFirstOrThrowArgs} args - Arguments to find a PRSAnalysis
     * @example
     * // Get one PRSAnalysis
     * const pRSAnalysis = await prisma.pRSAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PRSAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, PRSAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__PRSAnalysisClient<$Result.GetResult<Prisma.$PRSAnalysisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PRSAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PRSAnalyses
     * const pRSAnalyses = await prisma.pRSAnalysis.findMany()
     * 
     * // Get first 10 PRSAnalyses
     * const pRSAnalyses = await prisma.pRSAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pRSAnalysisWithIdOnly = await prisma.pRSAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PRSAnalysisFindManyArgs>(args?: SelectSubset<T, PRSAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PRSAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PRSAnalysis.
     * @param {PRSAnalysisCreateArgs} args - Arguments to create a PRSAnalysis.
     * @example
     * // Create one PRSAnalysis
     * const PRSAnalysis = await prisma.pRSAnalysis.create({
     *   data: {
     *     // ... data to create a PRSAnalysis
     *   }
     * })
     * 
     */
    create<T extends PRSAnalysisCreateArgs>(args: SelectSubset<T, PRSAnalysisCreateArgs<ExtArgs>>): Prisma__PRSAnalysisClient<$Result.GetResult<Prisma.$PRSAnalysisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PRSAnalyses.
     * @param {PRSAnalysisCreateManyArgs} args - Arguments to create many PRSAnalyses.
     * @example
     * // Create many PRSAnalyses
     * const pRSAnalysis = await prisma.pRSAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PRSAnalysisCreateManyArgs>(args?: SelectSubset<T, PRSAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PRSAnalysis.
     * @param {PRSAnalysisDeleteArgs} args - Arguments to delete one PRSAnalysis.
     * @example
     * // Delete one PRSAnalysis
     * const PRSAnalysis = await prisma.pRSAnalysis.delete({
     *   where: {
     *     // ... filter to delete one PRSAnalysis
     *   }
     * })
     * 
     */
    delete<T extends PRSAnalysisDeleteArgs>(args: SelectSubset<T, PRSAnalysisDeleteArgs<ExtArgs>>): Prisma__PRSAnalysisClient<$Result.GetResult<Prisma.$PRSAnalysisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PRSAnalysis.
     * @param {PRSAnalysisUpdateArgs} args - Arguments to update one PRSAnalysis.
     * @example
     * // Update one PRSAnalysis
     * const pRSAnalysis = await prisma.pRSAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PRSAnalysisUpdateArgs>(args: SelectSubset<T, PRSAnalysisUpdateArgs<ExtArgs>>): Prisma__PRSAnalysisClient<$Result.GetResult<Prisma.$PRSAnalysisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PRSAnalyses.
     * @param {PRSAnalysisDeleteManyArgs} args - Arguments to filter PRSAnalyses to delete.
     * @example
     * // Delete a few PRSAnalyses
     * const { count } = await prisma.pRSAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PRSAnalysisDeleteManyArgs>(args?: SelectSubset<T, PRSAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PRSAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PRSAnalyses
     * const pRSAnalysis = await prisma.pRSAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PRSAnalysisUpdateManyArgs>(args: SelectSubset<T, PRSAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PRSAnalysis.
     * @param {PRSAnalysisUpsertArgs} args - Arguments to update or create a PRSAnalysis.
     * @example
     * // Update or create a PRSAnalysis
     * const pRSAnalysis = await prisma.pRSAnalysis.upsert({
     *   create: {
     *     // ... data to create a PRSAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PRSAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends PRSAnalysisUpsertArgs>(args: SelectSubset<T, PRSAnalysisUpsertArgs<ExtArgs>>): Prisma__PRSAnalysisClient<$Result.GetResult<Prisma.$PRSAnalysisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PRSAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSAnalysisCountArgs} args - Arguments to filter PRSAnalyses to count.
     * @example
     * // Count the number of PRSAnalyses
     * const count = await prisma.pRSAnalysis.count({
     *   where: {
     *     // ... the filter for the PRSAnalyses we want to count
     *   }
     * })
    **/
    count<T extends PRSAnalysisCountArgs>(
      args?: Subset<T, PRSAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PRSAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PRSAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PRSAnalysisAggregateArgs>(args: Subset<T, PRSAnalysisAggregateArgs>): Prisma.PrismaPromise<GetPRSAnalysisAggregateType<T>>

    /**
     * Group by PRSAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PRSAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PRSAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: PRSAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PRSAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPRSAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PRSAnalysis model
   */
  readonly fields: PRSAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PRSAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PRSAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    referencePopulation<T extends ReferencePopulationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReferencePopulationDefaultArgs<ExtArgs>>): Prisma__ReferencePopulationClient<$Result.GetResult<Prisma.$ReferencePopulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prioritizedModels<T extends PRSAnalysis$prioritizedModelsArgs<ExtArgs> = {}>(args?: Subset<T, PRSAnalysis$prioritizedModelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrioritizedModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PRSAnalysis model
   */
  interface PRSAnalysisFieldRefs {
    readonly id: FieldRef<"PRSAnalysis", 'Int'>
    readonly name: FieldRef<"PRSAnalysis", 'String'>
    readonly description: FieldRef<"PRSAnalysis", 'String'>
    readonly userId: FieldRef<"PRSAnalysis", 'String'>
    readonly date: FieldRef<"PRSAnalysis", 'String'>
    readonly status: FieldRef<"PRSAnalysis", 'String'>
    readonly HTMLResultPath: FieldRef<"PRSAnalysis", 'String'>
    readonly ancestryThreshold: FieldRef<"PRSAnalysis", 'Int'>
    readonly overlapThreshold: FieldRef<"PRSAnalysis", 'Int'>
    readonly ancestryAdjustment: FieldRef<"PRSAnalysis", 'AncestryAdjustmentType'>
    readonly assembly: FieldRef<"PRSAnalysis", 'AssemblyType'>
    readonly patientId: FieldRef<"PRSAnalysis", 'Int'>
    readonly referencePopulationId: FieldRef<"PRSAnalysis", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PRSAnalysis findUnique
   */
  export type PRSAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSAnalysis
     */
    select?: PRSAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSAnalysis
     */
    omit?: PRSAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which PRSAnalysis to fetch.
     */
    where: PRSAnalysisWhereUniqueInput
  }

  /**
   * PRSAnalysis findUniqueOrThrow
   */
  export type PRSAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSAnalysis
     */
    select?: PRSAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSAnalysis
     */
    omit?: PRSAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which PRSAnalysis to fetch.
     */
    where: PRSAnalysisWhereUniqueInput
  }

  /**
   * PRSAnalysis findFirst
   */
  export type PRSAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSAnalysis
     */
    select?: PRSAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSAnalysis
     */
    omit?: PRSAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which PRSAnalysis to fetch.
     */
    where?: PRSAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRSAnalyses to fetch.
     */
    orderBy?: PRSAnalysisOrderByWithRelationInput | PRSAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PRSAnalyses.
     */
    cursor?: PRSAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRSAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRSAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PRSAnalyses.
     */
    distinct?: PRSAnalysisScalarFieldEnum | PRSAnalysisScalarFieldEnum[]
  }

  /**
   * PRSAnalysis findFirstOrThrow
   */
  export type PRSAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSAnalysis
     */
    select?: PRSAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSAnalysis
     */
    omit?: PRSAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which PRSAnalysis to fetch.
     */
    where?: PRSAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRSAnalyses to fetch.
     */
    orderBy?: PRSAnalysisOrderByWithRelationInput | PRSAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PRSAnalyses.
     */
    cursor?: PRSAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRSAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRSAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PRSAnalyses.
     */
    distinct?: PRSAnalysisScalarFieldEnum | PRSAnalysisScalarFieldEnum[]
  }

  /**
   * PRSAnalysis findMany
   */
  export type PRSAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSAnalysis
     */
    select?: PRSAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSAnalysis
     */
    omit?: PRSAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which PRSAnalyses to fetch.
     */
    where?: PRSAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRSAnalyses to fetch.
     */
    orderBy?: PRSAnalysisOrderByWithRelationInput | PRSAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PRSAnalyses.
     */
    cursor?: PRSAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRSAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRSAnalyses.
     */
    skip?: number
    distinct?: PRSAnalysisScalarFieldEnum | PRSAnalysisScalarFieldEnum[]
  }

  /**
   * PRSAnalysis create
   */
  export type PRSAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSAnalysis
     */
    select?: PRSAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSAnalysis
     */
    omit?: PRSAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a PRSAnalysis.
     */
    data: XOR<PRSAnalysisCreateInput, PRSAnalysisUncheckedCreateInput>
  }

  /**
   * PRSAnalysis createMany
   */
  export type PRSAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PRSAnalyses.
     */
    data: PRSAnalysisCreateManyInput | PRSAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PRSAnalysis update
   */
  export type PRSAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSAnalysis
     */
    select?: PRSAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSAnalysis
     */
    omit?: PRSAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a PRSAnalysis.
     */
    data: XOR<PRSAnalysisUpdateInput, PRSAnalysisUncheckedUpdateInput>
    /**
     * Choose, which PRSAnalysis to update.
     */
    where: PRSAnalysisWhereUniqueInput
  }

  /**
   * PRSAnalysis updateMany
   */
  export type PRSAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PRSAnalyses.
     */
    data: XOR<PRSAnalysisUpdateManyMutationInput, PRSAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which PRSAnalyses to update
     */
    where?: PRSAnalysisWhereInput
    /**
     * Limit how many PRSAnalyses to update.
     */
    limit?: number
  }

  /**
   * PRSAnalysis upsert
   */
  export type PRSAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSAnalysis
     */
    select?: PRSAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSAnalysis
     */
    omit?: PRSAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSAnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the PRSAnalysis to update in case it exists.
     */
    where: PRSAnalysisWhereUniqueInput
    /**
     * In case the PRSAnalysis found by the `where` argument doesn't exist, create a new PRSAnalysis with this data.
     */
    create: XOR<PRSAnalysisCreateInput, PRSAnalysisUncheckedCreateInput>
    /**
     * In case the PRSAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PRSAnalysisUpdateInput, PRSAnalysisUncheckedUpdateInput>
  }

  /**
   * PRSAnalysis delete
   */
  export type PRSAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSAnalysis
     */
    select?: PRSAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSAnalysis
     */
    omit?: PRSAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSAnalysisInclude<ExtArgs> | null
    /**
     * Filter which PRSAnalysis to delete.
     */
    where: PRSAnalysisWhereUniqueInput
  }

  /**
   * PRSAnalysis deleteMany
   */
  export type PRSAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PRSAnalyses to delete
     */
    where?: PRSAnalysisWhereInput
    /**
     * Limit how many PRSAnalyses to delete.
     */
    limit?: number
  }

  /**
   * PRSAnalysis.prioritizedModels
   */
  export type PRSAnalysis$prioritizedModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrioritizedModel
     */
    select?: PrioritizedModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrioritizedModel
     */
    omit?: PrioritizedModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrioritizedModelInclude<ExtArgs> | null
    where?: PrioritizedModelWhereInput
    orderBy?: PrioritizedModelOrderByWithRelationInput | PrioritizedModelOrderByWithRelationInput[]
    cursor?: PrioritizedModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrioritizedModelScalarFieldEnum | PrioritizedModelScalarFieldEnum[]
  }

  /**
   * PRSAnalysis without action
   */
  export type PRSAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSAnalysis
     */
    select?: PRSAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSAnalysis
     */
    omit?: PRSAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model PrioritizedModel
   */

  export type AggregatePrioritizedModel = {
    _count: PrioritizedModelCountAggregateOutputType | null
    _avg: PrioritizedModelAvgAggregateOutputType | null
    _sum: PrioritizedModelSumAggregateOutputType | null
    _min: PrioritizedModelMinAggregateOutputType | null
    _max: PrioritizedModelMaxAggregateOutputType | null
  }

  export type PrioritizedModelAvgAggregateOutputType = {
    position: number | null
    prsModelId: number | null
    prsAnalysisId: number | null
    prsResultId: number | null
  }

  export type PrioritizedModelSumAggregateOutputType = {
    position: number | null
    prsModelId: number | null
    prsAnalysisId: number | null
    prsResultId: number | null
  }

  export type PrioritizedModelMinAggregateOutputType = {
    position: number | null
    prsModelId: number | null
    prsAnalysisId: number | null
    prsResultId: number | null
  }

  export type PrioritizedModelMaxAggregateOutputType = {
    position: number | null
    prsModelId: number | null
    prsAnalysisId: number | null
    prsResultId: number | null
  }

  export type PrioritizedModelCountAggregateOutputType = {
    position: number
    prsModelId: number
    prsAnalysisId: number
    prsResultId: number
    _all: number
  }


  export type PrioritizedModelAvgAggregateInputType = {
    position?: true
    prsModelId?: true
    prsAnalysisId?: true
    prsResultId?: true
  }

  export type PrioritizedModelSumAggregateInputType = {
    position?: true
    prsModelId?: true
    prsAnalysisId?: true
    prsResultId?: true
  }

  export type PrioritizedModelMinAggregateInputType = {
    position?: true
    prsModelId?: true
    prsAnalysisId?: true
    prsResultId?: true
  }

  export type PrioritizedModelMaxAggregateInputType = {
    position?: true
    prsModelId?: true
    prsAnalysisId?: true
    prsResultId?: true
  }

  export type PrioritizedModelCountAggregateInputType = {
    position?: true
    prsModelId?: true
    prsAnalysisId?: true
    prsResultId?: true
    _all?: true
  }

  export type PrioritizedModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrioritizedModel to aggregate.
     */
    where?: PrioritizedModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrioritizedModels to fetch.
     */
    orderBy?: PrioritizedModelOrderByWithRelationInput | PrioritizedModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrioritizedModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrioritizedModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrioritizedModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrioritizedModels
    **/
    _count?: true | PrioritizedModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrioritizedModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrioritizedModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrioritizedModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrioritizedModelMaxAggregateInputType
  }

  export type GetPrioritizedModelAggregateType<T extends PrioritizedModelAggregateArgs> = {
        [P in keyof T & keyof AggregatePrioritizedModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrioritizedModel[P]>
      : GetScalarType<T[P], AggregatePrioritizedModel[P]>
  }




  export type PrioritizedModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrioritizedModelWhereInput
    orderBy?: PrioritizedModelOrderByWithAggregationInput | PrioritizedModelOrderByWithAggregationInput[]
    by: PrioritizedModelScalarFieldEnum[] | PrioritizedModelScalarFieldEnum
    having?: PrioritizedModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrioritizedModelCountAggregateInputType | true
    _avg?: PrioritizedModelAvgAggregateInputType
    _sum?: PrioritizedModelSumAggregateInputType
    _min?: PrioritizedModelMinAggregateInputType
    _max?: PrioritizedModelMaxAggregateInputType
  }

  export type PrioritizedModelGroupByOutputType = {
    position: number
    prsModelId: number
    prsAnalysisId: number
    prsResultId: number | null
    _count: PrioritizedModelCountAggregateOutputType | null
    _avg: PrioritizedModelAvgAggregateOutputType | null
    _sum: PrioritizedModelSumAggregateOutputType | null
    _min: PrioritizedModelMinAggregateOutputType | null
    _max: PrioritizedModelMaxAggregateOutputType | null
  }

  type GetPrioritizedModelGroupByPayload<T extends PrioritizedModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrioritizedModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrioritizedModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrioritizedModelGroupByOutputType[P]>
            : GetScalarType<T[P], PrioritizedModelGroupByOutputType[P]>
        }
      >
    >


  export type PrioritizedModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    position?: boolean
    prsModelId?: boolean
    prsAnalysisId?: boolean
    prsResultId?: boolean
    prsResult?: boolean | PrioritizedModel$prsResultArgs<ExtArgs>
    prsAnalysis?: boolean | PRSAnalysisDefaultArgs<ExtArgs>
    prsModel?: boolean | PRSModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prioritizedModel"]>



  export type PrioritizedModelSelectScalar = {
    position?: boolean
    prsModelId?: boolean
    prsAnalysisId?: boolean
    prsResultId?: boolean
  }

  export type PrioritizedModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"position" | "prsModelId" | "prsAnalysisId" | "prsResultId", ExtArgs["result"]["prioritizedModel"]>
  export type PrioritizedModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prsResult?: boolean | PrioritizedModel$prsResultArgs<ExtArgs>
    prsAnalysis?: boolean | PRSAnalysisDefaultArgs<ExtArgs>
    prsModel?: boolean | PRSModelDefaultArgs<ExtArgs>
  }

  export type $PrioritizedModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrioritizedModel"
    objects: {
      prsResult: Prisma.$PRSResultPayload<ExtArgs> | null
      prsAnalysis: Prisma.$PRSAnalysisPayload<ExtArgs>
      prsModel: Prisma.$PRSModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      position: number
      prsModelId: number
      prsAnalysisId: number
      prsResultId: number | null
    }, ExtArgs["result"]["prioritizedModel"]>
    composites: {}
  }

  type PrioritizedModelGetPayload<S extends boolean | null | undefined | PrioritizedModelDefaultArgs> = $Result.GetResult<Prisma.$PrioritizedModelPayload, S>

  type PrioritizedModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrioritizedModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrioritizedModelCountAggregateInputType | true
    }

  export interface PrioritizedModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrioritizedModel'], meta: { name: 'PrioritizedModel' } }
    /**
     * Find zero or one PrioritizedModel that matches the filter.
     * @param {PrioritizedModelFindUniqueArgs} args - Arguments to find a PrioritizedModel
     * @example
     * // Get one PrioritizedModel
     * const prioritizedModel = await prisma.prioritizedModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrioritizedModelFindUniqueArgs>(args: SelectSubset<T, PrioritizedModelFindUniqueArgs<ExtArgs>>): Prisma__PrioritizedModelClient<$Result.GetResult<Prisma.$PrioritizedModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrioritizedModel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrioritizedModelFindUniqueOrThrowArgs} args - Arguments to find a PrioritizedModel
     * @example
     * // Get one PrioritizedModel
     * const prioritizedModel = await prisma.prioritizedModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrioritizedModelFindUniqueOrThrowArgs>(args: SelectSubset<T, PrioritizedModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrioritizedModelClient<$Result.GetResult<Prisma.$PrioritizedModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrioritizedModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrioritizedModelFindFirstArgs} args - Arguments to find a PrioritizedModel
     * @example
     * // Get one PrioritizedModel
     * const prioritizedModel = await prisma.prioritizedModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrioritizedModelFindFirstArgs>(args?: SelectSubset<T, PrioritizedModelFindFirstArgs<ExtArgs>>): Prisma__PrioritizedModelClient<$Result.GetResult<Prisma.$PrioritizedModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrioritizedModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrioritizedModelFindFirstOrThrowArgs} args - Arguments to find a PrioritizedModel
     * @example
     * // Get one PrioritizedModel
     * const prioritizedModel = await prisma.prioritizedModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrioritizedModelFindFirstOrThrowArgs>(args?: SelectSubset<T, PrioritizedModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrioritizedModelClient<$Result.GetResult<Prisma.$PrioritizedModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrioritizedModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrioritizedModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrioritizedModels
     * const prioritizedModels = await prisma.prioritizedModel.findMany()
     * 
     * // Get first 10 PrioritizedModels
     * const prioritizedModels = await prisma.prioritizedModel.findMany({ take: 10 })
     * 
     * // Only select the `position`
     * const prioritizedModelWithPositionOnly = await prisma.prioritizedModel.findMany({ select: { position: true } })
     * 
     */
    findMany<T extends PrioritizedModelFindManyArgs>(args?: SelectSubset<T, PrioritizedModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrioritizedModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrioritizedModel.
     * @param {PrioritizedModelCreateArgs} args - Arguments to create a PrioritizedModel.
     * @example
     * // Create one PrioritizedModel
     * const PrioritizedModel = await prisma.prioritizedModel.create({
     *   data: {
     *     // ... data to create a PrioritizedModel
     *   }
     * })
     * 
     */
    create<T extends PrioritizedModelCreateArgs>(args: SelectSubset<T, PrioritizedModelCreateArgs<ExtArgs>>): Prisma__PrioritizedModelClient<$Result.GetResult<Prisma.$PrioritizedModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrioritizedModels.
     * @param {PrioritizedModelCreateManyArgs} args - Arguments to create many PrioritizedModels.
     * @example
     * // Create many PrioritizedModels
     * const prioritizedModel = await prisma.prioritizedModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrioritizedModelCreateManyArgs>(args?: SelectSubset<T, PrioritizedModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PrioritizedModel.
     * @param {PrioritizedModelDeleteArgs} args - Arguments to delete one PrioritizedModel.
     * @example
     * // Delete one PrioritizedModel
     * const PrioritizedModel = await prisma.prioritizedModel.delete({
     *   where: {
     *     // ... filter to delete one PrioritizedModel
     *   }
     * })
     * 
     */
    delete<T extends PrioritizedModelDeleteArgs>(args: SelectSubset<T, PrioritizedModelDeleteArgs<ExtArgs>>): Prisma__PrioritizedModelClient<$Result.GetResult<Prisma.$PrioritizedModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrioritizedModel.
     * @param {PrioritizedModelUpdateArgs} args - Arguments to update one PrioritizedModel.
     * @example
     * // Update one PrioritizedModel
     * const prioritizedModel = await prisma.prioritizedModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrioritizedModelUpdateArgs>(args: SelectSubset<T, PrioritizedModelUpdateArgs<ExtArgs>>): Prisma__PrioritizedModelClient<$Result.GetResult<Prisma.$PrioritizedModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrioritizedModels.
     * @param {PrioritizedModelDeleteManyArgs} args - Arguments to filter PrioritizedModels to delete.
     * @example
     * // Delete a few PrioritizedModels
     * const { count } = await prisma.prioritizedModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrioritizedModelDeleteManyArgs>(args?: SelectSubset<T, PrioritizedModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrioritizedModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrioritizedModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrioritizedModels
     * const prioritizedModel = await prisma.prioritizedModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrioritizedModelUpdateManyArgs>(args: SelectSubset<T, PrioritizedModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PrioritizedModel.
     * @param {PrioritizedModelUpsertArgs} args - Arguments to update or create a PrioritizedModel.
     * @example
     * // Update or create a PrioritizedModel
     * const prioritizedModel = await prisma.prioritizedModel.upsert({
     *   create: {
     *     // ... data to create a PrioritizedModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrioritizedModel we want to update
     *   }
     * })
     */
    upsert<T extends PrioritizedModelUpsertArgs>(args: SelectSubset<T, PrioritizedModelUpsertArgs<ExtArgs>>): Prisma__PrioritizedModelClient<$Result.GetResult<Prisma.$PrioritizedModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrioritizedModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrioritizedModelCountArgs} args - Arguments to filter PrioritizedModels to count.
     * @example
     * // Count the number of PrioritizedModels
     * const count = await prisma.prioritizedModel.count({
     *   where: {
     *     // ... the filter for the PrioritizedModels we want to count
     *   }
     * })
    **/
    count<T extends PrioritizedModelCountArgs>(
      args?: Subset<T, PrioritizedModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrioritizedModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrioritizedModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrioritizedModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrioritizedModelAggregateArgs>(args: Subset<T, PrioritizedModelAggregateArgs>): Prisma.PrismaPromise<GetPrioritizedModelAggregateType<T>>

    /**
     * Group by PrioritizedModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrioritizedModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrioritizedModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrioritizedModelGroupByArgs['orderBy'] }
        : { orderBy?: PrioritizedModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrioritizedModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrioritizedModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrioritizedModel model
   */
  readonly fields: PrioritizedModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrioritizedModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrioritizedModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prsResult<T extends PrioritizedModel$prsResultArgs<ExtArgs> = {}>(args?: Subset<T, PrioritizedModel$prsResultArgs<ExtArgs>>): Prisma__PRSResultClient<$Result.GetResult<Prisma.$PRSResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    prsAnalysis<T extends PRSAnalysisDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PRSAnalysisDefaultArgs<ExtArgs>>): Prisma__PRSAnalysisClient<$Result.GetResult<Prisma.$PRSAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prsModel<T extends PRSModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PRSModelDefaultArgs<ExtArgs>>): Prisma__PRSModelClient<$Result.GetResult<Prisma.$PRSModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrioritizedModel model
   */
  interface PrioritizedModelFieldRefs {
    readonly position: FieldRef<"PrioritizedModel", 'Int'>
    readonly prsModelId: FieldRef<"PrioritizedModel", 'Int'>
    readonly prsAnalysisId: FieldRef<"PrioritizedModel", 'Int'>
    readonly prsResultId: FieldRef<"PrioritizedModel", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PrioritizedModel findUnique
   */
  export type PrioritizedModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrioritizedModel
     */
    select?: PrioritizedModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrioritizedModel
     */
    omit?: PrioritizedModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrioritizedModelInclude<ExtArgs> | null
    /**
     * Filter, which PrioritizedModel to fetch.
     */
    where: PrioritizedModelWhereUniqueInput
  }

  /**
   * PrioritizedModel findUniqueOrThrow
   */
  export type PrioritizedModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrioritizedModel
     */
    select?: PrioritizedModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrioritizedModel
     */
    omit?: PrioritizedModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrioritizedModelInclude<ExtArgs> | null
    /**
     * Filter, which PrioritizedModel to fetch.
     */
    where: PrioritizedModelWhereUniqueInput
  }

  /**
   * PrioritizedModel findFirst
   */
  export type PrioritizedModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrioritizedModel
     */
    select?: PrioritizedModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrioritizedModel
     */
    omit?: PrioritizedModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrioritizedModelInclude<ExtArgs> | null
    /**
     * Filter, which PrioritizedModel to fetch.
     */
    where?: PrioritizedModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrioritizedModels to fetch.
     */
    orderBy?: PrioritizedModelOrderByWithRelationInput | PrioritizedModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrioritizedModels.
     */
    cursor?: PrioritizedModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrioritizedModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrioritizedModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrioritizedModels.
     */
    distinct?: PrioritizedModelScalarFieldEnum | PrioritizedModelScalarFieldEnum[]
  }

  /**
   * PrioritizedModel findFirstOrThrow
   */
  export type PrioritizedModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrioritizedModel
     */
    select?: PrioritizedModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrioritizedModel
     */
    omit?: PrioritizedModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrioritizedModelInclude<ExtArgs> | null
    /**
     * Filter, which PrioritizedModel to fetch.
     */
    where?: PrioritizedModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrioritizedModels to fetch.
     */
    orderBy?: PrioritizedModelOrderByWithRelationInput | PrioritizedModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrioritizedModels.
     */
    cursor?: PrioritizedModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrioritizedModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrioritizedModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrioritizedModels.
     */
    distinct?: PrioritizedModelScalarFieldEnum | PrioritizedModelScalarFieldEnum[]
  }

  /**
   * PrioritizedModel findMany
   */
  export type PrioritizedModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrioritizedModel
     */
    select?: PrioritizedModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrioritizedModel
     */
    omit?: PrioritizedModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrioritizedModelInclude<ExtArgs> | null
    /**
     * Filter, which PrioritizedModels to fetch.
     */
    where?: PrioritizedModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrioritizedModels to fetch.
     */
    orderBy?: PrioritizedModelOrderByWithRelationInput | PrioritizedModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrioritizedModels.
     */
    cursor?: PrioritizedModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrioritizedModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrioritizedModels.
     */
    skip?: number
    distinct?: PrioritizedModelScalarFieldEnum | PrioritizedModelScalarFieldEnum[]
  }

  /**
   * PrioritizedModel create
   */
  export type PrioritizedModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrioritizedModel
     */
    select?: PrioritizedModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrioritizedModel
     */
    omit?: PrioritizedModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrioritizedModelInclude<ExtArgs> | null
    /**
     * The data needed to create a PrioritizedModel.
     */
    data: XOR<PrioritizedModelCreateInput, PrioritizedModelUncheckedCreateInput>
  }

  /**
   * PrioritizedModel createMany
   */
  export type PrioritizedModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrioritizedModels.
     */
    data: PrioritizedModelCreateManyInput | PrioritizedModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrioritizedModel update
   */
  export type PrioritizedModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrioritizedModel
     */
    select?: PrioritizedModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrioritizedModel
     */
    omit?: PrioritizedModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrioritizedModelInclude<ExtArgs> | null
    /**
     * The data needed to update a PrioritizedModel.
     */
    data: XOR<PrioritizedModelUpdateInput, PrioritizedModelUncheckedUpdateInput>
    /**
     * Choose, which PrioritizedModel to update.
     */
    where: PrioritizedModelWhereUniqueInput
  }

  /**
   * PrioritizedModel updateMany
   */
  export type PrioritizedModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrioritizedModels.
     */
    data: XOR<PrioritizedModelUpdateManyMutationInput, PrioritizedModelUncheckedUpdateManyInput>
    /**
     * Filter which PrioritizedModels to update
     */
    where?: PrioritizedModelWhereInput
    /**
     * Limit how many PrioritizedModels to update.
     */
    limit?: number
  }

  /**
   * PrioritizedModel upsert
   */
  export type PrioritizedModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrioritizedModel
     */
    select?: PrioritizedModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrioritizedModel
     */
    omit?: PrioritizedModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrioritizedModelInclude<ExtArgs> | null
    /**
     * The filter to search for the PrioritizedModel to update in case it exists.
     */
    where: PrioritizedModelWhereUniqueInput
    /**
     * In case the PrioritizedModel found by the `where` argument doesn't exist, create a new PrioritizedModel with this data.
     */
    create: XOR<PrioritizedModelCreateInput, PrioritizedModelUncheckedCreateInput>
    /**
     * In case the PrioritizedModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrioritizedModelUpdateInput, PrioritizedModelUncheckedUpdateInput>
  }

  /**
   * PrioritizedModel delete
   */
  export type PrioritizedModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrioritizedModel
     */
    select?: PrioritizedModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrioritizedModel
     */
    omit?: PrioritizedModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrioritizedModelInclude<ExtArgs> | null
    /**
     * Filter which PrioritizedModel to delete.
     */
    where: PrioritizedModelWhereUniqueInput
  }

  /**
   * PrioritizedModel deleteMany
   */
  export type PrioritizedModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrioritizedModels to delete
     */
    where?: PrioritizedModelWhereInput
    /**
     * Limit how many PrioritizedModels to delete.
     */
    limit?: number
  }

  /**
   * PrioritizedModel.prsResult
   */
  export type PrioritizedModel$prsResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSResult
     */
    select?: PRSResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSResult
     */
    omit?: PRSResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSResultInclude<ExtArgs> | null
    where?: PRSResultWhereInput
  }

  /**
   * PrioritizedModel without action
   */
  export type PrioritizedModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrioritizedModel
     */
    select?: PrioritizedModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrioritizedModel
     */
    omit?: PrioritizedModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrioritizedModelInclude<ExtArgs> | null
  }


  /**
   * Model PRSResult
   */

  export type AggregatePRSResult = {
    _count: PRSResultCountAggregateOutputType | null
    _avg: PRSResultAvgAggregateOutputType | null
    _sum: PRSResultSumAggregateOutputType | null
    _min: PRSResultMinAggregateOutputType | null
    _max: PRSResultMaxAggregateOutputType | null
  }

  export type PRSResultAvgAggregateOutputType = {
    id: number | null
    prs: number | null
    overlapPercent: number | null
    prsModelId: number | null
    prsAnalysisId: number | null
  }

  export type PRSResultSumAggregateOutputType = {
    id: number | null
    prs: number | null
    overlapPercent: number | null
    prsModelId: number | null
    prsAnalysisId: number | null
  }

  export type PRSResultMinAggregateOutputType = {
    id: number | null
    prs: number | null
    percentile: string | null
    overlapPercent: number | null
    prsModelId: number | null
    prsAnalysisId: number | null
  }

  export type PRSResultMaxAggregateOutputType = {
    id: number | null
    prs: number | null
    percentile: string | null
    overlapPercent: number | null
    prsModelId: number | null
    prsAnalysisId: number | null
  }

  export type PRSResultCountAggregateOutputType = {
    id: number
    prs: number
    percentile: number
    overlapPercent: number
    prsModelId: number
    prsAnalysisId: number
    _all: number
  }


  export type PRSResultAvgAggregateInputType = {
    id?: true
    prs?: true
    overlapPercent?: true
    prsModelId?: true
    prsAnalysisId?: true
  }

  export type PRSResultSumAggregateInputType = {
    id?: true
    prs?: true
    overlapPercent?: true
    prsModelId?: true
    prsAnalysisId?: true
  }

  export type PRSResultMinAggregateInputType = {
    id?: true
    prs?: true
    percentile?: true
    overlapPercent?: true
    prsModelId?: true
    prsAnalysisId?: true
  }

  export type PRSResultMaxAggregateInputType = {
    id?: true
    prs?: true
    percentile?: true
    overlapPercent?: true
    prsModelId?: true
    prsAnalysisId?: true
  }

  export type PRSResultCountAggregateInputType = {
    id?: true
    prs?: true
    percentile?: true
    overlapPercent?: true
    prsModelId?: true
    prsAnalysisId?: true
    _all?: true
  }

  export type PRSResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PRSResult to aggregate.
     */
    where?: PRSResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRSResults to fetch.
     */
    orderBy?: PRSResultOrderByWithRelationInput | PRSResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PRSResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRSResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRSResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PRSResults
    **/
    _count?: true | PRSResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PRSResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PRSResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PRSResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PRSResultMaxAggregateInputType
  }

  export type GetPRSResultAggregateType<T extends PRSResultAggregateArgs> = {
        [P in keyof T & keyof AggregatePRSResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePRSResult[P]>
      : GetScalarType<T[P], AggregatePRSResult[P]>
  }




  export type PRSResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PRSResultWhereInput
    orderBy?: PRSResultOrderByWithAggregationInput | PRSResultOrderByWithAggregationInput[]
    by: PRSResultScalarFieldEnum[] | PRSResultScalarFieldEnum
    having?: PRSResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PRSResultCountAggregateInputType | true
    _avg?: PRSResultAvgAggregateInputType
    _sum?: PRSResultSumAggregateInputType
    _min?: PRSResultMinAggregateInputType
    _max?: PRSResultMaxAggregateInputType
  }

  export type PRSResultGroupByOutputType = {
    id: number
    prs: number
    percentile: string
    overlapPercent: number
    prsModelId: number
    prsAnalysisId: number
    _count: PRSResultCountAggregateOutputType | null
    _avg: PRSResultAvgAggregateOutputType | null
    _sum: PRSResultSumAggregateOutputType | null
    _min: PRSResultMinAggregateOutputType | null
    _max: PRSResultMaxAggregateOutputType | null
  }

  type GetPRSResultGroupByPayload<T extends PRSResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PRSResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PRSResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PRSResultGroupByOutputType[P]>
            : GetScalarType<T[P], PRSResultGroupByOutputType[P]>
        }
      >
    >


  export type PRSResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prs?: boolean
    percentile?: boolean
    overlapPercent?: boolean
    prsModelId?: boolean
    prsAnalysisId?: boolean
    prioritizedModel?: boolean | PrioritizedModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pRSResult"]>



  export type PRSResultSelectScalar = {
    id?: boolean
    prs?: boolean
    percentile?: boolean
    overlapPercent?: boolean
    prsModelId?: boolean
    prsAnalysisId?: boolean
  }

  export type PRSResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prs" | "percentile" | "overlapPercent" | "prsModelId" | "prsAnalysisId", ExtArgs["result"]["pRSResult"]>
  export type PRSResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prioritizedModel?: boolean | PrioritizedModelDefaultArgs<ExtArgs>
  }

  export type $PRSResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PRSResult"
    objects: {
      prioritizedModel: Prisma.$PrioritizedModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      prs: number
      percentile: string
      overlapPercent: number
      prsModelId: number
      prsAnalysisId: number
    }, ExtArgs["result"]["pRSResult"]>
    composites: {}
  }

  type PRSResultGetPayload<S extends boolean | null | undefined | PRSResultDefaultArgs> = $Result.GetResult<Prisma.$PRSResultPayload, S>

  type PRSResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PRSResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PRSResultCountAggregateInputType | true
    }

  export interface PRSResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PRSResult'], meta: { name: 'PRSResult' } }
    /**
     * Find zero or one PRSResult that matches the filter.
     * @param {PRSResultFindUniqueArgs} args - Arguments to find a PRSResult
     * @example
     * // Get one PRSResult
     * const pRSResult = await prisma.pRSResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PRSResultFindUniqueArgs>(args: SelectSubset<T, PRSResultFindUniqueArgs<ExtArgs>>): Prisma__PRSResultClient<$Result.GetResult<Prisma.$PRSResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PRSResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PRSResultFindUniqueOrThrowArgs} args - Arguments to find a PRSResult
     * @example
     * // Get one PRSResult
     * const pRSResult = await prisma.pRSResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PRSResultFindUniqueOrThrowArgs>(args: SelectSubset<T, PRSResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PRSResultClient<$Result.GetResult<Prisma.$PRSResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PRSResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSResultFindFirstArgs} args - Arguments to find a PRSResult
     * @example
     * // Get one PRSResult
     * const pRSResult = await prisma.pRSResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PRSResultFindFirstArgs>(args?: SelectSubset<T, PRSResultFindFirstArgs<ExtArgs>>): Prisma__PRSResultClient<$Result.GetResult<Prisma.$PRSResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PRSResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSResultFindFirstOrThrowArgs} args - Arguments to find a PRSResult
     * @example
     * // Get one PRSResult
     * const pRSResult = await prisma.pRSResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PRSResultFindFirstOrThrowArgs>(args?: SelectSubset<T, PRSResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__PRSResultClient<$Result.GetResult<Prisma.$PRSResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PRSResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PRSResults
     * const pRSResults = await prisma.pRSResult.findMany()
     * 
     * // Get first 10 PRSResults
     * const pRSResults = await prisma.pRSResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pRSResultWithIdOnly = await prisma.pRSResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PRSResultFindManyArgs>(args?: SelectSubset<T, PRSResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PRSResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PRSResult.
     * @param {PRSResultCreateArgs} args - Arguments to create a PRSResult.
     * @example
     * // Create one PRSResult
     * const PRSResult = await prisma.pRSResult.create({
     *   data: {
     *     // ... data to create a PRSResult
     *   }
     * })
     * 
     */
    create<T extends PRSResultCreateArgs>(args: SelectSubset<T, PRSResultCreateArgs<ExtArgs>>): Prisma__PRSResultClient<$Result.GetResult<Prisma.$PRSResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PRSResults.
     * @param {PRSResultCreateManyArgs} args - Arguments to create many PRSResults.
     * @example
     * // Create many PRSResults
     * const pRSResult = await prisma.pRSResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PRSResultCreateManyArgs>(args?: SelectSubset<T, PRSResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PRSResult.
     * @param {PRSResultDeleteArgs} args - Arguments to delete one PRSResult.
     * @example
     * // Delete one PRSResult
     * const PRSResult = await prisma.pRSResult.delete({
     *   where: {
     *     // ... filter to delete one PRSResult
     *   }
     * })
     * 
     */
    delete<T extends PRSResultDeleteArgs>(args: SelectSubset<T, PRSResultDeleteArgs<ExtArgs>>): Prisma__PRSResultClient<$Result.GetResult<Prisma.$PRSResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PRSResult.
     * @param {PRSResultUpdateArgs} args - Arguments to update one PRSResult.
     * @example
     * // Update one PRSResult
     * const pRSResult = await prisma.pRSResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PRSResultUpdateArgs>(args: SelectSubset<T, PRSResultUpdateArgs<ExtArgs>>): Prisma__PRSResultClient<$Result.GetResult<Prisma.$PRSResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PRSResults.
     * @param {PRSResultDeleteManyArgs} args - Arguments to filter PRSResults to delete.
     * @example
     * // Delete a few PRSResults
     * const { count } = await prisma.pRSResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PRSResultDeleteManyArgs>(args?: SelectSubset<T, PRSResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PRSResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PRSResults
     * const pRSResult = await prisma.pRSResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PRSResultUpdateManyArgs>(args: SelectSubset<T, PRSResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PRSResult.
     * @param {PRSResultUpsertArgs} args - Arguments to update or create a PRSResult.
     * @example
     * // Update or create a PRSResult
     * const pRSResult = await prisma.pRSResult.upsert({
     *   create: {
     *     // ... data to create a PRSResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PRSResult we want to update
     *   }
     * })
     */
    upsert<T extends PRSResultUpsertArgs>(args: SelectSubset<T, PRSResultUpsertArgs<ExtArgs>>): Prisma__PRSResultClient<$Result.GetResult<Prisma.$PRSResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PRSResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSResultCountArgs} args - Arguments to filter PRSResults to count.
     * @example
     * // Count the number of PRSResults
     * const count = await prisma.pRSResult.count({
     *   where: {
     *     // ... the filter for the PRSResults we want to count
     *   }
     * })
    **/
    count<T extends PRSResultCountArgs>(
      args?: Subset<T, PRSResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PRSResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PRSResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PRSResultAggregateArgs>(args: Subset<T, PRSResultAggregateArgs>): Prisma.PrismaPromise<GetPRSResultAggregateType<T>>

    /**
     * Group by PRSResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRSResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PRSResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PRSResultGroupByArgs['orderBy'] }
        : { orderBy?: PRSResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PRSResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPRSResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PRSResult model
   */
  readonly fields: PRSResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PRSResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PRSResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prioritizedModel<T extends PrioritizedModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrioritizedModelDefaultArgs<ExtArgs>>): Prisma__PrioritizedModelClient<$Result.GetResult<Prisma.$PrioritizedModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PRSResult model
   */
  interface PRSResultFieldRefs {
    readonly id: FieldRef<"PRSResult", 'Int'>
    readonly prs: FieldRef<"PRSResult", 'Float'>
    readonly percentile: FieldRef<"PRSResult", 'String'>
    readonly overlapPercent: FieldRef<"PRSResult", 'Float'>
    readonly prsModelId: FieldRef<"PRSResult", 'Int'>
    readonly prsAnalysisId: FieldRef<"PRSResult", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PRSResult findUnique
   */
  export type PRSResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSResult
     */
    select?: PRSResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSResult
     */
    omit?: PRSResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSResultInclude<ExtArgs> | null
    /**
     * Filter, which PRSResult to fetch.
     */
    where: PRSResultWhereUniqueInput
  }

  /**
   * PRSResult findUniqueOrThrow
   */
  export type PRSResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSResult
     */
    select?: PRSResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSResult
     */
    omit?: PRSResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSResultInclude<ExtArgs> | null
    /**
     * Filter, which PRSResult to fetch.
     */
    where: PRSResultWhereUniqueInput
  }

  /**
   * PRSResult findFirst
   */
  export type PRSResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSResult
     */
    select?: PRSResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSResult
     */
    omit?: PRSResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSResultInclude<ExtArgs> | null
    /**
     * Filter, which PRSResult to fetch.
     */
    where?: PRSResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRSResults to fetch.
     */
    orderBy?: PRSResultOrderByWithRelationInput | PRSResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PRSResults.
     */
    cursor?: PRSResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRSResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRSResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PRSResults.
     */
    distinct?: PRSResultScalarFieldEnum | PRSResultScalarFieldEnum[]
  }

  /**
   * PRSResult findFirstOrThrow
   */
  export type PRSResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSResult
     */
    select?: PRSResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSResult
     */
    omit?: PRSResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSResultInclude<ExtArgs> | null
    /**
     * Filter, which PRSResult to fetch.
     */
    where?: PRSResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRSResults to fetch.
     */
    orderBy?: PRSResultOrderByWithRelationInput | PRSResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PRSResults.
     */
    cursor?: PRSResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRSResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRSResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PRSResults.
     */
    distinct?: PRSResultScalarFieldEnum | PRSResultScalarFieldEnum[]
  }

  /**
   * PRSResult findMany
   */
  export type PRSResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSResult
     */
    select?: PRSResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSResult
     */
    omit?: PRSResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSResultInclude<ExtArgs> | null
    /**
     * Filter, which PRSResults to fetch.
     */
    where?: PRSResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRSResults to fetch.
     */
    orderBy?: PRSResultOrderByWithRelationInput | PRSResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PRSResults.
     */
    cursor?: PRSResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRSResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRSResults.
     */
    skip?: number
    distinct?: PRSResultScalarFieldEnum | PRSResultScalarFieldEnum[]
  }

  /**
   * PRSResult create
   */
  export type PRSResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSResult
     */
    select?: PRSResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSResult
     */
    omit?: PRSResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSResultInclude<ExtArgs> | null
    /**
     * The data needed to create a PRSResult.
     */
    data: XOR<PRSResultCreateInput, PRSResultUncheckedCreateInput>
  }

  /**
   * PRSResult createMany
   */
  export type PRSResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PRSResults.
     */
    data: PRSResultCreateManyInput | PRSResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PRSResult update
   */
  export type PRSResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSResult
     */
    select?: PRSResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSResult
     */
    omit?: PRSResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSResultInclude<ExtArgs> | null
    /**
     * The data needed to update a PRSResult.
     */
    data: XOR<PRSResultUpdateInput, PRSResultUncheckedUpdateInput>
    /**
     * Choose, which PRSResult to update.
     */
    where: PRSResultWhereUniqueInput
  }

  /**
   * PRSResult updateMany
   */
  export type PRSResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PRSResults.
     */
    data: XOR<PRSResultUpdateManyMutationInput, PRSResultUncheckedUpdateManyInput>
    /**
     * Filter which PRSResults to update
     */
    where?: PRSResultWhereInput
    /**
     * Limit how many PRSResults to update.
     */
    limit?: number
  }

  /**
   * PRSResult upsert
   */
  export type PRSResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSResult
     */
    select?: PRSResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSResult
     */
    omit?: PRSResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSResultInclude<ExtArgs> | null
    /**
     * The filter to search for the PRSResult to update in case it exists.
     */
    where: PRSResultWhereUniqueInput
    /**
     * In case the PRSResult found by the `where` argument doesn't exist, create a new PRSResult with this data.
     */
    create: XOR<PRSResultCreateInput, PRSResultUncheckedCreateInput>
    /**
     * In case the PRSResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PRSResultUpdateInput, PRSResultUncheckedUpdateInput>
  }

  /**
   * PRSResult delete
   */
  export type PRSResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSResult
     */
    select?: PRSResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSResult
     */
    omit?: PRSResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSResultInclude<ExtArgs> | null
    /**
     * Filter which PRSResult to delete.
     */
    where: PRSResultWhereUniqueInput
  }

  /**
   * PRSResult deleteMany
   */
  export type PRSResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PRSResults to delete
     */
    where?: PRSResultWhereInput
    /**
     * Limit how many PRSResults to delete.
     */
    limit?: number
  }

  /**
   * PRSResult without action
   */
  export type PRSResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSResult
     */
    select?: PRSResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSResult
     */
    omit?: PRSResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSResultInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientAvgAggregateOutputType = {
    id: number | null
  }

  export type PatientSumAggregateOutputType = {
    id: number | null
  }

  export type PatientMinAggregateOutputType = {
    id: number | null
    patientId: string | null
    genotypingMethod: string | null
    DataFilePath: string | null
    DataFilteFormat: string | null
  }

  export type PatientMaxAggregateOutputType = {
    id: number | null
    patientId: string | null
    genotypingMethod: string | null
    DataFilePath: string | null
    DataFilteFormat: string | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    patientId: number
    genotypingMethod: number
    DataFilePath: number
    DataFilteFormat: number
    _all: number
  }


  export type PatientAvgAggregateInputType = {
    id?: true
  }

  export type PatientSumAggregateInputType = {
    id?: true
  }

  export type PatientMinAggregateInputType = {
    id?: true
    patientId?: true
    genotypingMethod?: true
    DataFilePath?: true
    DataFilteFormat?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    patientId?: true
    genotypingMethod?: true
    DataFilePath?: true
    DataFilteFormat?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    patientId?: true
    genotypingMethod?: true
    DataFilePath?: true
    DataFilteFormat?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _avg?: PatientAvgAggregateInputType
    _sum?: PatientSumAggregateInputType
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: number
    patientId: string
    genotypingMethod: string | null
    DataFilePath: string
    DataFilteFormat: string
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    genotypingMethod?: boolean
    DataFilePath?: boolean
    DataFilteFormat?: boolean
    prsAnalyses?: boolean | Patient$prsAnalysesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>



  export type PatientSelectScalar = {
    id?: boolean
    patientId?: boolean
    genotypingMethod?: boolean
    DataFilePath?: boolean
    DataFilteFormat?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "genotypingMethod" | "DataFilePath" | "DataFilteFormat", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prsAnalyses?: boolean | Patient$prsAnalysesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      prsAnalyses: Prisma.$PRSAnalysisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: string
      genotypingMethod: string | null
      DataFilePath: string
      DataFilteFormat: string
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prsAnalyses<T extends Patient$prsAnalysesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$prsAnalysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PRSAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'Int'>
    readonly patientId: FieldRef<"Patient", 'String'>
    readonly genotypingMethod: FieldRef<"Patient", 'String'>
    readonly DataFilePath: FieldRef<"Patient", 'String'>
    readonly DataFilteFormat: FieldRef<"Patient", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.prsAnalyses
   */
  export type Patient$prsAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRSAnalysis
     */
    select?: PRSAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRSAnalysis
     */
    omit?: PRSAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRSAnalysisInclude<ExtArgs> | null
    where?: PRSAnalysisWhereInput
    orderBy?: PRSAnalysisOrderByWithRelationInput | PRSAnalysisOrderByWithRelationInput[]
    cursor?: PRSAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PRSAnalysisScalarFieldEnum | PRSAnalysisScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TraitCategoryScalarFieldEnum: {
    id: 'id',
    label: 'label'
  };

  export type TraitCategoryScalarFieldEnum = (typeof TraitCategoryScalarFieldEnum)[keyof typeof TraitCategoryScalarFieldEnum]


  export const TraitScalarFieldEnum: {
    id: 'id',
    label: 'label',
    description: 'description',
    URL: 'URL',
    efoId: 'efoId',
    mondoId: 'mondoId',
    hpoId: 'hpoId',
    orphaId: 'orphaId',
    otherId: 'otherId'
  };

  export type TraitScalarFieldEnum = (typeof TraitScalarFieldEnum)[keyof typeof TraitScalarFieldEnum]


  export const TraitToTraitCategoryScalarFieldEnum: {
    traitId: 'traitId',
    traitCategoryId: 'traitCategoryId'
  };

  export type TraitToTraitCategoryScalarFieldEnum = (typeof TraitToTraitCategoryScalarFieldEnum)[keyof typeof TraitToTraitCategoryScalarFieldEnum]


  export const PRSModelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    numberOfSNP: 'numberOfSNP',
    pgscId: 'pgscId',
    pgscURL: 'pgscURL',
    publicationId: 'publicationId'
  };

  export type PRSModelScalarFieldEnum = (typeof PRSModelScalarFieldEnum)[keyof typeof PRSModelScalarFieldEnum]


  export const PRSModelToTraitScalarFieldEnum: {
    prsModelId: 'prsModelId',
    traitId: 'traitId'
  };

  export type PRSModelToTraitScalarFieldEnum = (typeof PRSModelToTraitScalarFieldEnum)[keyof typeof PRSModelToTraitScalarFieldEnum]


  export const ScoringFileScalarFieldEnum: {
    id: 'id',
    assembly: 'assembly',
    path: 'path',
    prsModelId: 'prsModelId'
  };

  export type ScoringFileScalarFieldEnum = (typeof ScoringFileScalarFieldEnum)[keyof typeof ScoringFileScalarFieldEnum]


  export const PublicationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    journal: 'journal',
    author: 'author',
    date: 'date',
    year: 'year',
    PMID: 'PMID',
    DOI: 'DOI',
    pgpId: 'pgpId'
  };

  export type PublicationScalarFieldEnum = (typeof PublicationScalarFieldEnum)[keyof typeof PublicationScalarFieldEnum]


  export const ModelEvaluationScalarFieldEnum: {
    id: 'id',
    reportedTrait: 'reportedTrait',
    covariates: 'covariates',
    ppmId: 'ppmId',
    prsModelId: 'prsModelId',
    publicationId: 'publicationId',
    evaluationPopulationSampleId: 'evaluationPopulationSampleId'
  };

  export type ModelEvaluationScalarFieldEnum = (typeof ModelEvaluationScalarFieldEnum)[keyof typeof ModelEvaluationScalarFieldEnum]


  export const PerformanceMetricEvaluationScalarFieldEnum: {
    id: 'id',
    estimate: 'estimate',
    CILower: 'CILower',
    CIUpper: 'CIUpper',
    modelEvaluationId: 'modelEvaluationId',
    performanceMetricId: 'performanceMetricId'
  };

  export type PerformanceMetricEvaluationScalarFieldEnum = (typeof PerformanceMetricEvaluationScalarFieldEnum)[keyof typeof PerformanceMetricEvaluationScalarFieldEnum]


  export const PerformanceMetricScalarFieldEnum: {
    id: 'id',
    nameShort: 'nameShort',
    nameLong: 'nameLong',
    type: 'type'
  };

  export type PerformanceMetricScalarFieldEnum = (typeof PerformanceMetricScalarFieldEnum)[keyof typeof PerformanceMetricScalarFieldEnum]


  export const EvaluationPopulationSampleScalarFieldEnum: {
    id: 'id',
    numberOfIndividuals: 'numberOfIndividuals',
    numberOfCases: 'numberOfCases',
    numberOfControls: 'numberOfControls',
    percentMale: 'percentMale',
    age: 'age',
    ageUnits: 'ageUnits',
    ancestryBroad: 'ancestryBroad',
    ancestryDetails: 'ancestryDetails',
    cohort: 'cohort',
    gcId: 'gcId',
    sourcePMID: 'sourcePMID',
    sourceDOI: 'sourceDOI',
    phenotypeFree: 'phenotypeFree',
    pssId: 'pssId',
    broadAncestryId: 'broadAncestryId'
  };

  export type EvaluationPopulationSampleScalarFieldEnum = (typeof EvaluationPopulationSampleScalarFieldEnum)[keyof typeof EvaluationPopulationSampleScalarFieldEnum]


  export const BroadAncestryCategoryScalarFieldEnum: {
    id: 'id',
    symbol: 'symbol',
    label: 'label'
  };

  export type BroadAncestryCategoryScalarFieldEnum = (typeof BroadAncestryCategoryScalarFieldEnum)[keyof typeof BroadAncestryCategoryScalarFieldEnum]


  export const BroadAncestryInModelScalarFieldEnum: {
    percentage: 'percentage',
    broadAncestryId: 'broadAncestryId',
    prsModelId: 'prsModelId'
  };

  export type BroadAncestryInModelScalarFieldEnum = (typeof BroadAncestryInModelScalarFieldEnum)[keyof typeof BroadAncestryInModelScalarFieldEnum]


  export const DevelopmentPopulationSampleScalarFieldEnum: {
    id: 'id',
    numberOfIndividuals: 'numberOfIndividuals',
    numberOfCases: 'numberOfCases',
    numberOfControls: 'numberOfControls',
    percentMale: 'percentMale',
    age: 'age',
    ageUnits: 'ageUnits',
    ancestryBroad: 'ancestryBroad',
    ancestryDetails: 'ancestryDetails',
    cohort: 'cohort',
    gcId: 'gcId',
    sourcePMID: 'sourcePMID',
    sourceDOI: 'sourceDOI',
    role: 'role',
    prsModelId: 'prsModelId',
    broadAncestryId: 'broadAncestryId'
  };

  export type DevelopmentPopulationSampleScalarFieldEnum = (typeof DevelopmentPopulationSampleScalarFieldEnum)[keyof typeof DevelopmentPopulationSampleScalarFieldEnum]


  export const BroadAncestryInRefPopScalarFieldEnum: {
    percentage: 'percentage',
    broadAncestryId: 'broadAncestryId',
    referencePopulationId: 'referencePopulationId'
  };

  export type BroadAncestryInRefPopScalarFieldEnum = (typeof BroadAncestryInRefPopScalarFieldEnum)[keyof typeof BroadAncestryInRefPopScalarFieldEnum]


  export const ReferencePopulationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    studyURL: 'studyURL',
    assembly: 'assembly',
    numberOfindividuals: 'numberOfindividuals',
    numberOfvariants: 'numberOfvariants',
    studyName: 'studyName',
    date: 'date',
    path: 'path'
  };

  export type ReferencePopulationScalarFieldEnum = (typeof ReferencePopulationScalarFieldEnum)[keyof typeof ReferencePopulationScalarFieldEnum]


  export const PRSAnalysisScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    userId: 'userId',
    date: 'date',
    status: 'status',
    HTMLResultPath: 'HTMLResultPath',
    ancestryThreshold: 'ancestryThreshold',
    overlapThreshold: 'overlapThreshold',
    ancestryAdjustment: 'ancestryAdjustment',
    assembly: 'assembly',
    patientId: 'patientId',
    referencePopulationId: 'referencePopulationId'
  };

  export type PRSAnalysisScalarFieldEnum = (typeof PRSAnalysisScalarFieldEnum)[keyof typeof PRSAnalysisScalarFieldEnum]


  export const PrioritizedModelScalarFieldEnum: {
    position: 'position',
    prsModelId: 'prsModelId',
    prsAnalysisId: 'prsAnalysisId',
    prsResultId: 'prsResultId'
  };

  export type PrioritizedModelScalarFieldEnum = (typeof PrioritizedModelScalarFieldEnum)[keyof typeof PrioritizedModelScalarFieldEnum]


  export const PRSResultScalarFieldEnum: {
    id: 'id',
    prs: 'prs',
    percentile: 'percentile',
    overlapPercent: 'overlapPercent',
    prsModelId: 'prsModelId',
    prsAnalysisId: 'prsAnalysisId'
  };

  export type PRSResultScalarFieldEnum = (typeof PRSResultScalarFieldEnum)[keyof typeof PRSResultScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    genotypingMethod: 'genotypingMethod',
    DataFilePath: 'DataFilePath',
    DataFilteFormat: 'DataFilteFormat'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TraitCategoryOrderByRelevanceFieldEnum: {
    label: 'label'
  };

  export type TraitCategoryOrderByRelevanceFieldEnum = (typeof TraitCategoryOrderByRelevanceFieldEnum)[keyof typeof TraitCategoryOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const TraitOrderByRelevanceFieldEnum: {
    label: 'label',
    description: 'description',
    URL: 'URL',
    efoId: 'efoId',
    mondoId: 'mondoId',
    hpoId: 'hpoId',
    orphaId: 'orphaId',
    otherId: 'otherId'
  };

  export type TraitOrderByRelevanceFieldEnum = (typeof TraitOrderByRelevanceFieldEnum)[keyof typeof TraitOrderByRelevanceFieldEnum]


  export const PRSModelOrderByRelevanceFieldEnum: {
    name: 'name',
    pgscId: 'pgscId',
    pgscURL: 'pgscURL'
  };

  export type PRSModelOrderByRelevanceFieldEnum = (typeof PRSModelOrderByRelevanceFieldEnum)[keyof typeof PRSModelOrderByRelevanceFieldEnum]


  export const ScoringFileOrderByRelevanceFieldEnum: {
    path: 'path'
  };

  export type ScoringFileOrderByRelevanceFieldEnum = (typeof ScoringFileOrderByRelevanceFieldEnum)[keyof typeof ScoringFileOrderByRelevanceFieldEnum]


  export const PublicationOrderByRelevanceFieldEnum: {
    title: 'title',
    journal: 'journal',
    author: 'author',
    PMID: 'PMID',
    DOI: 'DOI',
    pgpId: 'pgpId'
  };

  export type PublicationOrderByRelevanceFieldEnum = (typeof PublicationOrderByRelevanceFieldEnum)[keyof typeof PublicationOrderByRelevanceFieldEnum]


  export const ModelEvaluationOrderByRelevanceFieldEnum: {
    reportedTrait: 'reportedTrait',
    covariates: 'covariates',
    ppmId: 'ppmId'
  };

  export type ModelEvaluationOrderByRelevanceFieldEnum = (typeof ModelEvaluationOrderByRelevanceFieldEnum)[keyof typeof ModelEvaluationOrderByRelevanceFieldEnum]


  export const PerformanceMetricOrderByRelevanceFieldEnum: {
    nameShort: 'nameShort',
    nameLong: 'nameLong'
  };

  export type PerformanceMetricOrderByRelevanceFieldEnum = (typeof PerformanceMetricOrderByRelevanceFieldEnum)[keyof typeof PerformanceMetricOrderByRelevanceFieldEnum]


  export const EvaluationPopulationSampleOrderByRelevanceFieldEnum: {
    ageUnits: 'ageUnits',
    ancestryBroad: 'ancestryBroad',
    ancestryDetails: 'ancestryDetails',
    cohort: 'cohort',
    gcId: 'gcId',
    sourcePMID: 'sourcePMID',
    sourceDOI: 'sourceDOI',
    phenotypeFree: 'phenotypeFree',
    pssId: 'pssId'
  };

  export type EvaluationPopulationSampleOrderByRelevanceFieldEnum = (typeof EvaluationPopulationSampleOrderByRelevanceFieldEnum)[keyof typeof EvaluationPopulationSampleOrderByRelevanceFieldEnum]


  export const BroadAncestryCategoryOrderByRelevanceFieldEnum: {
    symbol: 'symbol',
    label: 'label'
  };

  export type BroadAncestryCategoryOrderByRelevanceFieldEnum = (typeof BroadAncestryCategoryOrderByRelevanceFieldEnum)[keyof typeof BroadAncestryCategoryOrderByRelevanceFieldEnum]


  export const DevelopmentPopulationSampleOrderByRelevanceFieldEnum: {
    ageUnits: 'ageUnits',
    ancestryBroad: 'ancestryBroad',
    ancestryDetails: 'ancestryDetails',
    cohort: 'cohort',
    gcId: 'gcId',
    sourcePMID: 'sourcePMID',
    sourceDOI: 'sourceDOI'
  };

  export type DevelopmentPopulationSampleOrderByRelevanceFieldEnum = (typeof DevelopmentPopulationSampleOrderByRelevanceFieldEnum)[keyof typeof DevelopmentPopulationSampleOrderByRelevanceFieldEnum]


  export const ReferencePopulationOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    studyURL: 'studyURL',
    studyName: 'studyName',
    path: 'path'
  };

  export type ReferencePopulationOrderByRelevanceFieldEnum = (typeof ReferencePopulationOrderByRelevanceFieldEnum)[keyof typeof ReferencePopulationOrderByRelevanceFieldEnum]


  export const PRSAnalysisOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    userId: 'userId',
    date: 'date',
    status: 'status',
    HTMLResultPath: 'HTMLResultPath'
  };

  export type PRSAnalysisOrderByRelevanceFieldEnum = (typeof PRSAnalysisOrderByRelevanceFieldEnum)[keyof typeof PRSAnalysisOrderByRelevanceFieldEnum]


  export const PRSResultOrderByRelevanceFieldEnum: {
    percentile: 'percentile'
  };

  export type PRSResultOrderByRelevanceFieldEnum = (typeof PRSResultOrderByRelevanceFieldEnum)[keyof typeof PRSResultOrderByRelevanceFieldEnum]


  export const PatientOrderByRelevanceFieldEnum: {
    patientId: 'patientId',
    genotypingMethod: 'genotypingMethod',
    DataFilePath: 'DataFilePath',
    DataFilteFormat: 'DataFilteFormat'
  };

  export type PatientOrderByRelevanceFieldEnum = (typeof PatientOrderByRelevanceFieldEnum)[keyof typeof PatientOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'AssemblyType'
   */
  export type EnumAssemblyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssemblyType'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'PerformanceMetricType'
   */
  export type EnumPerformanceMetricTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PerformanceMetricType'>
    


  /**
   * Reference to a field of type 'DevelopmentRoleType'
   */
  export type EnumDevelopmentRoleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DevelopmentRoleType'>
    


  /**
   * Reference to a field of type 'AncestryAdjustmentType'
   */
  export type EnumAncestryAdjustmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AncestryAdjustmentType'>
    
  /**
   * Deep Input Types
   */


  export type TraitCategoryWhereInput = {
    AND?: TraitCategoryWhereInput | TraitCategoryWhereInput[]
    OR?: TraitCategoryWhereInput[]
    NOT?: TraitCategoryWhereInput | TraitCategoryWhereInput[]
    id?: IntFilter<"TraitCategory"> | number
    label?: StringFilter<"TraitCategory"> | string
    traits?: TraitToTraitCategoryListRelationFilter
  }

  export type TraitCategoryOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    traits?: TraitToTraitCategoryOrderByRelationAggregateInput
    _relevance?: TraitCategoryOrderByRelevanceInput
  }

  export type TraitCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TraitCategoryWhereInput | TraitCategoryWhereInput[]
    OR?: TraitCategoryWhereInput[]
    NOT?: TraitCategoryWhereInput | TraitCategoryWhereInput[]
    label?: StringFilter<"TraitCategory"> | string
    traits?: TraitToTraitCategoryListRelationFilter
  }, "id">

  export type TraitCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    _count?: TraitCategoryCountOrderByAggregateInput
    _avg?: TraitCategoryAvgOrderByAggregateInput
    _max?: TraitCategoryMaxOrderByAggregateInput
    _min?: TraitCategoryMinOrderByAggregateInput
    _sum?: TraitCategorySumOrderByAggregateInput
  }

  export type TraitCategoryScalarWhereWithAggregatesInput = {
    AND?: TraitCategoryScalarWhereWithAggregatesInput | TraitCategoryScalarWhereWithAggregatesInput[]
    OR?: TraitCategoryScalarWhereWithAggregatesInput[]
    NOT?: TraitCategoryScalarWhereWithAggregatesInput | TraitCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TraitCategory"> | number
    label?: StringWithAggregatesFilter<"TraitCategory"> | string
  }

  export type TraitWhereInput = {
    AND?: TraitWhereInput | TraitWhereInput[]
    OR?: TraitWhereInput[]
    NOT?: TraitWhereInput | TraitWhereInput[]
    id?: IntFilter<"Trait"> | number
    label?: StringFilter<"Trait"> | string
    description?: StringNullableFilter<"Trait"> | string | null
    URL?: StringNullableFilter<"Trait"> | string | null
    efoId?: StringNullableFilter<"Trait"> | string | null
    mondoId?: StringNullableFilter<"Trait"> | string | null
    hpoId?: StringNullableFilter<"Trait"> | string | null
    orphaId?: StringNullableFilter<"Trait"> | string | null
    otherId?: StringNullableFilter<"Trait"> | string | null
    prsModels?: PRSModelToTraitListRelationFilter
    categories?: TraitToTraitCategoryListRelationFilter
  }

  export type TraitOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    URL?: SortOrderInput | SortOrder
    efoId?: SortOrderInput | SortOrder
    mondoId?: SortOrderInput | SortOrder
    hpoId?: SortOrderInput | SortOrder
    orphaId?: SortOrderInput | SortOrder
    otherId?: SortOrderInput | SortOrder
    prsModels?: PRSModelToTraitOrderByRelationAggregateInput
    categories?: TraitToTraitCategoryOrderByRelationAggregateInput
    _relevance?: TraitOrderByRelevanceInput
  }

  export type TraitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    efoId?: string
    mondoId?: string
    hpoId?: string
    orphaId?: string
    AND?: TraitWhereInput | TraitWhereInput[]
    OR?: TraitWhereInput[]
    NOT?: TraitWhereInput | TraitWhereInput[]
    label?: StringFilter<"Trait"> | string
    description?: StringNullableFilter<"Trait"> | string | null
    URL?: StringNullableFilter<"Trait"> | string | null
    otherId?: StringNullableFilter<"Trait"> | string | null
    prsModels?: PRSModelToTraitListRelationFilter
    categories?: TraitToTraitCategoryListRelationFilter
  }, "id" | "efoId" | "mondoId" | "hpoId" | "orphaId">

  export type TraitOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    URL?: SortOrderInput | SortOrder
    efoId?: SortOrderInput | SortOrder
    mondoId?: SortOrderInput | SortOrder
    hpoId?: SortOrderInput | SortOrder
    orphaId?: SortOrderInput | SortOrder
    otherId?: SortOrderInput | SortOrder
    _count?: TraitCountOrderByAggregateInput
    _avg?: TraitAvgOrderByAggregateInput
    _max?: TraitMaxOrderByAggregateInput
    _min?: TraitMinOrderByAggregateInput
    _sum?: TraitSumOrderByAggregateInput
  }

  export type TraitScalarWhereWithAggregatesInput = {
    AND?: TraitScalarWhereWithAggregatesInput | TraitScalarWhereWithAggregatesInput[]
    OR?: TraitScalarWhereWithAggregatesInput[]
    NOT?: TraitScalarWhereWithAggregatesInput | TraitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Trait"> | number
    label?: StringWithAggregatesFilter<"Trait"> | string
    description?: StringNullableWithAggregatesFilter<"Trait"> | string | null
    URL?: StringNullableWithAggregatesFilter<"Trait"> | string | null
    efoId?: StringNullableWithAggregatesFilter<"Trait"> | string | null
    mondoId?: StringNullableWithAggregatesFilter<"Trait"> | string | null
    hpoId?: StringNullableWithAggregatesFilter<"Trait"> | string | null
    orphaId?: StringNullableWithAggregatesFilter<"Trait"> | string | null
    otherId?: StringNullableWithAggregatesFilter<"Trait"> | string | null
  }

  export type TraitToTraitCategoryWhereInput = {
    AND?: TraitToTraitCategoryWhereInput | TraitToTraitCategoryWhereInput[]
    OR?: TraitToTraitCategoryWhereInput[]
    NOT?: TraitToTraitCategoryWhereInput | TraitToTraitCategoryWhereInput[]
    traitId?: IntFilter<"TraitToTraitCategory"> | number
    traitCategoryId?: IntFilter<"TraitToTraitCategory"> | number
    traitCategory?: XOR<TraitCategoryScalarRelationFilter, TraitCategoryWhereInput>
    trait?: XOR<TraitScalarRelationFilter, TraitWhereInput>
  }

  export type TraitToTraitCategoryOrderByWithRelationInput = {
    traitId?: SortOrder
    traitCategoryId?: SortOrder
    traitCategory?: TraitCategoryOrderByWithRelationInput
    trait?: TraitOrderByWithRelationInput
  }

  export type TraitToTraitCategoryWhereUniqueInput = Prisma.AtLeast<{
    traitId_traitCategoryId?: TraitToTraitCategoryTraitIdTraitCategoryIdCompoundUniqueInput
    AND?: TraitToTraitCategoryWhereInput | TraitToTraitCategoryWhereInput[]
    OR?: TraitToTraitCategoryWhereInput[]
    NOT?: TraitToTraitCategoryWhereInput | TraitToTraitCategoryWhereInput[]
    traitId?: IntFilter<"TraitToTraitCategory"> | number
    traitCategoryId?: IntFilter<"TraitToTraitCategory"> | number
    traitCategory?: XOR<TraitCategoryScalarRelationFilter, TraitCategoryWhereInput>
    trait?: XOR<TraitScalarRelationFilter, TraitWhereInput>
  }, "traitId_traitCategoryId">

  export type TraitToTraitCategoryOrderByWithAggregationInput = {
    traitId?: SortOrder
    traitCategoryId?: SortOrder
    _count?: TraitToTraitCategoryCountOrderByAggregateInput
    _avg?: TraitToTraitCategoryAvgOrderByAggregateInput
    _max?: TraitToTraitCategoryMaxOrderByAggregateInput
    _min?: TraitToTraitCategoryMinOrderByAggregateInput
    _sum?: TraitToTraitCategorySumOrderByAggregateInput
  }

  export type TraitToTraitCategoryScalarWhereWithAggregatesInput = {
    AND?: TraitToTraitCategoryScalarWhereWithAggregatesInput | TraitToTraitCategoryScalarWhereWithAggregatesInput[]
    OR?: TraitToTraitCategoryScalarWhereWithAggregatesInput[]
    NOT?: TraitToTraitCategoryScalarWhereWithAggregatesInput | TraitToTraitCategoryScalarWhereWithAggregatesInput[]
    traitId?: IntWithAggregatesFilter<"TraitToTraitCategory"> | number
    traitCategoryId?: IntWithAggregatesFilter<"TraitToTraitCategory"> | number
  }

  export type PRSModelWhereInput = {
    AND?: PRSModelWhereInput | PRSModelWhereInput[]
    OR?: PRSModelWhereInput[]
    NOT?: PRSModelWhereInput | PRSModelWhereInput[]
    id?: IntFilter<"PRSModel"> | number
    name?: StringFilter<"PRSModel"> | string
    numberOfSNP?: IntNullableFilter<"PRSModel"> | number | null
    pgscId?: StringNullableFilter<"PRSModel"> | string | null
    pgscURL?: StringNullableFilter<"PRSModel"> | string | null
    publicationId?: IntFilter<"PRSModel"> | number
    broadAncestryCategories?: BroadAncestryInModelListRelationFilter
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleListRelationFilter
    modelEvaluations?: ModelEvaluationListRelationFilter
    publication?: XOR<PublicationScalarRelationFilter, PublicationWhereInput>
    traits?: PRSModelToTraitListRelationFilter
    prioritizedModels?: PrioritizedModelListRelationFilter
    scoringFiles?: XOR<ScoringFileNullableScalarRelationFilter, ScoringFileWhereInput> | null
  }

  export type PRSModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    numberOfSNP?: SortOrderInput | SortOrder
    pgscId?: SortOrderInput | SortOrder
    pgscURL?: SortOrderInput | SortOrder
    publicationId?: SortOrder
    broadAncestryCategories?: BroadAncestryInModelOrderByRelationAggregateInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleOrderByRelationAggregateInput
    modelEvaluations?: ModelEvaluationOrderByRelationAggregateInput
    publication?: PublicationOrderByWithRelationInput
    traits?: PRSModelToTraitOrderByRelationAggregateInput
    prioritizedModels?: PrioritizedModelOrderByRelationAggregateInput
    scoringFiles?: ScoringFileOrderByWithRelationInput
    _relevance?: PRSModelOrderByRelevanceInput
  }

  export type PRSModelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    pgscId?: string
    pgscURL?: string
    AND?: PRSModelWhereInput | PRSModelWhereInput[]
    OR?: PRSModelWhereInput[]
    NOT?: PRSModelWhereInput | PRSModelWhereInput[]
    name?: StringFilter<"PRSModel"> | string
    numberOfSNP?: IntNullableFilter<"PRSModel"> | number | null
    publicationId?: IntFilter<"PRSModel"> | number
    broadAncestryCategories?: BroadAncestryInModelListRelationFilter
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleListRelationFilter
    modelEvaluations?: ModelEvaluationListRelationFilter
    publication?: XOR<PublicationScalarRelationFilter, PublicationWhereInput>
    traits?: PRSModelToTraitListRelationFilter
    prioritizedModels?: PrioritizedModelListRelationFilter
    scoringFiles?: XOR<ScoringFileNullableScalarRelationFilter, ScoringFileWhereInput> | null
  }, "id" | "pgscId" | "pgscURL">

  export type PRSModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    numberOfSNP?: SortOrderInput | SortOrder
    pgscId?: SortOrderInput | SortOrder
    pgscURL?: SortOrderInput | SortOrder
    publicationId?: SortOrder
    _count?: PRSModelCountOrderByAggregateInput
    _avg?: PRSModelAvgOrderByAggregateInput
    _max?: PRSModelMaxOrderByAggregateInput
    _min?: PRSModelMinOrderByAggregateInput
    _sum?: PRSModelSumOrderByAggregateInput
  }

  export type PRSModelScalarWhereWithAggregatesInput = {
    AND?: PRSModelScalarWhereWithAggregatesInput | PRSModelScalarWhereWithAggregatesInput[]
    OR?: PRSModelScalarWhereWithAggregatesInput[]
    NOT?: PRSModelScalarWhereWithAggregatesInput | PRSModelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PRSModel"> | number
    name?: StringWithAggregatesFilter<"PRSModel"> | string
    numberOfSNP?: IntNullableWithAggregatesFilter<"PRSModel"> | number | null
    pgscId?: StringNullableWithAggregatesFilter<"PRSModel"> | string | null
    pgscURL?: StringNullableWithAggregatesFilter<"PRSModel"> | string | null
    publicationId?: IntWithAggregatesFilter<"PRSModel"> | number
  }

  export type PRSModelToTraitWhereInput = {
    AND?: PRSModelToTraitWhereInput | PRSModelToTraitWhereInput[]
    OR?: PRSModelToTraitWhereInput[]
    NOT?: PRSModelToTraitWhereInput | PRSModelToTraitWhereInput[]
    prsModelId?: IntFilter<"PRSModelToTrait"> | number
    traitId?: IntFilter<"PRSModelToTrait"> | number
    prsModel?: XOR<PRSModelScalarRelationFilter, PRSModelWhereInput>
    trait?: XOR<TraitScalarRelationFilter, TraitWhereInput>
  }

  export type PRSModelToTraitOrderByWithRelationInput = {
    prsModelId?: SortOrder
    traitId?: SortOrder
    prsModel?: PRSModelOrderByWithRelationInput
    trait?: TraitOrderByWithRelationInput
  }

  export type PRSModelToTraitWhereUniqueInput = Prisma.AtLeast<{
    prsModelId_traitId?: PRSModelToTraitPrsModelIdTraitIdCompoundUniqueInput
    AND?: PRSModelToTraitWhereInput | PRSModelToTraitWhereInput[]
    OR?: PRSModelToTraitWhereInput[]
    NOT?: PRSModelToTraitWhereInput | PRSModelToTraitWhereInput[]
    prsModelId?: IntFilter<"PRSModelToTrait"> | number
    traitId?: IntFilter<"PRSModelToTrait"> | number
    prsModel?: XOR<PRSModelScalarRelationFilter, PRSModelWhereInput>
    trait?: XOR<TraitScalarRelationFilter, TraitWhereInput>
  }, "prsModelId_traitId">

  export type PRSModelToTraitOrderByWithAggregationInput = {
    prsModelId?: SortOrder
    traitId?: SortOrder
    _count?: PRSModelToTraitCountOrderByAggregateInput
    _avg?: PRSModelToTraitAvgOrderByAggregateInput
    _max?: PRSModelToTraitMaxOrderByAggregateInput
    _min?: PRSModelToTraitMinOrderByAggregateInput
    _sum?: PRSModelToTraitSumOrderByAggregateInput
  }

  export type PRSModelToTraitScalarWhereWithAggregatesInput = {
    AND?: PRSModelToTraitScalarWhereWithAggregatesInput | PRSModelToTraitScalarWhereWithAggregatesInput[]
    OR?: PRSModelToTraitScalarWhereWithAggregatesInput[]
    NOT?: PRSModelToTraitScalarWhereWithAggregatesInput | PRSModelToTraitScalarWhereWithAggregatesInput[]
    prsModelId?: IntWithAggregatesFilter<"PRSModelToTrait"> | number
    traitId?: IntWithAggregatesFilter<"PRSModelToTrait"> | number
  }

  export type ScoringFileWhereInput = {
    AND?: ScoringFileWhereInput | ScoringFileWhereInput[]
    OR?: ScoringFileWhereInput[]
    NOT?: ScoringFileWhereInput | ScoringFileWhereInput[]
    id?: IntFilter<"ScoringFile"> | number
    assembly?: EnumAssemblyTypeFilter<"ScoringFile"> | $Enums.AssemblyType
    path?: StringFilter<"ScoringFile"> | string
    prsModelId?: IntFilter<"ScoringFile"> | number
    prsModel?: XOR<PRSModelScalarRelationFilter, PRSModelWhereInput>
  }

  export type ScoringFileOrderByWithRelationInput = {
    id?: SortOrder
    assembly?: SortOrder
    path?: SortOrder
    prsModelId?: SortOrder
    prsModel?: PRSModelOrderByWithRelationInput
    _relevance?: ScoringFileOrderByRelevanceInput
  }

  export type ScoringFileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    prsModelId?: number
    AND?: ScoringFileWhereInput | ScoringFileWhereInput[]
    OR?: ScoringFileWhereInput[]
    NOT?: ScoringFileWhereInput | ScoringFileWhereInput[]
    assembly?: EnumAssemblyTypeFilter<"ScoringFile"> | $Enums.AssemblyType
    path?: StringFilter<"ScoringFile"> | string
    prsModel?: XOR<PRSModelScalarRelationFilter, PRSModelWhereInput>
  }, "id" | "prsModelId">

  export type ScoringFileOrderByWithAggregationInput = {
    id?: SortOrder
    assembly?: SortOrder
    path?: SortOrder
    prsModelId?: SortOrder
    _count?: ScoringFileCountOrderByAggregateInput
    _avg?: ScoringFileAvgOrderByAggregateInput
    _max?: ScoringFileMaxOrderByAggregateInput
    _min?: ScoringFileMinOrderByAggregateInput
    _sum?: ScoringFileSumOrderByAggregateInput
  }

  export type ScoringFileScalarWhereWithAggregatesInput = {
    AND?: ScoringFileScalarWhereWithAggregatesInput | ScoringFileScalarWhereWithAggregatesInput[]
    OR?: ScoringFileScalarWhereWithAggregatesInput[]
    NOT?: ScoringFileScalarWhereWithAggregatesInput | ScoringFileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ScoringFile"> | number
    assembly?: EnumAssemblyTypeWithAggregatesFilter<"ScoringFile"> | $Enums.AssemblyType
    path?: StringWithAggregatesFilter<"ScoringFile"> | string
    prsModelId?: IntWithAggregatesFilter<"ScoringFile"> | number
  }

  export type PublicationWhereInput = {
    AND?: PublicationWhereInput | PublicationWhereInput[]
    OR?: PublicationWhereInput[]
    NOT?: PublicationWhereInput | PublicationWhereInput[]
    id?: IntFilter<"Publication"> | number
    title?: StringFilter<"Publication"> | string
    journal?: StringFilter<"Publication"> | string
    author?: StringFilter<"Publication"> | string
    date?: DateTimeNullableFilter<"Publication"> | Date | string | null
    year?: IntFilter<"Publication"> | number
    PMID?: StringNullableFilter<"Publication"> | string | null
    DOI?: StringNullableFilter<"Publication"> | string | null
    pgpId?: StringNullableFilter<"Publication"> | string | null
    modelEvaluations?: ModelEvaluationListRelationFilter
    prsModels?: PRSModelListRelationFilter
  }

  export type PublicationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    journal?: SortOrder
    author?: SortOrder
    date?: SortOrderInput | SortOrder
    year?: SortOrder
    PMID?: SortOrderInput | SortOrder
    DOI?: SortOrderInput | SortOrder
    pgpId?: SortOrderInput | SortOrder
    modelEvaluations?: ModelEvaluationOrderByRelationAggregateInput
    prsModels?: PRSModelOrderByRelationAggregateInput
    _relevance?: PublicationOrderByRelevanceInput
  }

  export type PublicationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    PMID?: string
    DOI?: string
    pgpId?: string
    AND?: PublicationWhereInput | PublicationWhereInput[]
    OR?: PublicationWhereInput[]
    NOT?: PublicationWhereInput | PublicationWhereInput[]
    title?: StringFilter<"Publication"> | string
    journal?: StringFilter<"Publication"> | string
    author?: StringFilter<"Publication"> | string
    date?: DateTimeNullableFilter<"Publication"> | Date | string | null
    year?: IntFilter<"Publication"> | number
    modelEvaluations?: ModelEvaluationListRelationFilter
    prsModels?: PRSModelListRelationFilter
  }, "id" | "PMID" | "DOI" | "pgpId">

  export type PublicationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    journal?: SortOrder
    author?: SortOrder
    date?: SortOrderInput | SortOrder
    year?: SortOrder
    PMID?: SortOrderInput | SortOrder
    DOI?: SortOrderInput | SortOrder
    pgpId?: SortOrderInput | SortOrder
    _count?: PublicationCountOrderByAggregateInput
    _avg?: PublicationAvgOrderByAggregateInput
    _max?: PublicationMaxOrderByAggregateInput
    _min?: PublicationMinOrderByAggregateInput
    _sum?: PublicationSumOrderByAggregateInput
  }

  export type PublicationScalarWhereWithAggregatesInput = {
    AND?: PublicationScalarWhereWithAggregatesInput | PublicationScalarWhereWithAggregatesInput[]
    OR?: PublicationScalarWhereWithAggregatesInput[]
    NOT?: PublicationScalarWhereWithAggregatesInput | PublicationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Publication"> | number
    title?: StringWithAggregatesFilter<"Publication"> | string
    journal?: StringWithAggregatesFilter<"Publication"> | string
    author?: StringWithAggregatesFilter<"Publication"> | string
    date?: DateTimeNullableWithAggregatesFilter<"Publication"> | Date | string | null
    year?: IntWithAggregatesFilter<"Publication"> | number
    PMID?: StringNullableWithAggregatesFilter<"Publication"> | string | null
    DOI?: StringNullableWithAggregatesFilter<"Publication"> | string | null
    pgpId?: StringNullableWithAggregatesFilter<"Publication"> | string | null
  }

  export type ModelEvaluationWhereInput = {
    AND?: ModelEvaluationWhereInput | ModelEvaluationWhereInput[]
    OR?: ModelEvaluationWhereInput[]
    NOT?: ModelEvaluationWhereInput | ModelEvaluationWhereInput[]
    id?: IntFilter<"ModelEvaluation"> | number
    reportedTrait?: StringFilter<"ModelEvaluation"> | string
    covariates?: StringNullableFilter<"ModelEvaluation"> | string | null
    ppmId?: StringNullableFilter<"ModelEvaluation"> | string | null
    prsModelId?: IntFilter<"ModelEvaluation"> | number
    publicationId?: IntFilter<"ModelEvaluation"> | number
    evaluationPopulationSampleId?: IntFilter<"ModelEvaluation"> | number
    evaluationPopulationSample?: XOR<EvaluationPopulationSampleScalarRelationFilter, EvaluationPopulationSampleWhereInput>
    prsModel?: XOR<PRSModelScalarRelationFilter, PRSModelWhereInput>
    publication?: XOR<PublicationScalarRelationFilter, PublicationWhereInput>
    metricEvaluations?: PerformanceMetricEvaluationListRelationFilter
  }

  export type ModelEvaluationOrderByWithRelationInput = {
    id?: SortOrder
    reportedTrait?: SortOrder
    covariates?: SortOrderInput | SortOrder
    ppmId?: SortOrderInput | SortOrder
    prsModelId?: SortOrder
    publicationId?: SortOrder
    evaluationPopulationSampleId?: SortOrder
    evaluationPopulationSample?: EvaluationPopulationSampleOrderByWithRelationInput
    prsModel?: PRSModelOrderByWithRelationInput
    publication?: PublicationOrderByWithRelationInput
    metricEvaluations?: PerformanceMetricEvaluationOrderByRelationAggregateInput
    _relevance?: ModelEvaluationOrderByRelevanceInput
  }

  export type ModelEvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ModelEvaluationWhereInput | ModelEvaluationWhereInput[]
    OR?: ModelEvaluationWhereInput[]
    NOT?: ModelEvaluationWhereInput | ModelEvaluationWhereInput[]
    reportedTrait?: StringFilter<"ModelEvaluation"> | string
    covariates?: StringNullableFilter<"ModelEvaluation"> | string | null
    ppmId?: StringNullableFilter<"ModelEvaluation"> | string | null
    prsModelId?: IntFilter<"ModelEvaluation"> | number
    publicationId?: IntFilter<"ModelEvaluation"> | number
    evaluationPopulationSampleId?: IntFilter<"ModelEvaluation"> | number
    evaluationPopulationSample?: XOR<EvaluationPopulationSampleScalarRelationFilter, EvaluationPopulationSampleWhereInput>
    prsModel?: XOR<PRSModelScalarRelationFilter, PRSModelWhereInput>
    publication?: XOR<PublicationScalarRelationFilter, PublicationWhereInput>
    metricEvaluations?: PerformanceMetricEvaluationListRelationFilter
  }, "id">

  export type ModelEvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    reportedTrait?: SortOrder
    covariates?: SortOrderInput | SortOrder
    ppmId?: SortOrderInput | SortOrder
    prsModelId?: SortOrder
    publicationId?: SortOrder
    evaluationPopulationSampleId?: SortOrder
    _count?: ModelEvaluationCountOrderByAggregateInput
    _avg?: ModelEvaluationAvgOrderByAggregateInput
    _max?: ModelEvaluationMaxOrderByAggregateInput
    _min?: ModelEvaluationMinOrderByAggregateInput
    _sum?: ModelEvaluationSumOrderByAggregateInput
  }

  export type ModelEvaluationScalarWhereWithAggregatesInput = {
    AND?: ModelEvaluationScalarWhereWithAggregatesInput | ModelEvaluationScalarWhereWithAggregatesInput[]
    OR?: ModelEvaluationScalarWhereWithAggregatesInput[]
    NOT?: ModelEvaluationScalarWhereWithAggregatesInput | ModelEvaluationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ModelEvaluation"> | number
    reportedTrait?: StringWithAggregatesFilter<"ModelEvaluation"> | string
    covariates?: StringNullableWithAggregatesFilter<"ModelEvaluation"> | string | null
    ppmId?: StringNullableWithAggregatesFilter<"ModelEvaluation"> | string | null
    prsModelId?: IntWithAggregatesFilter<"ModelEvaluation"> | number
    publicationId?: IntWithAggregatesFilter<"ModelEvaluation"> | number
    evaluationPopulationSampleId?: IntWithAggregatesFilter<"ModelEvaluation"> | number
  }

  export type PerformanceMetricEvaluationWhereInput = {
    AND?: PerformanceMetricEvaluationWhereInput | PerformanceMetricEvaluationWhereInput[]
    OR?: PerformanceMetricEvaluationWhereInput[]
    NOT?: PerformanceMetricEvaluationWhereInput | PerformanceMetricEvaluationWhereInput[]
    id?: IntFilter<"PerformanceMetricEvaluation"> | number
    estimate?: FloatFilter<"PerformanceMetricEvaluation"> | number
    CILower?: FloatNullableFilter<"PerformanceMetricEvaluation"> | number | null
    CIUpper?: FloatNullableFilter<"PerformanceMetricEvaluation"> | number | null
    modelEvaluationId?: IntFilter<"PerformanceMetricEvaluation"> | number
    performanceMetricId?: IntFilter<"PerformanceMetricEvaluation"> | number
    modelEvaluation?: XOR<ModelEvaluationScalarRelationFilter, ModelEvaluationWhereInput>
    performanceMetric?: XOR<PerformanceMetricScalarRelationFilter, PerformanceMetricWhereInput>
  }

  export type PerformanceMetricEvaluationOrderByWithRelationInput = {
    id?: SortOrder
    estimate?: SortOrder
    CILower?: SortOrderInput | SortOrder
    CIUpper?: SortOrderInput | SortOrder
    modelEvaluationId?: SortOrder
    performanceMetricId?: SortOrder
    modelEvaluation?: ModelEvaluationOrderByWithRelationInput
    performanceMetric?: PerformanceMetricOrderByWithRelationInput
  }

  export type PerformanceMetricEvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PerformanceMetricEvaluationWhereInput | PerformanceMetricEvaluationWhereInput[]
    OR?: PerformanceMetricEvaluationWhereInput[]
    NOT?: PerformanceMetricEvaluationWhereInput | PerformanceMetricEvaluationWhereInput[]
    estimate?: FloatFilter<"PerformanceMetricEvaluation"> | number
    CILower?: FloatNullableFilter<"PerformanceMetricEvaluation"> | number | null
    CIUpper?: FloatNullableFilter<"PerformanceMetricEvaluation"> | number | null
    modelEvaluationId?: IntFilter<"PerformanceMetricEvaluation"> | number
    performanceMetricId?: IntFilter<"PerformanceMetricEvaluation"> | number
    modelEvaluation?: XOR<ModelEvaluationScalarRelationFilter, ModelEvaluationWhereInput>
    performanceMetric?: XOR<PerformanceMetricScalarRelationFilter, PerformanceMetricWhereInput>
  }, "id">

  export type PerformanceMetricEvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    estimate?: SortOrder
    CILower?: SortOrderInput | SortOrder
    CIUpper?: SortOrderInput | SortOrder
    modelEvaluationId?: SortOrder
    performanceMetricId?: SortOrder
    _count?: PerformanceMetricEvaluationCountOrderByAggregateInput
    _avg?: PerformanceMetricEvaluationAvgOrderByAggregateInput
    _max?: PerformanceMetricEvaluationMaxOrderByAggregateInput
    _min?: PerformanceMetricEvaluationMinOrderByAggregateInput
    _sum?: PerformanceMetricEvaluationSumOrderByAggregateInput
  }

  export type PerformanceMetricEvaluationScalarWhereWithAggregatesInput = {
    AND?: PerformanceMetricEvaluationScalarWhereWithAggregatesInput | PerformanceMetricEvaluationScalarWhereWithAggregatesInput[]
    OR?: PerformanceMetricEvaluationScalarWhereWithAggregatesInput[]
    NOT?: PerformanceMetricEvaluationScalarWhereWithAggregatesInput | PerformanceMetricEvaluationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PerformanceMetricEvaluation"> | number
    estimate?: FloatWithAggregatesFilter<"PerformanceMetricEvaluation"> | number
    CILower?: FloatNullableWithAggregatesFilter<"PerformanceMetricEvaluation"> | number | null
    CIUpper?: FloatNullableWithAggregatesFilter<"PerformanceMetricEvaluation"> | number | null
    modelEvaluationId?: IntWithAggregatesFilter<"PerformanceMetricEvaluation"> | number
    performanceMetricId?: IntWithAggregatesFilter<"PerformanceMetricEvaluation"> | number
  }

  export type PerformanceMetricWhereInput = {
    AND?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    OR?: PerformanceMetricWhereInput[]
    NOT?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    id?: IntFilter<"PerformanceMetric"> | number
    nameShort?: StringFilter<"PerformanceMetric"> | string
    nameLong?: StringNullableFilter<"PerformanceMetric"> | string | null
    type?: EnumPerformanceMetricTypeFilter<"PerformanceMetric"> | $Enums.PerformanceMetricType
    performanceMetricEvaluations?: PerformanceMetricEvaluationListRelationFilter
  }

  export type PerformanceMetricOrderByWithRelationInput = {
    id?: SortOrder
    nameShort?: SortOrder
    nameLong?: SortOrderInput | SortOrder
    type?: SortOrder
    performanceMetricEvaluations?: PerformanceMetricEvaluationOrderByRelationAggregateInput
    _relevance?: PerformanceMetricOrderByRelevanceInput
  }

  export type PerformanceMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    OR?: PerformanceMetricWhereInput[]
    NOT?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    nameShort?: StringFilter<"PerformanceMetric"> | string
    nameLong?: StringNullableFilter<"PerformanceMetric"> | string | null
    type?: EnumPerformanceMetricTypeFilter<"PerformanceMetric"> | $Enums.PerformanceMetricType
    performanceMetricEvaluations?: PerformanceMetricEvaluationListRelationFilter
  }, "id">

  export type PerformanceMetricOrderByWithAggregationInput = {
    id?: SortOrder
    nameShort?: SortOrder
    nameLong?: SortOrderInput | SortOrder
    type?: SortOrder
    _count?: PerformanceMetricCountOrderByAggregateInput
    _avg?: PerformanceMetricAvgOrderByAggregateInput
    _max?: PerformanceMetricMaxOrderByAggregateInput
    _min?: PerformanceMetricMinOrderByAggregateInput
    _sum?: PerformanceMetricSumOrderByAggregateInput
  }

  export type PerformanceMetricScalarWhereWithAggregatesInput = {
    AND?: PerformanceMetricScalarWhereWithAggregatesInput | PerformanceMetricScalarWhereWithAggregatesInput[]
    OR?: PerformanceMetricScalarWhereWithAggregatesInput[]
    NOT?: PerformanceMetricScalarWhereWithAggregatesInput | PerformanceMetricScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PerformanceMetric"> | number
    nameShort?: StringWithAggregatesFilter<"PerformanceMetric"> | string
    nameLong?: StringNullableWithAggregatesFilter<"PerformanceMetric"> | string | null
    type?: EnumPerformanceMetricTypeWithAggregatesFilter<"PerformanceMetric"> | $Enums.PerformanceMetricType
  }

  export type EvaluationPopulationSampleWhereInput = {
    AND?: EvaluationPopulationSampleWhereInput | EvaluationPopulationSampleWhereInput[]
    OR?: EvaluationPopulationSampleWhereInput[]
    NOT?: EvaluationPopulationSampleWhereInput | EvaluationPopulationSampleWhereInput[]
    id?: IntFilter<"EvaluationPopulationSample"> | number
    numberOfIndividuals?: IntFilter<"EvaluationPopulationSample"> | number
    numberOfCases?: IntNullableFilter<"EvaluationPopulationSample"> | number | null
    numberOfControls?: IntNullableFilter<"EvaluationPopulationSample"> | number | null
    percentMale?: FloatNullableFilter<"EvaluationPopulationSample"> | number | null
    age?: FloatNullableFilter<"EvaluationPopulationSample"> | number | null
    ageUnits?: StringNullableFilter<"EvaluationPopulationSample"> | string | null
    ancestryBroad?: StringFilter<"EvaluationPopulationSample"> | string
    ancestryDetails?: StringNullableFilter<"EvaluationPopulationSample"> | string | null
    cohort?: StringFilter<"EvaluationPopulationSample"> | string
    gcId?: StringNullableFilter<"EvaluationPopulationSample"> | string | null
    sourcePMID?: StringNullableFilter<"EvaluationPopulationSample"> | string | null
    sourceDOI?: StringNullableFilter<"EvaluationPopulationSample"> | string | null
    phenotypeFree?: StringNullableFilter<"EvaluationPopulationSample"> | string | null
    pssId?: StringFilter<"EvaluationPopulationSample"> | string
    broadAncestryId?: IntFilter<"EvaluationPopulationSample"> | number
    broadAncestryCategory?: XOR<BroadAncestryCategoryScalarRelationFilter, BroadAncestryCategoryWhereInput>
    modelEvaluations?: ModelEvaluationListRelationFilter
  }

  export type EvaluationPopulationSampleOrderByWithRelationInput = {
    id?: SortOrder
    numberOfIndividuals?: SortOrder
    numberOfCases?: SortOrderInput | SortOrder
    numberOfControls?: SortOrderInput | SortOrder
    percentMale?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    ageUnits?: SortOrderInput | SortOrder
    ancestryBroad?: SortOrder
    ancestryDetails?: SortOrderInput | SortOrder
    cohort?: SortOrder
    gcId?: SortOrderInput | SortOrder
    sourcePMID?: SortOrderInput | SortOrder
    sourceDOI?: SortOrderInput | SortOrder
    phenotypeFree?: SortOrderInput | SortOrder
    pssId?: SortOrder
    broadAncestryId?: SortOrder
    broadAncestryCategory?: BroadAncestryCategoryOrderByWithRelationInput
    modelEvaluations?: ModelEvaluationOrderByRelationAggregateInput
    _relevance?: EvaluationPopulationSampleOrderByRelevanceInput
  }

  export type EvaluationPopulationSampleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    pssId?: string
    AND?: EvaluationPopulationSampleWhereInput | EvaluationPopulationSampleWhereInput[]
    OR?: EvaluationPopulationSampleWhereInput[]
    NOT?: EvaluationPopulationSampleWhereInput | EvaluationPopulationSampleWhereInput[]
    numberOfIndividuals?: IntFilter<"EvaluationPopulationSample"> | number
    numberOfCases?: IntNullableFilter<"EvaluationPopulationSample"> | number | null
    numberOfControls?: IntNullableFilter<"EvaluationPopulationSample"> | number | null
    percentMale?: FloatNullableFilter<"EvaluationPopulationSample"> | number | null
    age?: FloatNullableFilter<"EvaluationPopulationSample"> | number | null
    ageUnits?: StringNullableFilter<"EvaluationPopulationSample"> | string | null
    ancestryBroad?: StringFilter<"EvaluationPopulationSample"> | string
    ancestryDetails?: StringNullableFilter<"EvaluationPopulationSample"> | string | null
    cohort?: StringFilter<"EvaluationPopulationSample"> | string
    gcId?: StringNullableFilter<"EvaluationPopulationSample"> | string | null
    sourcePMID?: StringNullableFilter<"EvaluationPopulationSample"> | string | null
    sourceDOI?: StringNullableFilter<"EvaluationPopulationSample"> | string | null
    phenotypeFree?: StringNullableFilter<"EvaluationPopulationSample"> | string | null
    broadAncestryId?: IntFilter<"EvaluationPopulationSample"> | number
    broadAncestryCategory?: XOR<BroadAncestryCategoryScalarRelationFilter, BroadAncestryCategoryWhereInput>
    modelEvaluations?: ModelEvaluationListRelationFilter
  }, "id" | "pssId">

  export type EvaluationPopulationSampleOrderByWithAggregationInput = {
    id?: SortOrder
    numberOfIndividuals?: SortOrder
    numberOfCases?: SortOrderInput | SortOrder
    numberOfControls?: SortOrderInput | SortOrder
    percentMale?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    ageUnits?: SortOrderInput | SortOrder
    ancestryBroad?: SortOrder
    ancestryDetails?: SortOrderInput | SortOrder
    cohort?: SortOrder
    gcId?: SortOrderInput | SortOrder
    sourcePMID?: SortOrderInput | SortOrder
    sourceDOI?: SortOrderInput | SortOrder
    phenotypeFree?: SortOrderInput | SortOrder
    pssId?: SortOrder
    broadAncestryId?: SortOrder
    _count?: EvaluationPopulationSampleCountOrderByAggregateInput
    _avg?: EvaluationPopulationSampleAvgOrderByAggregateInput
    _max?: EvaluationPopulationSampleMaxOrderByAggregateInput
    _min?: EvaluationPopulationSampleMinOrderByAggregateInput
    _sum?: EvaluationPopulationSampleSumOrderByAggregateInput
  }

  export type EvaluationPopulationSampleScalarWhereWithAggregatesInput = {
    AND?: EvaluationPopulationSampleScalarWhereWithAggregatesInput | EvaluationPopulationSampleScalarWhereWithAggregatesInput[]
    OR?: EvaluationPopulationSampleScalarWhereWithAggregatesInput[]
    NOT?: EvaluationPopulationSampleScalarWhereWithAggregatesInput | EvaluationPopulationSampleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EvaluationPopulationSample"> | number
    numberOfIndividuals?: IntWithAggregatesFilter<"EvaluationPopulationSample"> | number
    numberOfCases?: IntNullableWithAggregatesFilter<"EvaluationPopulationSample"> | number | null
    numberOfControls?: IntNullableWithAggregatesFilter<"EvaluationPopulationSample"> | number | null
    percentMale?: FloatNullableWithAggregatesFilter<"EvaluationPopulationSample"> | number | null
    age?: FloatNullableWithAggregatesFilter<"EvaluationPopulationSample"> | number | null
    ageUnits?: StringNullableWithAggregatesFilter<"EvaluationPopulationSample"> | string | null
    ancestryBroad?: StringWithAggregatesFilter<"EvaluationPopulationSample"> | string
    ancestryDetails?: StringNullableWithAggregatesFilter<"EvaluationPopulationSample"> | string | null
    cohort?: StringWithAggregatesFilter<"EvaluationPopulationSample"> | string
    gcId?: StringNullableWithAggregatesFilter<"EvaluationPopulationSample"> | string | null
    sourcePMID?: StringNullableWithAggregatesFilter<"EvaluationPopulationSample"> | string | null
    sourceDOI?: StringNullableWithAggregatesFilter<"EvaluationPopulationSample"> | string | null
    phenotypeFree?: StringNullableWithAggregatesFilter<"EvaluationPopulationSample"> | string | null
    pssId?: StringWithAggregatesFilter<"EvaluationPopulationSample"> | string
    broadAncestryId?: IntWithAggregatesFilter<"EvaluationPopulationSample"> | number
  }

  export type BroadAncestryCategoryWhereInput = {
    AND?: BroadAncestryCategoryWhereInput | BroadAncestryCategoryWhereInput[]
    OR?: BroadAncestryCategoryWhereInput[]
    NOT?: BroadAncestryCategoryWhereInput | BroadAncestryCategoryWhereInput[]
    id?: IntFilter<"BroadAncestryCategory"> | number
    symbol?: StringFilter<"BroadAncestryCategory"> | string
    label?: StringFilter<"BroadAncestryCategory"> | string
    broadAncestryInModels?: BroadAncestryInModelListRelationFilter
    broadAncestryInRefPops?: BroadAncestryInRefPopListRelationFilter
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleListRelationFilter
    EvaluationPopulationSamples?: EvaluationPopulationSampleListRelationFilter
  }

  export type BroadAncestryCategoryOrderByWithRelationInput = {
    id?: SortOrder
    symbol?: SortOrder
    label?: SortOrder
    broadAncestryInModels?: BroadAncestryInModelOrderByRelationAggregateInput
    broadAncestryInRefPops?: BroadAncestryInRefPopOrderByRelationAggregateInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleOrderByRelationAggregateInput
    EvaluationPopulationSamples?: EvaluationPopulationSampleOrderByRelationAggregateInput
    _relevance?: BroadAncestryCategoryOrderByRelevanceInput
  }

  export type BroadAncestryCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BroadAncestryCategoryWhereInput | BroadAncestryCategoryWhereInput[]
    OR?: BroadAncestryCategoryWhereInput[]
    NOT?: BroadAncestryCategoryWhereInput | BroadAncestryCategoryWhereInput[]
    symbol?: StringFilter<"BroadAncestryCategory"> | string
    label?: StringFilter<"BroadAncestryCategory"> | string
    broadAncestryInModels?: BroadAncestryInModelListRelationFilter
    broadAncestryInRefPops?: BroadAncestryInRefPopListRelationFilter
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleListRelationFilter
    EvaluationPopulationSamples?: EvaluationPopulationSampleListRelationFilter
  }, "id">

  export type BroadAncestryCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    symbol?: SortOrder
    label?: SortOrder
    _count?: BroadAncestryCategoryCountOrderByAggregateInput
    _avg?: BroadAncestryCategoryAvgOrderByAggregateInput
    _max?: BroadAncestryCategoryMaxOrderByAggregateInput
    _min?: BroadAncestryCategoryMinOrderByAggregateInput
    _sum?: BroadAncestryCategorySumOrderByAggregateInput
  }

  export type BroadAncestryCategoryScalarWhereWithAggregatesInput = {
    AND?: BroadAncestryCategoryScalarWhereWithAggregatesInput | BroadAncestryCategoryScalarWhereWithAggregatesInput[]
    OR?: BroadAncestryCategoryScalarWhereWithAggregatesInput[]
    NOT?: BroadAncestryCategoryScalarWhereWithAggregatesInput | BroadAncestryCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BroadAncestryCategory"> | number
    symbol?: StringWithAggregatesFilter<"BroadAncestryCategory"> | string
    label?: StringWithAggregatesFilter<"BroadAncestryCategory"> | string
  }

  export type BroadAncestryInModelWhereInput = {
    AND?: BroadAncestryInModelWhereInput | BroadAncestryInModelWhereInput[]
    OR?: BroadAncestryInModelWhereInput[]
    NOT?: BroadAncestryInModelWhereInput | BroadAncestryInModelWhereInput[]
    percentage?: FloatFilter<"BroadAncestryInModel"> | number
    broadAncestryId?: IntFilter<"BroadAncestryInModel"> | number
    prsModelId?: IntFilter<"BroadAncestryInModel"> | number
    broadAncestryCategory?: XOR<BroadAncestryCategoryScalarRelationFilter, BroadAncestryCategoryWhereInput>
    prsModel?: XOR<PRSModelScalarRelationFilter, PRSModelWhereInput>
  }

  export type BroadAncestryInModelOrderByWithRelationInput = {
    percentage?: SortOrder
    broadAncestryId?: SortOrder
    prsModelId?: SortOrder
    broadAncestryCategory?: BroadAncestryCategoryOrderByWithRelationInput
    prsModel?: PRSModelOrderByWithRelationInput
  }

  export type BroadAncestryInModelWhereUniqueInput = Prisma.AtLeast<{
    broadAncestryId_prsModelId?: BroadAncestryInModelBroadAncestryIdPrsModelIdCompoundUniqueInput
    AND?: BroadAncestryInModelWhereInput | BroadAncestryInModelWhereInput[]
    OR?: BroadAncestryInModelWhereInput[]
    NOT?: BroadAncestryInModelWhereInput | BroadAncestryInModelWhereInput[]
    percentage?: FloatFilter<"BroadAncestryInModel"> | number
    broadAncestryId?: IntFilter<"BroadAncestryInModel"> | number
    prsModelId?: IntFilter<"BroadAncestryInModel"> | number
    broadAncestryCategory?: XOR<BroadAncestryCategoryScalarRelationFilter, BroadAncestryCategoryWhereInput>
    prsModel?: XOR<PRSModelScalarRelationFilter, PRSModelWhereInput>
  }, "broadAncestryId_prsModelId">

  export type BroadAncestryInModelOrderByWithAggregationInput = {
    percentage?: SortOrder
    broadAncestryId?: SortOrder
    prsModelId?: SortOrder
    _count?: BroadAncestryInModelCountOrderByAggregateInput
    _avg?: BroadAncestryInModelAvgOrderByAggregateInput
    _max?: BroadAncestryInModelMaxOrderByAggregateInput
    _min?: BroadAncestryInModelMinOrderByAggregateInput
    _sum?: BroadAncestryInModelSumOrderByAggregateInput
  }

  export type BroadAncestryInModelScalarWhereWithAggregatesInput = {
    AND?: BroadAncestryInModelScalarWhereWithAggregatesInput | BroadAncestryInModelScalarWhereWithAggregatesInput[]
    OR?: BroadAncestryInModelScalarWhereWithAggregatesInput[]
    NOT?: BroadAncestryInModelScalarWhereWithAggregatesInput | BroadAncestryInModelScalarWhereWithAggregatesInput[]
    percentage?: FloatWithAggregatesFilter<"BroadAncestryInModel"> | number
    broadAncestryId?: IntWithAggregatesFilter<"BroadAncestryInModel"> | number
    prsModelId?: IntWithAggregatesFilter<"BroadAncestryInModel"> | number
  }

  export type DevelopmentPopulationSampleWhereInput = {
    AND?: DevelopmentPopulationSampleWhereInput | DevelopmentPopulationSampleWhereInput[]
    OR?: DevelopmentPopulationSampleWhereInput[]
    NOT?: DevelopmentPopulationSampleWhereInput | DevelopmentPopulationSampleWhereInput[]
    id?: IntFilter<"DevelopmentPopulationSample"> | number
    numberOfIndividuals?: IntNullableFilter<"DevelopmentPopulationSample"> | number | null
    numberOfCases?: IntNullableFilter<"DevelopmentPopulationSample"> | number | null
    numberOfControls?: IntNullableFilter<"DevelopmentPopulationSample"> | number | null
    percentMale?: FloatNullableFilter<"DevelopmentPopulationSample"> | number | null
    age?: FloatNullableFilter<"DevelopmentPopulationSample"> | number | null
    ageUnits?: StringNullableFilter<"DevelopmentPopulationSample"> | string | null
    ancestryBroad?: StringFilter<"DevelopmentPopulationSample"> | string
    ancestryDetails?: StringNullableFilter<"DevelopmentPopulationSample"> | string | null
    cohort?: StringFilter<"DevelopmentPopulationSample"> | string
    gcId?: StringNullableFilter<"DevelopmentPopulationSample"> | string | null
    sourcePMID?: StringNullableFilter<"DevelopmentPopulationSample"> | string | null
    sourceDOI?: StringNullableFilter<"DevelopmentPopulationSample"> | string | null
    role?: EnumDevelopmentRoleTypeFilter<"DevelopmentPopulationSample"> | $Enums.DevelopmentRoleType
    prsModelId?: IntFilter<"DevelopmentPopulationSample"> | number
    broadAncestryId?: IntFilter<"DevelopmentPopulationSample"> | number
    broadAncestryCategory?: XOR<BroadAncestryCategoryScalarRelationFilter, BroadAncestryCategoryWhereInput>
    prsModel?: XOR<PRSModelScalarRelationFilter, PRSModelWhereInput>
  }

  export type DevelopmentPopulationSampleOrderByWithRelationInput = {
    id?: SortOrder
    numberOfIndividuals?: SortOrderInput | SortOrder
    numberOfCases?: SortOrderInput | SortOrder
    numberOfControls?: SortOrderInput | SortOrder
    percentMale?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    ageUnits?: SortOrderInput | SortOrder
    ancestryBroad?: SortOrder
    ancestryDetails?: SortOrderInput | SortOrder
    cohort?: SortOrder
    gcId?: SortOrderInput | SortOrder
    sourcePMID?: SortOrderInput | SortOrder
    sourceDOI?: SortOrderInput | SortOrder
    role?: SortOrder
    prsModelId?: SortOrder
    broadAncestryId?: SortOrder
    broadAncestryCategory?: BroadAncestryCategoryOrderByWithRelationInput
    prsModel?: PRSModelOrderByWithRelationInput
    _relevance?: DevelopmentPopulationSampleOrderByRelevanceInput
  }

  export type DevelopmentPopulationSampleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DevelopmentPopulationSampleWhereInput | DevelopmentPopulationSampleWhereInput[]
    OR?: DevelopmentPopulationSampleWhereInput[]
    NOT?: DevelopmentPopulationSampleWhereInput | DevelopmentPopulationSampleWhereInput[]
    numberOfIndividuals?: IntNullableFilter<"DevelopmentPopulationSample"> | number | null
    numberOfCases?: IntNullableFilter<"DevelopmentPopulationSample"> | number | null
    numberOfControls?: IntNullableFilter<"DevelopmentPopulationSample"> | number | null
    percentMale?: FloatNullableFilter<"DevelopmentPopulationSample"> | number | null
    age?: FloatNullableFilter<"DevelopmentPopulationSample"> | number | null
    ageUnits?: StringNullableFilter<"DevelopmentPopulationSample"> | string | null
    ancestryBroad?: StringFilter<"DevelopmentPopulationSample"> | string
    ancestryDetails?: StringNullableFilter<"DevelopmentPopulationSample"> | string | null
    cohort?: StringFilter<"DevelopmentPopulationSample"> | string
    gcId?: StringNullableFilter<"DevelopmentPopulationSample"> | string | null
    sourcePMID?: StringNullableFilter<"DevelopmentPopulationSample"> | string | null
    sourceDOI?: StringNullableFilter<"DevelopmentPopulationSample"> | string | null
    role?: EnumDevelopmentRoleTypeFilter<"DevelopmentPopulationSample"> | $Enums.DevelopmentRoleType
    prsModelId?: IntFilter<"DevelopmentPopulationSample"> | number
    broadAncestryId?: IntFilter<"DevelopmentPopulationSample"> | number
    broadAncestryCategory?: XOR<BroadAncestryCategoryScalarRelationFilter, BroadAncestryCategoryWhereInput>
    prsModel?: XOR<PRSModelScalarRelationFilter, PRSModelWhereInput>
  }, "id">

  export type DevelopmentPopulationSampleOrderByWithAggregationInput = {
    id?: SortOrder
    numberOfIndividuals?: SortOrderInput | SortOrder
    numberOfCases?: SortOrderInput | SortOrder
    numberOfControls?: SortOrderInput | SortOrder
    percentMale?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    ageUnits?: SortOrderInput | SortOrder
    ancestryBroad?: SortOrder
    ancestryDetails?: SortOrderInput | SortOrder
    cohort?: SortOrder
    gcId?: SortOrderInput | SortOrder
    sourcePMID?: SortOrderInput | SortOrder
    sourceDOI?: SortOrderInput | SortOrder
    role?: SortOrder
    prsModelId?: SortOrder
    broadAncestryId?: SortOrder
    _count?: DevelopmentPopulationSampleCountOrderByAggregateInput
    _avg?: DevelopmentPopulationSampleAvgOrderByAggregateInput
    _max?: DevelopmentPopulationSampleMaxOrderByAggregateInput
    _min?: DevelopmentPopulationSampleMinOrderByAggregateInput
    _sum?: DevelopmentPopulationSampleSumOrderByAggregateInput
  }

  export type DevelopmentPopulationSampleScalarWhereWithAggregatesInput = {
    AND?: DevelopmentPopulationSampleScalarWhereWithAggregatesInput | DevelopmentPopulationSampleScalarWhereWithAggregatesInput[]
    OR?: DevelopmentPopulationSampleScalarWhereWithAggregatesInput[]
    NOT?: DevelopmentPopulationSampleScalarWhereWithAggregatesInput | DevelopmentPopulationSampleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DevelopmentPopulationSample"> | number
    numberOfIndividuals?: IntNullableWithAggregatesFilter<"DevelopmentPopulationSample"> | number | null
    numberOfCases?: IntNullableWithAggregatesFilter<"DevelopmentPopulationSample"> | number | null
    numberOfControls?: IntNullableWithAggregatesFilter<"DevelopmentPopulationSample"> | number | null
    percentMale?: FloatNullableWithAggregatesFilter<"DevelopmentPopulationSample"> | number | null
    age?: FloatNullableWithAggregatesFilter<"DevelopmentPopulationSample"> | number | null
    ageUnits?: StringNullableWithAggregatesFilter<"DevelopmentPopulationSample"> | string | null
    ancestryBroad?: StringWithAggregatesFilter<"DevelopmentPopulationSample"> | string
    ancestryDetails?: StringNullableWithAggregatesFilter<"DevelopmentPopulationSample"> | string | null
    cohort?: StringWithAggregatesFilter<"DevelopmentPopulationSample"> | string
    gcId?: StringNullableWithAggregatesFilter<"DevelopmentPopulationSample"> | string | null
    sourcePMID?: StringNullableWithAggregatesFilter<"DevelopmentPopulationSample"> | string | null
    sourceDOI?: StringNullableWithAggregatesFilter<"DevelopmentPopulationSample"> | string | null
    role?: EnumDevelopmentRoleTypeWithAggregatesFilter<"DevelopmentPopulationSample"> | $Enums.DevelopmentRoleType
    prsModelId?: IntWithAggregatesFilter<"DevelopmentPopulationSample"> | number
    broadAncestryId?: IntWithAggregatesFilter<"DevelopmentPopulationSample"> | number
  }

  export type BroadAncestryInRefPopWhereInput = {
    AND?: BroadAncestryInRefPopWhereInput | BroadAncestryInRefPopWhereInput[]
    OR?: BroadAncestryInRefPopWhereInput[]
    NOT?: BroadAncestryInRefPopWhereInput | BroadAncestryInRefPopWhereInput[]
    percentage?: FloatFilter<"BroadAncestryInRefPop"> | number
    broadAncestryId?: IntFilter<"BroadAncestryInRefPop"> | number
    referencePopulationId?: IntFilter<"BroadAncestryInRefPop"> | number
    broadAncestryCategory?: XOR<BroadAncestryCategoryScalarRelationFilter, BroadAncestryCategoryWhereInput>
    referencePopulation?: XOR<ReferencePopulationScalarRelationFilter, ReferencePopulationWhereInput>
  }

  export type BroadAncestryInRefPopOrderByWithRelationInput = {
    percentage?: SortOrder
    broadAncestryId?: SortOrder
    referencePopulationId?: SortOrder
    broadAncestryCategory?: BroadAncestryCategoryOrderByWithRelationInput
    referencePopulation?: ReferencePopulationOrderByWithRelationInput
  }

  export type BroadAncestryInRefPopWhereUniqueInput = Prisma.AtLeast<{
    broadAncestryId_referencePopulationId?: BroadAncestryInRefPopBroadAncestryIdReferencePopulationIdCompoundUniqueInput
    AND?: BroadAncestryInRefPopWhereInput | BroadAncestryInRefPopWhereInput[]
    OR?: BroadAncestryInRefPopWhereInput[]
    NOT?: BroadAncestryInRefPopWhereInput | BroadAncestryInRefPopWhereInput[]
    percentage?: FloatFilter<"BroadAncestryInRefPop"> | number
    broadAncestryId?: IntFilter<"BroadAncestryInRefPop"> | number
    referencePopulationId?: IntFilter<"BroadAncestryInRefPop"> | number
    broadAncestryCategory?: XOR<BroadAncestryCategoryScalarRelationFilter, BroadAncestryCategoryWhereInput>
    referencePopulation?: XOR<ReferencePopulationScalarRelationFilter, ReferencePopulationWhereInput>
  }, "broadAncestryId_referencePopulationId">

  export type BroadAncestryInRefPopOrderByWithAggregationInput = {
    percentage?: SortOrder
    broadAncestryId?: SortOrder
    referencePopulationId?: SortOrder
    _count?: BroadAncestryInRefPopCountOrderByAggregateInput
    _avg?: BroadAncestryInRefPopAvgOrderByAggregateInput
    _max?: BroadAncestryInRefPopMaxOrderByAggregateInput
    _min?: BroadAncestryInRefPopMinOrderByAggregateInput
    _sum?: BroadAncestryInRefPopSumOrderByAggregateInput
  }

  export type BroadAncestryInRefPopScalarWhereWithAggregatesInput = {
    AND?: BroadAncestryInRefPopScalarWhereWithAggregatesInput | BroadAncestryInRefPopScalarWhereWithAggregatesInput[]
    OR?: BroadAncestryInRefPopScalarWhereWithAggregatesInput[]
    NOT?: BroadAncestryInRefPopScalarWhereWithAggregatesInput | BroadAncestryInRefPopScalarWhereWithAggregatesInput[]
    percentage?: FloatWithAggregatesFilter<"BroadAncestryInRefPop"> | number
    broadAncestryId?: IntWithAggregatesFilter<"BroadAncestryInRefPop"> | number
    referencePopulationId?: IntWithAggregatesFilter<"BroadAncestryInRefPop"> | number
  }

  export type ReferencePopulationWhereInput = {
    AND?: ReferencePopulationWhereInput | ReferencePopulationWhereInput[]
    OR?: ReferencePopulationWhereInput[]
    NOT?: ReferencePopulationWhereInput | ReferencePopulationWhereInput[]
    id?: IntFilter<"ReferencePopulation"> | number
    name?: StringFilter<"ReferencePopulation"> | string
    description?: StringNullableFilter<"ReferencePopulation"> | string | null
    studyURL?: StringNullableFilter<"ReferencePopulation"> | string | null
    assembly?: EnumAssemblyTypeFilter<"ReferencePopulation"> | $Enums.AssemblyType
    numberOfindividuals?: IntNullableFilter<"ReferencePopulation"> | number | null
    numberOfvariants?: IntNullableFilter<"ReferencePopulation"> | number | null
    studyName?: StringFilter<"ReferencePopulation"> | string
    date?: DateTimeFilter<"ReferencePopulation"> | Date | string
    path?: StringFilter<"ReferencePopulation"> | string
    broadAncestryCategories?: BroadAncestryInRefPopListRelationFilter
    prsAnalyses?: PRSAnalysisListRelationFilter
  }

  export type ReferencePopulationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    studyURL?: SortOrderInput | SortOrder
    assembly?: SortOrder
    numberOfindividuals?: SortOrderInput | SortOrder
    numberOfvariants?: SortOrderInput | SortOrder
    studyName?: SortOrder
    date?: SortOrder
    path?: SortOrder
    broadAncestryCategories?: BroadAncestryInRefPopOrderByRelationAggregateInput
    prsAnalyses?: PRSAnalysisOrderByRelationAggregateInput
    _relevance?: ReferencePopulationOrderByRelevanceInput
  }

  export type ReferencePopulationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReferencePopulationWhereInput | ReferencePopulationWhereInput[]
    OR?: ReferencePopulationWhereInput[]
    NOT?: ReferencePopulationWhereInput | ReferencePopulationWhereInput[]
    name?: StringFilter<"ReferencePopulation"> | string
    description?: StringNullableFilter<"ReferencePopulation"> | string | null
    studyURL?: StringNullableFilter<"ReferencePopulation"> | string | null
    assembly?: EnumAssemblyTypeFilter<"ReferencePopulation"> | $Enums.AssemblyType
    numberOfindividuals?: IntNullableFilter<"ReferencePopulation"> | number | null
    numberOfvariants?: IntNullableFilter<"ReferencePopulation"> | number | null
    studyName?: StringFilter<"ReferencePopulation"> | string
    date?: DateTimeFilter<"ReferencePopulation"> | Date | string
    path?: StringFilter<"ReferencePopulation"> | string
    broadAncestryCategories?: BroadAncestryInRefPopListRelationFilter
    prsAnalyses?: PRSAnalysisListRelationFilter
  }, "id">

  export type ReferencePopulationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    studyURL?: SortOrderInput | SortOrder
    assembly?: SortOrder
    numberOfindividuals?: SortOrderInput | SortOrder
    numberOfvariants?: SortOrderInput | SortOrder
    studyName?: SortOrder
    date?: SortOrder
    path?: SortOrder
    _count?: ReferencePopulationCountOrderByAggregateInput
    _avg?: ReferencePopulationAvgOrderByAggregateInput
    _max?: ReferencePopulationMaxOrderByAggregateInput
    _min?: ReferencePopulationMinOrderByAggregateInput
    _sum?: ReferencePopulationSumOrderByAggregateInput
  }

  export type ReferencePopulationScalarWhereWithAggregatesInput = {
    AND?: ReferencePopulationScalarWhereWithAggregatesInput | ReferencePopulationScalarWhereWithAggregatesInput[]
    OR?: ReferencePopulationScalarWhereWithAggregatesInput[]
    NOT?: ReferencePopulationScalarWhereWithAggregatesInput | ReferencePopulationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReferencePopulation"> | number
    name?: StringWithAggregatesFilter<"ReferencePopulation"> | string
    description?: StringNullableWithAggregatesFilter<"ReferencePopulation"> | string | null
    studyURL?: StringNullableWithAggregatesFilter<"ReferencePopulation"> | string | null
    assembly?: EnumAssemblyTypeWithAggregatesFilter<"ReferencePopulation"> | $Enums.AssemblyType
    numberOfindividuals?: IntNullableWithAggregatesFilter<"ReferencePopulation"> | number | null
    numberOfvariants?: IntNullableWithAggregatesFilter<"ReferencePopulation"> | number | null
    studyName?: StringWithAggregatesFilter<"ReferencePopulation"> | string
    date?: DateTimeWithAggregatesFilter<"ReferencePopulation"> | Date | string
    path?: StringWithAggregatesFilter<"ReferencePopulation"> | string
  }

  export type PRSAnalysisWhereInput = {
    AND?: PRSAnalysisWhereInput | PRSAnalysisWhereInput[]
    OR?: PRSAnalysisWhereInput[]
    NOT?: PRSAnalysisWhereInput | PRSAnalysisWhereInput[]
    id?: IntFilter<"PRSAnalysis"> | number
    name?: StringFilter<"PRSAnalysis"> | string
    description?: StringNullableFilter<"PRSAnalysis"> | string | null
    userId?: StringNullableFilter<"PRSAnalysis"> | string | null
    date?: StringFilter<"PRSAnalysis"> | string
    status?: StringFilter<"PRSAnalysis"> | string
    HTMLResultPath?: StringFilter<"PRSAnalysis"> | string
    ancestryThreshold?: IntFilter<"PRSAnalysis"> | number
    overlapThreshold?: IntFilter<"PRSAnalysis"> | number
    ancestryAdjustment?: EnumAncestryAdjustmentTypeFilter<"PRSAnalysis"> | $Enums.AncestryAdjustmentType
    assembly?: EnumAssemblyTypeFilter<"PRSAnalysis"> | $Enums.AssemblyType
    patientId?: IntFilter<"PRSAnalysis"> | number
    referencePopulationId?: IntFilter<"PRSAnalysis"> | number
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    referencePopulation?: XOR<ReferencePopulationScalarRelationFilter, ReferencePopulationWhereInput>
    prioritizedModels?: PrioritizedModelListRelationFilter
  }

  export type PRSAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    date?: SortOrder
    status?: SortOrder
    HTMLResultPath?: SortOrder
    ancestryThreshold?: SortOrder
    overlapThreshold?: SortOrder
    ancestryAdjustment?: SortOrder
    assembly?: SortOrder
    patientId?: SortOrder
    referencePopulationId?: SortOrder
    patient?: PatientOrderByWithRelationInput
    referencePopulation?: ReferencePopulationOrderByWithRelationInput
    prioritizedModels?: PrioritizedModelOrderByRelationAggregateInput
    _relevance?: PRSAnalysisOrderByRelevanceInput
  }

  export type PRSAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PRSAnalysisWhereInput | PRSAnalysisWhereInput[]
    OR?: PRSAnalysisWhereInput[]
    NOT?: PRSAnalysisWhereInput | PRSAnalysisWhereInput[]
    name?: StringFilter<"PRSAnalysis"> | string
    description?: StringNullableFilter<"PRSAnalysis"> | string | null
    userId?: StringNullableFilter<"PRSAnalysis"> | string | null
    date?: StringFilter<"PRSAnalysis"> | string
    status?: StringFilter<"PRSAnalysis"> | string
    HTMLResultPath?: StringFilter<"PRSAnalysis"> | string
    ancestryThreshold?: IntFilter<"PRSAnalysis"> | number
    overlapThreshold?: IntFilter<"PRSAnalysis"> | number
    ancestryAdjustment?: EnumAncestryAdjustmentTypeFilter<"PRSAnalysis"> | $Enums.AncestryAdjustmentType
    assembly?: EnumAssemblyTypeFilter<"PRSAnalysis"> | $Enums.AssemblyType
    patientId?: IntFilter<"PRSAnalysis"> | number
    referencePopulationId?: IntFilter<"PRSAnalysis"> | number
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    referencePopulation?: XOR<ReferencePopulationScalarRelationFilter, ReferencePopulationWhereInput>
    prioritizedModels?: PrioritizedModelListRelationFilter
  }, "id">

  export type PRSAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    date?: SortOrder
    status?: SortOrder
    HTMLResultPath?: SortOrder
    ancestryThreshold?: SortOrder
    overlapThreshold?: SortOrder
    ancestryAdjustment?: SortOrder
    assembly?: SortOrder
    patientId?: SortOrder
    referencePopulationId?: SortOrder
    _count?: PRSAnalysisCountOrderByAggregateInput
    _avg?: PRSAnalysisAvgOrderByAggregateInput
    _max?: PRSAnalysisMaxOrderByAggregateInput
    _min?: PRSAnalysisMinOrderByAggregateInput
    _sum?: PRSAnalysisSumOrderByAggregateInput
  }

  export type PRSAnalysisScalarWhereWithAggregatesInput = {
    AND?: PRSAnalysisScalarWhereWithAggregatesInput | PRSAnalysisScalarWhereWithAggregatesInput[]
    OR?: PRSAnalysisScalarWhereWithAggregatesInput[]
    NOT?: PRSAnalysisScalarWhereWithAggregatesInput | PRSAnalysisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PRSAnalysis"> | number
    name?: StringWithAggregatesFilter<"PRSAnalysis"> | string
    description?: StringNullableWithAggregatesFilter<"PRSAnalysis"> | string | null
    userId?: StringNullableWithAggregatesFilter<"PRSAnalysis"> | string | null
    date?: StringWithAggregatesFilter<"PRSAnalysis"> | string
    status?: StringWithAggregatesFilter<"PRSAnalysis"> | string
    HTMLResultPath?: StringWithAggregatesFilter<"PRSAnalysis"> | string
    ancestryThreshold?: IntWithAggregatesFilter<"PRSAnalysis"> | number
    overlapThreshold?: IntWithAggregatesFilter<"PRSAnalysis"> | number
    ancestryAdjustment?: EnumAncestryAdjustmentTypeWithAggregatesFilter<"PRSAnalysis"> | $Enums.AncestryAdjustmentType
    assembly?: EnumAssemblyTypeWithAggregatesFilter<"PRSAnalysis"> | $Enums.AssemblyType
    patientId?: IntWithAggregatesFilter<"PRSAnalysis"> | number
    referencePopulationId?: IntWithAggregatesFilter<"PRSAnalysis"> | number
  }

  export type PrioritizedModelWhereInput = {
    AND?: PrioritizedModelWhereInput | PrioritizedModelWhereInput[]
    OR?: PrioritizedModelWhereInput[]
    NOT?: PrioritizedModelWhereInput | PrioritizedModelWhereInput[]
    position?: IntFilter<"PrioritizedModel"> | number
    prsModelId?: IntFilter<"PrioritizedModel"> | number
    prsAnalysisId?: IntFilter<"PrioritizedModel"> | number
    prsResultId?: IntNullableFilter<"PrioritizedModel"> | number | null
    prsResult?: XOR<PRSResultNullableScalarRelationFilter, PRSResultWhereInput> | null
    prsAnalysis?: XOR<PRSAnalysisScalarRelationFilter, PRSAnalysisWhereInput>
    prsModel?: XOR<PRSModelScalarRelationFilter, PRSModelWhereInput>
  }

  export type PrioritizedModelOrderByWithRelationInput = {
    position?: SortOrder
    prsModelId?: SortOrder
    prsAnalysisId?: SortOrder
    prsResultId?: SortOrderInput | SortOrder
    prsResult?: PRSResultOrderByWithRelationInput
    prsAnalysis?: PRSAnalysisOrderByWithRelationInput
    prsModel?: PRSModelOrderByWithRelationInput
  }

  export type PrioritizedModelWhereUniqueInput = Prisma.AtLeast<{
    prsModelId_prsAnalysisId?: PrioritizedModelPrsModelIdPrsAnalysisIdCompoundUniqueInput
    AND?: PrioritizedModelWhereInput | PrioritizedModelWhereInput[]
    OR?: PrioritizedModelWhereInput[]
    NOT?: PrioritizedModelWhereInput | PrioritizedModelWhereInput[]
    position?: IntFilter<"PrioritizedModel"> | number
    prsModelId?: IntFilter<"PrioritizedModel"> | number
    prsAnalysisId?: IntFilter<"PrioritizedModel"> | number
    prsResultId?: IntNullableFilter<"PrioritizedModel"> | number | null
    prsResult?: XOR<PRSResultNullableScalarRelationFilter, PRSResultWhereInput> | null
    prsAnalysis?: XOR<PRSAnalysisScalarRelationFilter, PRSAnalysisWhereInput>
    prsModel?: XOR<PRSModelScalarRelationFilter, PRSModelWhereInput>
  }, "prsModelId_prsAnalysisId">

  export type PrioritizedModelOrderByWithAggregationInput = {
    position?: SortOrder
    prsModelId?: SortOrder
    prsAnalysisId?: SortOrder
    prsResultId?: SortOrderInput | SortOrder
    _count?: PrioritizedModelCountOrderByAggregateInput
    _avg?: PrioritizedModelAvgOrderByAggregateInput
    _max?: PrioritizedModelMaxOrderByAggregateInput
    _min?: PrioritizedModelMinOrderByAggregateInput
    _sum?: PrioritizedModelSumOrderByAggregateInput
  }

  export type PrioritizedModelScalarWhereWithAggregatesInput = {
    AND?: PrioritizedModelScalarWhereWithAggregatesInput | PrioritizedModelScalarWhereWithAggregatesInput[]
    OR?: PrioritizedModelScalarWhereWithAggregatesInput[]
    NOT?: PrioritizedModelScalarWhereWithAggregatesInput | PrioritizedModelScalarWhereWithAggregatesInput[]
    position?: IntWithAggregatesFilter<"PrioritizedModel"> | number
    prsModelId?: IntWithAggregatesFilter<"PrioritizedModel"> | number
    prsAnalysisId?: IntWithAggregatesFilter<"PrioritizedModel"> | number
    prsResultId?: IntNullableWithAggregatesFilter<"PrioritizedModel"> | number | null
  }

  export type PRSResultWhereInput = {
    AND?: PRSResultWhereInput | PRSResultWhereInput[]
    OR?: PRSResultWhereInput[]
    NOT?: PRSResultWhereInput | PRSResultWhereInput[]
    id?: IntFilter<"PRSResult"> | number
    prs?: FloatFilter<"PRSResult"> | number
    percentile?: StringFilter<"PRSResult"> | string
    overlapPercent?: FloatFilter<"PRSResult"> | number
    prsModelId?: IntFilter<"PRSResult"> | number
    prsAnalysisId?: IntFilter<"PRSResult"> | number
    prioritizedModel?: XOR<PrioritizedModelScalarRelationFilter, PrioritizedModelWhereInput>
  }

  export type PRSResultOrderByWithRelationInput = {
    id?: SortOrder
    prs?: SortOrder
    percentile?: SortOrder
    overlapPercent?: SortOrder
    prsModelId?: SortOrder
    prsAnalysisId?: SortOrder
    prioritizedModel?: PrioritizedModelOrderByWithRelationInput
    _relevance?: PRSResultOrderByRelevanceInput
  }

  export type PRSResultWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    prsModelId_prsAnalysisId?: PRSResultPrsModelIdPrsAnalysisIdCompoundUniqueInput
    AND?: PRSResultWhereInput | PRSResultWhereInput[]
    OR?: PRSResultWhereInput[]
    NOT?: PRSResultWhereInput | PRSResultWhereInput[]
    prs?: FloatFilter<"PRSResult"> | number
    percentile?: StringFilter<"PRSResult"> | string
    overlapPercent?: FloatFilter<"PRSResult"> | number
    prsModelId?: IntFilter<"PRSResult"> | number
    prsAnalysisId?: IntFilter<"PRSResult"> | number
    prioritizedModel?: XOR<PrioritizedModelScalarRelationFilter, PrioritizedModelWhereInput>
  }, "id" | "prsModelId_prsAnalysisId">

  export type PRSResultOrderByWithAggregationInput = {
    id?: SortOrder
    prs?: SortOrder
    percentile?: SortOrder
    overlapPercent?: SortOrder
    prsModelId?: SortOrder
    prsAnalysisId?: SortOrder
    _count?: PRSResultCountOrderByAggregateInput
    _avg?: PRSResultAvgOrderByAggregateInput
    _max?: PRSResultMaxOrderByAggregateInput
    _min?: PRSResultMinOrderByAggregateInput
    _sum?: PRSResultSumOrderByAggregateInput
  }

  export type PRSResultScalarWhereWithAggregatesInput = {
    AND?: PRSResultScalarWhereWithAggregatesInput | PRSResultScalarWhereWithAggregatesInput[]
    OR?: PRSResultScalarWhereWithAggregatesInput[]
    NOT?: PRSResultScalarWhereWithAggregatesInput | PRSResultScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PRSResult"> | number
    prs?: FloatWithAggregatesFilter<"PRSResult"> | number
    percentile?: StringWithAggregatesFilter<"PRSResult"> | string
    overlapPercent?: FloatWithAggregatesFilter<"PRSResult"> | number
    prsModelId?: IntWithAggregatesFilter<"PRSResult"> | number
    prsAnalysisId?: IntWithAggregatesFilter<"PRSResult"> | number
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: IntFilter<"Patient"> | number
    patientId?: StringFilter<"Patient"> | string
    genotypingMethod?: StringNullableFilter<"Patient"> | string | null
    DataFilePath?: StringFilter<"Patient"> | string
    DataFilteFormat?: StringFilter<"Patient"> | string
    prsAnalyses?: PRSAnalysisListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    genotypingMethod?: SortOrderInput | SortOrder
    DataFilePath?: SortOrder
    DataFilteFormat?: SortOrder
    prsAnalyses?: PRSAnalysisOrderByRelationAggregateInput
    _relevance?: PatientOrderByRelevanceInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    patientId?: StringFilter<"Patient"> | string
    genotypingMethod?: StringNullableFilter<"Patient"> | string | null
    DataFilePath?: StringFilter<"Patient"> | string
    DataFilteFormat?: StringFilter<"Patient"> | string
    prsAnalyses?: PRSAnalysisListRelationFilter
  }, "id">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    genotypingMethod?: SortOrderInput | SortOrder
    DataFilePath?: SortOrder
    DataFilteFormat?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _avg?: PatientAvgOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
    _sum?: PatientSumOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Patient"> | number
    patientId?: StringWithAggregatesFilter<"Patient"> | string
    genotypingMethod?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    DataFilePath?: StringWithAggregatesFilter<"Patient"> | string
    DataFilteFormat?: StringWithAggregatesFilter<"Patient"> | string
  }

  export type TraitCategoryCreateInput = {
    label: string
    traits?: TraitToTraitCategoryCreateNestedManyWithoutTraitCategoryInput
  }

  export type TraitCategoryUncheckedCreateInput = {
    id?: number
    label: string
    traits?: TraitToTraitCategoryUncheckedCreateNestedManyWithoutTraitCategoryInput
  }

  export type TraitCategoryUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    traits?: TraitToTraitCategoryUpdateManyWithoutTraitCategoryNestedInput
  }

  export type TraitCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    traits?: TraitToTraitCategoryUncheckedUpdateManyWithoutTraitCategoryNestedInput
  }

  export type TraitCategoryCreateManyInput = {
    id?: number
    label: string
  }

  export type TraitCategoryUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
  }

  export type TraitCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
  }

  export type TraitCreateInput = {
    label: string
    description?: string | null
    URL?: string | null
    efoId?: string | null
    mondoId?: string | null
    hpoId?: string | null
    orphaId?: string | null
    otherId?: string | null
    prsModels?: PRSModelToTraitCreateNestedManyWithoutTraitInput
    categories?: TraitToTraitCategoryCreateNestedManyWithoutTraitInput
  }

  export type TraitUncheckedCreateInput = {
    id?: number
    label: string
    description?: string | null
    URL?: string | null
    efoId?: string | null
    mondoId?: string | null
    hpoId?: string | null
    orphaId?: string | null
    otherId?: string | null
    prsModels?: PRSModelToTraitUncheckedCreateNestedManyWithoutTraitInput
    categories?: TraitToTraitCategoryUncheckedCreateNestedManyWithoutTraitInput
  }

  export type TraitUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    efoId?: NullableStringFieldUpdateOperationsInput | string | null
    mondoId?: NullableStringFieldUpdateOperationsInput | string | null
    hpoId?: NullableStringFieldUpdateOperationsInput | string | null
    orphaId?: NullableStringFieldUpdateOperationsInput | string | null
    otherId?: NullableStringFieldUpdateOperationsInput | string | null
    prsModels?: PRSModelToTraitUpdateManyWithoutTraitNestedInput
    categories?: TraitToTraitCategoryUpdateManyWithoutTraitNestedInput
  }

  export type TraitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    efoId?: NullableStringFieldUpdateOperationsInput | string | null
    mondoId?: NullableStringFieldUpdateOperationsInput | string | null
    hpoId?: NullableStringFieldUpdateOperationsInput | string | null
    orphaId?: NullableStringFieldUpdateOperationsInput | string | null
    otherId?: NullableStringFieldUpdateOperationsInput | string | null
    prsModels?: PRSModelToTraitUncheckedUpdateManyWithoutTraitNestedInput
    categories?: TraitToTraitCategoryUncheckedUpdateManyWithoutTraitNestedInput
  }

  export type TraitCreateManyInput = {
    id?: number
    label: string
    description?: string | null
    URL?: string | null
    efoId?: string | null
    mondoId?: string | null
    hpoId?: string | null
    orphaId?: string | null
    otherId?: string | null
  }

  export type TraitUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    efoId?: NullableStringFieldUpdateOperationsInput | string | null
    mondoId?: NullableStringFieldUpdateOperationsInput | string | null
    hpoId?: NullableStringFieldUpdateOperationsInput | string | null
    orphaId?: NullableStringFieldUpdateOperationsInput | string | null
    otherId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TraitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    efoId?: NullableStringFieldUpdateOperationsInput | string | null
    mondoId?: NullableStringFieldUpdateOperationsInput | string | null
    hpoId?: NullableStringFieldUpdateOperationsInput | string | null
    orphaId?: NullableStringFieldUpdateOperationsInput | string | null
    otherId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TraitToTraitCategoryCreateInput = {
    traitCategory: TraitCategoryCreateNestedOneWithoutTraitsInput
    trait: TraitCreateNestedOneWithoutCategoriesInput
  }

  export type TraitToTraitCategoryUncheckedCreateInput = {
    traitId: number
    traitCategoryId: number
  }

  export type TraitToTraitCategoryUpdateInput = {
    traitCategory?: TraitCategoryUpdateOneRequiredWithoutTraitsNestedInput
    trait?: TraitUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type TraitToTraitCategoryUncheckedUpdateInput = {
    traitId?: IntFieldUpdateOperationsInput | number
    traitCategoryId?: IntFieldUpdateOperationsInput | number
  }

  export type TraitToTraitCategoryCreateManyInput = {
    traitId: number
    traitCategoryId: number
  }

  export type TraitToTraitCategoryUpdateManyMutationInput = {

  }

  export type TraitToTraitCategoryUncheckedUpdateManyInput = {
    traitId?: IntFieldUpdateOperationsInput | number
    traitCategoryId?: IntFieldUpdateOperationsInput | number
  }

  export type PRSModelCreateInput = {
    name: string
    numberOfSNP?: number | null
    pgscId?: string | null
    pgscURL?: string | null
    broadAncestryCategories?: BroadAncestryInModelCreateNestedManyWithoutPrsModelInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleCreateNestedManyWithoutPrsModelInput
    modelEvaluations?: ModelEvaluationCreateNestedManyWithoutPrsModelInput
    publication: PublicationCreateNestedOneWithoutPrsModelsInput
    traits?: PRSModelToTraitCreateNestedManyWithoutPrsModelInput
    prioritizedModels?: PrioritizedModelCreateNestedManyWithoutPrsModelInput
    scoringFiles?: ScoringFileCreateNestedOneWithoutPrsModelInput
  }

  export type PRSModelUncheckedCreateInput = {
    id?: number
    name: string
    numberOfSNP?: number | null
    pgscId?: string | null
    pgscURL?: string | null
    publicationId: number
    broadAncestryCategories?: BroadAncestryInModelUncheckedCreateNestedManyWithoutPrsModelInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedCreateNestedManyWithoutPrsModelInput
    modelEvaluations?: ModelEvaluationUncheckedCreateNestedManyWithoutPrsModelInput
    traits?: PRSModelToTraitUncheckedCreateNestedManyWithoutPrsModelInput
    prioritizedModels?: PrioritizedModelUncheckedCreateNestedManyWithoutPrsModelInput
    scoringFiles?: ScoringFileUncheckedCreateNestedOneWithoutPrsModelInput
  }

  export type PRSModelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
    broadAncestryCategories?: BroadAncestryInModelUpdateManyWithoutPrsModelNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUpdateManyWithoutPrsModelNestedInput
    modelEvaluations?: ModelEvaluationUpdateManyWithoutPrsModelNestedInput
    publication?: PublicationUpdateOneRequiredWithoutPrsModelsNestedInput
    traits?: PRSModelToTraitUpdateManyWithoutPrsModelNestedInput
    prioritizedModels?: PrioritizedModelUpdateManyWithoutPrsModelNestedInput
    scoringFiles?: ScoringFileUpdateOneWithoutPrsModelNestedInput
  }

  export type PRSModelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
    publicationId?: IntFieldUpdateOperationsInput | number
    broadAncestryCategories?: BroadAncestryInModelUncheckedUpdateManyWithoutPrsModelNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedUpdateManyWithoutPrsModelNestedInput
    modelEvaluations?: ModelEvaluationUncheckedUpdateManyWithoutPrsModelNestedInput
    traits?: PRSModelToTraitUncheckedUpdateManyWithoutPrsModelNestedInput
    prioritizedModels?: PrioritizedModelUncheckedUpdateManyWithoutPrsModelNestedInput
    scoringFiles?: ScoringFileUncheckedUpdateOneWithoutPrsModelNestedInput
  }

  export type PRSModelCreateManyInput = {
    id?: number
    name: string
    numberOfSNP?: number | null
    pgscId?: string | null
    pgscURL?: string | null
    publicationId: number
  }

  export type PRSModelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PRSModelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
    publicationId?: IntFieldUpdateOperationsInput | number
  }

  export type PRSModelToTraitCreateInput = {
    prsModel: PRSModelCreateNestedOneWithoutTraitsInput
    trait: TraitCreateNestedOneWithoutPrsModelsInput
  }

  export type PRSModelToTraitUncheckedCreateInput = {
    prsModelId: number
    traitId: number
  }

  export type PRSModelToTraitUpdateInput = {
    prsModel?: PRSModelUpdateOneRequiredWithoutTraitsNestedInput
    trait?: TraitUpdateOneRequiredWithoutPrsModelsNestedInput
  }

  export type PRSModelToTraitUncheckedUpdateInput = {
    prsModelId?: IntFieldUpdateOperationsInput | number
    traitId?: IntFieldUpdateOperationsInput | number
  }

  export type PRSModelToTraitCreateManyInput = {
    prsModelId: number
    traitId: number
  }

  export type PRSModelToTraitUpdateManyMutationInput = {

  }

  export type PRSModelToTraitUncheckedUpdateManyInput = {
    prsModelId?: IntFieldUpdateOperationsInput | number
    traitId?: IntFieldUpdateOperationsInput | number
  }

  export type ScoringFileCreateInput = {
    assembly: $Enums.AssemblyType
    path: string
    prsModel: PRSModelCreateNestedOneWithoutScoringFilesInput
  }

  export type ScoringFileUncheckedCreateInput = {
    id?: number
    assembly: $Enums.AssemblyType
    path: string
    prsModelId: number
  }

  export type ScoringFileUpdateInput = {
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    path?: StringFieldUpdateOperationsInput | string
    prsModel?: PRSModelUpdateOneRequiredWithoutScoringFilesNestedInput
  }

  export type ScoringFileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    path?: StringFieldUpdateOperationsInput | string
    prsModelId?: IntFieldUpdateOperationsInput | number
  }

  export type ScoringFileCreateManyInput = {
    id?: number
    assembly: $Enums.AssemblyType
    path: string
    prsModelId: number
  }

  export type ScoringFileUpdateManyMutationInput = {
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    path?: StringFieldUpdateOperationsInput | string
  }

  export type ScoringFileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    path?: StringFieldUpdateOperationsInput | string
    prsModelId?: IntFieldUpdateOperationsInput | number
  }

  export type PublicationCreateInput = {
    title: string
    journal: string
    author: string
    date?: Date | string | null
    year: number
    PMID?: string | null
    DOI?: string | null
    pgpId?: string | null
    modelEvaluations?: ModelEvaluationCreateNestedManyWithoutPublicationInput
    prsModels?: PRSModelCreateNestedManyWithoutPublicationInput
  }

  export type PublicationUncheckedCreateInput = {
    id?: number
    title: string
    journal: string
    author: string
    date?: Date | string | null
    year: number
    PMID?: string | null
    DOI?: string | null
    pgpId?: string | null
    modelEvaluations?: ModelEvaluationUncheckedCreateNestedManyWithoutPublicationInput
    prsModels?: PRSModelUncheckedCreateNestedManyWithoutPublicationInput
  }

  export type PublicationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    journal?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    year?: IntFieldUpdateOperationsInput | number
    PMID?: NullableStringFieldUpdateOperationsInput | string | null
    DOI?: NullableStringFieldUpdateOperationsInput | string | null
    pgpId?: NullableStringFieldUpdateOperationsInput | string | null
    modelEvaluations?: ModelEvaluationUpdateManyWithoutPublicationNestedInput
    prsModels?: PRSModelUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    journal?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    year?: IntFieldUpdateOperationsInput | number
    PMID?: NullableStringFieldUpdateOperationsInput | string | null
    DOI?: NullableStringFieldUpdateOperationsInput | string | null
    pgpId?: NullableStringFieldUpdateOperationsInput | string | null
    modelEvaluations?: ModelEvaluationUncheckedUpdateManyWithoutPublicationNestedInput
    prsModels?: PRSModelUncheckedUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationCreateManyInput = {
    id?: number
    title: string
    journal: string
    author: string
    date?: Date | string | null
    year: number
    PMID?: string | null
    DOI?: string | null
    pgpId?: string | null
  }

  export type PublicationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    journal?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    year?: IntFieldUpdateOperationsInput | number
    PMID?: NullableStringFieldUpdateOperationsInput | string | null
    DOI?: NullableStringFieldUpdateOperationsInput | string | null
    pgpId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PublicationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    journal?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    year?: IntFieldUpdateOperationsInput | number
    PMID?: NullableStringFieldUpdateOperationsInput | string | null
    DOI?: NullableStringFieldUpdateOperationsInput | string | null
    pgpId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ModelEvaluationCreateInput = {
    reportedTrait: string
    covariates?: string | null
    ppmId?: string | null
    evaluationPopulationSample: EvaluationPopulationSampleCreateNestedOneWithoutModelEvaluationsInput
    prsModel: PRSModelCreateNestedOneWithoutModelEvaluationsInput
    publication: PublicationCreateNestedOneWithoutModelEvaluationsInput
    metricEvaluations?: PerformanceMetricEvaluationCreateNestedManyWithoutModelEvaluationInput
  }

  export type ModelEvaluationUncheckedCreateInput = {
    id?: number
    reportedTrait: string
    covariates?: string | null
    ppmId?: string | null
    prsModelId: number
    publicationId: number
    evaluationPopulationSampleId: number
    metricEvaluations?: PerformanceMetricEvaluationUncheckedCreateNestedManyWithoutModelEvaluationInput
  }

  export type ModelEvaluationUpdateInput = {
    reportedTrait?: StringFieldUpdateOperationsInput | string
    covariates?: NullableStringFieldUpdateOperationsInput | string | null
    ppmId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationPopulationSample?: EvaluationPopulationSampleUpdateOneRequiredWithoutModelEvaluationsNestedInput
    prsModel?: PRSModelUpdateOneRequiredWithoutModelEvaluationsNestedInput
    publication?: PublicationUpdateOneRequiredWithoutModelEvaluationsNestedInput
    metricEvaluations?: PerformanceMetricEvaluationUpdateManyWithoutModelEvaluationNestedInput
  }

  export type ModelEvaluationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedTrait?: StringFieldUpdateOperationsInput | string
    covariates?: NullableStringFieldUpdateOperationsInput | string | null
    ppmId?: NullableStringFieldUpdateOperationsInput | string | null
    prsModelId?: IntFieldUpdateOperationsInput | number
    publicationId?: IntFieldUpdateOperationsInput | number
    evaluationPopulationSampleId?: IntFieldUpdateOperationsInput | number
    metricEvaluations?: PerformanceMetricEvaluationUncheckedUpdateManyWithoutModelEvaluationNestedInput
  }

  export type ModelEvaluationCreateManyInput = {
    id?: number
    reportedTrait: string
    covariates?: string | null
    ppmId?: string | null
    prsModelId: number
    publicationId: number
    evaluationPopulationSampleId: number
  }

  export type ModelEvaluationUpdateManyMutationInput = {
    reportedTrait?: StringFieldUpdateOperationsInput | string
    covariates?: NullableStringFieldUpdateOperationsInput | string | null
    ppmId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ModelEvaluationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedTrait?: StringFieldUpdateOperationsInput | string
    covariates?: NullableStringFieldUpdateOperationsInput | string | null
    ppmId?: NullableStringFieldUpdateOperationsInput | string | null
    prsModelId?: IntFieldUpdateOperationsInput | number
    publicationId?: IntFieldUpdateOperationsInput | number
    evaluationPopulationSampleId?: IntFieldUpdateOperationsInput | number
  }

  export type PerformanceMetricEvaluationCreateInput = {
    estimate: number
    CILower?: number | null
    CIUpper?: number | null
    modelEvaluation: ModelEvaluationCreateNestedOneWithoutMetricEvaluationsInput
    performanceMetric: PerformanceMetricCreateNestedOneWithoutPerformanceMetricEvaluationsInput
  }

  export type PerformanceMetricEvaluationUncheckedCreateInput = {
    id?: number
    estimate: number
    CILower?: number | null
    CIUpper?: number | null
    modelEvaluationId: number
    performanceMetricId: number
  }

  export type PerformanceMetricEvaluationUpdateInput = {
    estimate?: FloatFieldUpdateOperationsInput | number
    CILower?: NullableFloatFieldUpdateOperationsInput | number | null
    CIUpper?: NullableFloatFieldUpdateOperationsInput | number | null
    modelEvaluation?: ModelEvaluationUpdateOneRequiredWithoutMetricEvaluationsNestedInput
    performanceMetric?: PerformanceMetricUpdateOneRequiredWithoutPerformanceMetricEvaluationsNestedInput
  }

  export type PerformanceMetricEvaluationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    estimate?: FloatFieldUpdateOperationsInput | number
    CILower?: NullableFloatFieldUpdateOperationsInput | number | null
    CIUpper?: NullableFloatFieldUpdateOperationsInput | number | null
    modelEvaluationId?: IntFieldUpdateOperationsInput | number
    performanceMetricId?: IntFieldUpdateOperationsInput | number
  }

  export type PerformanceMetricEvaluationCreateManyInput = {
    id?: number
    estimate: number
    CILower?: number | null
    CIUpper?: number | null
    modelEvaluationId: number
    performanceMetricId: number
  }

  export type PerformanceMetricEvaluationUpdateManyMutationInput = {
    estimate?: FloatFieldUpdateOperationsInput | number
    CILower?: NullableFloatFieldUpdateOperationsInput | number | null
    CIUpper?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PerformanceMetricEvaluationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    estimate?: FloatFieldUpdateOperationsInput | number
    CILower?: NullableFloatFieldUpdateOperationsInput | number | null
    CIUpper?: NullableFloatFieldUpdateOperationsInput | number | null
    modelEvaluationId?: IntFieldUpdateOperationsInput | number
    performanceMetricId?: IntFieldUpdateOperationsInput | number
  }

  export type PerformanceMetricCreateInput = {
    nameShort: string
    nameLong?: string | null
    type: $Enums.PerformanceMetricType
    performanceMetricEvaluations?: PerformanceMetricEvaluationCreateNestedManyWithoutPerformanceMetricInput
  }

  export type PerformanceMetricUncheckedCreateInput = {
    id?: number
    nameShort: string
    nameLong?: string | null
    type: $Enums.PerformanceMetricType
    performanceMetricEvaluations?: PerformanceMetricEvaluationUncheckedCreateNestedManyWithoutPerformanceMetricInput
  }

  export type PerformanceMetricUpdateInput = {
    nameShort?: StringFieldUpdateOperationsInput | string
    nameLong?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPerformanceMetricTypeFieldUpdateOperationsInput | $Enums.PerformanceMetricType
    performanceMetricEvaluations?: PerformanceMetricEvaluationUpdateManyWithoutPerformanceMetricNestedInput
  }

  export type PerformanceMetricUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameShort?: StringFieldUpdateOperationsInput | string
    nameLong?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPerformanceMetricTypeFieldUpdateOperationsInput | $Enums.PerformanceMetricType
    performanceMetricEvaluations?: PerformanceMetricEvaluationUncheckedUpdateManyWithoutPerformanceMetricNestedInput
  }

  export type PerformanceMetricCreateManyInput = {
    id?: number
    nameShort: string
    nameLong?: string | null
    type: $Enums.PerformanceMetricType
  }

  export type PerformanceMetricUpdateManyMutationInput = {
    nameShort?: StringFieldUpdateOperationsInput | string
    nameLong?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPerformanceMetricTypeFieldUpdateOperationsInput | $Enums.PerformanceMetricType
  }

  export type PerformanceMetricUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameShort?: StringFieldUpdateOperationsInput | string
    nameLong?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPerformanceMetricTypeFieldUpdateOperationsInput | $Enums.PerformanceMetricType
  }

  export type EvaluationPopulationSampleCreateInput = {
    numberOfIndividuals: number
    numberOfCases?: number | null
    numberOfControls?: number | null
    percentMale?: number | null
    age?: number | null
    ageUnits?: string | null
    ancestryBroad: string
    ancestryDetails?: string | null
    cohort: string
    gcId?: string | null
    sourcePMID?: string | null
    sourceDOI?: string | null
    phenotypeFree?: string | null
    pssId: string
    broadAncestryCategory: BroadAncestryCategoryCreateNestedOneWithoutEvaluationPopulationSamplesInput
    modelEvaluations?: ModelEvaluationCreateNestedManyWithoutEvaluationPopulationSampleInput
  }

  export type EvaluationPopulationSampleUncheckedCreateInput = {
    id?: number
    numberOfIndividuals: number
    numberOfCases?: number | null
    numberOfControls?: number | null
    percentMale?: number | null
    age?: number | null
    ageUnits?: string | null
    ancestryBroad: string
    ancestryDetails?: string | null
    cohort: string
    gcId?: string | null
    sourcePMID?: string | null
    sourceDOI?: string | null
    phenotypeFree?: string | null
    pssId: string
    broadAncestryId: number
    modelEvaluations?: ModelEvaluationUncheckedCreateNestedManyWithoutEvaluationPopulationSampleInput
  }

  export type EvaluationPopulationSampleUpdateInput = {
    numberOfIndividuals?: IntFieldUpdateOperationsInput | number
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    phenotypeFree?: NullableStringFieldUpdateOperationsInput | string | null
    pssId?: StringFieldUpdateOperationsInput | string
    broadAncestryCategory?: BroadAncestryCategoryUpdateOneRequiredWithoutEvaluationPopulationSamplesNestedInput
    modelEvaluations?: ModelEvaluationUpdateManyWithoutEvaluationPopulationSampleNestedInput
  }

  export type EvaluationPopulationSampleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    numberOfIndividuals?: IntFieldUpdateOperationsInput | number
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    phenotypeFree?: NullableStringFieldUpdateOperationsInput | string | null
    pssId?: StringFieldUpdateOperationsInput | string
    broadAncestryId?: IntFieldUpdateOperationsInput | number
    modelEvaluations?: ModelEvaluationUncheckedUpdateManyWithoutEvaluationPopulationSampleNestedInput
  }

  export type EvaluationPopulationSampleCreateManyInput = {
    id?: number
    numberOfIndividuals: number
    numberOfCases?: number | null
    numberOfControls?: number | null
    percentMale?: number | null
    age?: number | null
    ageUnits?: string | null
    ancestryBroad: string
    ancestryDetails?: string | null
    cohort: string
    gcId?: string | null
    sourcePMID?: string | null
    sourceDOI?: string | null
    phenotypeFree?: string | null
    pssId: string
    broadAncestryId: number
  }

  export type EvaluationPopulationSampleUpdateManyMutationInput = {
    numberOfIndividuals?: IntFieldUpdateOperationsInput | number
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    phenotypeFree?: NullableStringFieldUpdateOperationsInput | string | null
    pssId?: StringFieldUpdateOperationsInput | string
  }

  export type EvaluationPopulationSampleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    numberOfIndividuals?: IntFieldUpdateOperationsInput | number
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    phenotypeFree?: NullableStringFieldUpdateOperationsInput | string | null
    pssId?: StringFieldUpdateOperationsInput | string
    broadAncestryId?: IntFieldUpdateOperationsInput | number
  }

  export type BroadAncestryCategoryCreateInput = {
    symbol: string
    label: string
    broadAncestryInModels?: BroadAncestryInModelCreateNestedManyWithoutBroadAncestryCategoryInput
    broadAncestryInRefPops?: BroadAncestryInRefPopCreateNestedManyWithoutBroadAncestryCategoryInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleCreateNestedManyWithoutBroadAncestryCategoryInput
    EvaluationPopulationSamples?: EvaluationPopulationSampleCreateNestedManyWithoutBroadAncestryCategoryInput
  }

  export type BroadAncestryCategoryUncheckedCreateInput = {
    id?: number
    symbol: string
    label: string
    broadAncestryInModels?: BroadAncestryInModelUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput
    broadAncestryInRefPops?: BroadAncestryInRefPopUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput
    EvaluationPopulationSamples?: EvaluationPopulationSampleUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput
  }

  export type BroadAncestryCategoryUpdateInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    broadAncestryInModels?: BroadAncestryInModelUpdateManyWithoutBroadAncestryCategoryNestedInput
    broadAncestryInRefPops?: BroadAncestryInRefPopUpdateManyWithoutBroadAncestryCategoryNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUpdateManyWithoutBroadAncestryCategoryNestedInput
    EvaluationPopulationSamples?: EvaluationPopulationSampleUpdateManyWithoutBroadAncestryCategoryNestedInput
  }

  export type BroadAncestryCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    broadAncestryInModels?: BroadAncestryInModelUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput
    broadAncestryInRefPops?: BroadAncestryInRefPopUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput
    EvaluationPopulationSamples?: EvaluationPopulationSampleUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput
  }

  export type BroadAncestryCategoryCreateManyInput = {
    id?: number
    symbol: string
    label: string
  }

  export type BroadAncestryCategoryUpdateManyMutationInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
  }

  export type BroadAncestryCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
  }

  export type BroadAncestryInModelCreateInput = {
    percentage: number
    broadAncestryCategory: BroadAncestryCategoryCreateNestedOneWithoutBroadAncestryInModelsInput
    prsModel: PRSModelCreateNestedOneWithoutBroadAncestryCategoriesInput
  }

  export type BroadAncestryInModelUncheckedCreateInput = {
    percentage: number
    broadAncestryId: number
    prsModelId: number
  }

  export type BroadAncestryInModelUpdateInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    broadAncestryCategory?: BroadAncestryCategoryUpdateOneRequiredWithoutBroadAncestryInModelsNestedInput
    prsModel?: PRSModelUpdateOneRequiredWithoutBroadAncestryCategoriesNestedInput
  }

  export type BroadAncestryInModelUncheckedUpdateInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    broadAncestryId?: IntFieldUpdateOperationsInput | number
    prsModelId?: IntFieldUpdateOperationsInput | number
  }

  export type BroadAncestryInModelCreateManyInput = {
    percentage: number
    broadAncestryId: number
    prsModelId: number
  }

  export type BroadAncestryInModelUpdateManyMutationInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
  }

  export type BroadAncestryInModelUncheckedUpdateManyInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    broadAncestryId?: IntFieldUpdateOperationsInput | number
    prsModelId?: IntFieldUpdateOperationsInput | number
  }

  export type DevelopmentPopulationSampleCreateInput = {
    numberOfIndividuals?: number | null
    numberOfCases?: number | null
    numberOfControls?: number | null
    percentMale?: number | null
    age?: number | null
    ageUnits?: string | null
    ancestryBroad: string
    ancestryDetails?: string | null
    cohort: string
    gcId?: string | null
    sourcePMID?: string | null
    sourceDOI?: string | null
    role: $Enums.DevelopmentRoleType
    broadAncestryCategory: BroadAncestryCategoryCreateNestedOneWithoutDevelopmentPopulationSamplesInput
    prsModel: PRSModelCreateNestedOneWithoutDevelopmentPopulationSamplesInput
  }

  export type DevelopmentPopulationSampleUncheckedCreateInput = {
    id?: number
    numberOfIndividuals?: number | null
    numberOfCases?: number | null
    numberOfControls?: number | null
    percentMale?: number | null
    age?: number | null
    ageUnits?: string | null
    ancestryBroad: string
    ancestryDetails?: string | null
    cohort: string
    gcId?: string | null
    sourcePMID?: string | null
    sourceDOI?: string | null
    role: $Enums.DevelopmentRoleType
    prsModelId: number
    broadAncestryId: number
  }

  export type DevelopmentPopulationSampleUpdateInput = {
    numberOfIndividuals?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumDevelopmentRoleTypeFieldUpdateOperationsInput | $Enums.DevelopmentRoleType
    broadAncestryCategory?: BroadAncestryCategoryUpdateOneRequiredWithoutDevelopmentPopulationSamplesNestedInput
    prsModel?: PRSModelUpdateOneRequiredWithoutDevelopmentPopulationSamplesNestedInput
  }

  export type DevelopmentPopulationSampleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    numberOfIndividuals?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumDevelopmentRoleTypeFieldUpdateOperationsInput | $Enums.DevelopmentRoleType
    prsModelId?: IntFieldUpdateOperationsInput | number
    broadAncestryId?: IntFieldUpdateOperationsInput | number
  }

  export type DevelopmentPopulationSampleCreateManyInput = {
    id?: number
    numberOfIndividuals?: number | null
    numberOfCases?: number | null
    numberOfControls?: number | null
    percentMale?: number | null
    age?: number | null
    ageUnits?: string | null
    ancestryBroad: string
    ancestryDetails?: string | null
    cohort: string
    gcId?: string | null
    sourcePMID?: string | null
    sourceDOI?: string | null
    role: $Enums.DevelopmentRoleType
    prsModelId: number
    broadAncestryId: number
  }

  export type DevelopmentPopulationSampleUpdateManyMutationInput = {
    numberOfIndividuals?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumDevelopmentRoleTypeFieldUpdateOperationsInput | $Enums.DevelopmentRoleType
  }

  export type DevelopmentPopulationSampleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    numberOfIndividuals?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumDevelopmentRoleTypeFieldUpdateOperationsInput | $Enums.DevelopmentRoleType
    prsModelId?: IntFieldUpdateOperationsInput | number
    broadAncestryId?: IntFieldUpdateOperationsInput | number
  }

  export type BroadAncestryInRefPopCreateInput = {
    percentage: number
    broadAncestryCategory: BroadAncestryCategoryCreateNestedOneWithoutBroadAncestryInRefPopsInput
    referencePopulation: ReferencePopulationCreateNestedOneWithoutBroadAncestryCategoriesInput
  }

  export type BroadAncestryInRefPopUncheckedCreateInput = {
    percentage: number
    broadAncestryId: number
    referencePopulationId: number
  }

  export type BroadAncestryInRefPopUpdateInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    broadAncestryCategory?: BroadAncestryCategoryUpdateOneRequiredWithoutBroadAncestryInRefPopsNestedInput
    referencePopulation?: ReferencePopulationUpdateOneRequiredWithoutBroadAncestryCategoriesNestedInput
  }

  export type BroadAncestryInRefPopUncheckedUpdateInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    broadAncestryId?: IntFieldUpdateOperationsInput | number
    referencePopulationId?: IntFieldUpdateOperationsInput | number
  }

  export type BroadAncestryInRefPopCreateManyInput = {
    percentage: number
    broadAncestryId: number
    referencePopulationId: number
  }

  export type BroadAncestryInRefPopUpdateManyMutationInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
  }

  export type BroadAncestryInRefPopUncheckedUpdateManyInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    broadAncestryId?: IntFieldUpdateOperationsInput | number
    referencePopulationId?: IntFieldUpdateOperationsInput | number
  }

  export type ReferencePopulationCreateInput = {
    name: string
    description?: string | null
    studyURL?: string | null
    assembly: $Enums.AssemblyType
    numberOfindividuals?: number | null
    numberOfvariants?: number | null
    studyName: string
    date: Date | string
    path: string
    broadAncestryCategories?: BroadAncestryInRefPopCreateNestedManyWithoutReferencePopulationInput
    prsAnalyses?: PRSAnalysisCreateNestedManyWithoutReferencePopulationInput
  }

  export type ReferencePopulationUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    studyURL?: string | null
    assembly: $Enums.AssemblyType
    numberOfindividuals?: number | null
    numberOfvariants?: number | null
    studyName: string
    date: Date | string
    path: string
    broadAncestryCategories?: BroadAncestryInRefPopUncheckedCreateNestedManyWithoutReferencePopulationInput
    prsAnalyses?: PRSAnalysisUncheckedCreateNestedManyWithoutReferencePopulationInput
  }

  export type ReferencePopulationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    studyURL?: NullableStringFieldUpdateOperationsInput | string | null
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    numberOfindividuals?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfvariants?: NullableIntFieldUpdateOperationsInput | number | null
    studyName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: StringFieldUpdateOperationsInput | string
    broadAncestryCategories?: BroadAncestryInRefPopUpdateManyWithoutReferencePopulationNestedInput
    prsAnalyses?: PRSAnalysisUpdateManyWithoutReferencePopulationNestedInput
  }

  export type ReferencePopulationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    studyURL?: NullableStringFieldUpdateOperationsInput | string | null
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    numberOfindividuals?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfvariants?: NullableIntFieldUpdateOperationsInput | number | null
    studyName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: StringFieldUpdateOperationsInput | string
    broadAncestryCategories?: BroadAncestryInRefPopUncheckedUpdateManyWithoutReferencePopulationNestedInput
    prsAnalyses?: PRSAnalysisUncheckedUpdateManyWithoutReferencePopulationNestedInput
  }

  export type ReferencePopulationCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    studyURL?: string | null
    assembly: $Enums.AssemblyType
    numberOfindividuals?: number | null
    numberOfvariants?: number | null
    studyName: string
    date: Date | string
    path: string
  }

  export type ReferencePopulationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    studyURL?: NullableStringFieldUpdateOperationsInput | string | null
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    numberOfindividuals?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfvariants?: NullableIntFieldUpdateOperationsInput | number | null
    studyName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: StringFieldUpdateOperationsInput | string
  }

  export type ReferencePopulationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    studyURL?: NullableStringFieldUpdateOperationsInput | string | null
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    numberOfindividuals?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfvariants?: NullableIntFieldUpdateOperationsInput | number | null
    studyName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: StringFieldUpdateOperationsInput | string
  }

  export type PRSAnalysisCreateInput = {
    name: string
    description?: string | null
    userId?: string | null
    date: string
    status: string
    HTMLResultPath: string
    ancestryThreshold: number
    overlapThreshold: number
    ancestryAdjustment: $Enums.AncestryAdjustmentType
    assembly: $Enums.AssemblyType
    patient: PatientCreateNestedOneWithoutPrsAnalysesInput
    referencePopulation: ReferencePopulationCreateNestedOneWithoutPrsAnalysesInput
    prioritizedModels?: PrioritizedModelCreateNestedManyWithoutPrsAnalysisInput
  }

  export type PRSAnalysisUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    userId?: string | null
    date: string
    status: string
    HTMLResultPath: string
    ancestryThreshold: number
    overlapThreshold: number
    ancestryAdjustment: $Enums.AncestryAdjustmentType
    assembly: $Enums.AssemblyType
    patientId: number
    referencePopulationId: number
    prioritizedModels?: PrioritizedModelUncheckedCreateNestedManyWithoutPrsAnalysisInput
  }

  export type PRSAnalysisUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    HTMLResultPath?: StringFieldUpdateOperationsInput | string
    ancestryThreshold?: IntFieldUpdateOperationsInput | number
    overlapThreshold?: IntFieldUpdateOperationsInput | number
    ancestryAdjustment?: EnumAncestryAdjustmentTypeFieldUpdateOperationsInput | $Enums.AncestryAdjustmentType
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    patient?: PatientUpdateOneRequiredWithoutPrsAnalysesNestedInput
    referencePopulation?: ReferencePopulationUpdateOneRequiredWithoutPrsAnalysesNestedInput
    prioritizedModels?: PrioritizedModelUpdateManyWithoutPrsAnalysisNestedInput
  }

  export type PRSAnalysisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    HTMLResultPath?: StringFieldUpdateOperationsInput | string
    ancestryThreshold?: IntFieldUpdateOperationsInput | number
    overlapThreshold?: IntFieldUpdateOperationsInput | number
    ancestryAdjustment?: EnumAncestryAdjustmentTypeFieldUpdateOperationsInput | $Enums.AncestryAdjustmentType
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    patientId?: IntFieldUpdateOperationsInput | number
    referencePopulationId?: IntFieldUpdateOperationsInput | number
    prioritizedModels?: PrioritizedModelUncheckedUpdateManyWithoutPrsAnalysisNestedInput
  }

  export type PRSAnalysisCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    userId?: string | null
    date: string
    status: string
    HTMLResultPath: string
    ancestryThreshold: number
    overlapThreshold: number
    ancestryAdjustment: $Enums.AncestryAdjustmentType
    assembly: $Enums.AssemblyType
    patientId: number
    referencePopulationId: number
  }

  export type PRSAnalysisUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    HTMLResultPath?: StringFieldUpdateOperationsInput | string
    ancestryThreshold?: IntFieldUpdateOperationsInput | number
    overlapThreshold?: IntFieldUpdateOperationsInput | number
    ancestryAdjustment?: EnumAncestryAdjustmentTypeFieldUpdateOperationsInput | $Enums.AncestryAdjustmentType
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
  }

  export type PRSAnalysisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    HTMLResultPath?: StringFieldUpdateOperationsInput | string
    ancestryThreshold?: IntFieldUpdateOperationsInput | number
    overlapThreshold?: IntFieldUpdateOperationsInput | number
    ancestryAdjustment?: EnumAncestryAdjustmentTypeFieldUpdateOperationsInput | $Enums.AncestryAdjustmentType
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    patientId?: IntFieldUpdateOperationsInput | number
    referencePopulationId?: IntFieldUpdateOperationsInput | number
  }

  export type PrioritizedModelCreateInput = {
    position: number
    prsResultId?: number | null
    prsResult?: PRSResultCreateNestedOneWithoutPrioritizedModelInput
    prsAnalysis: PRSAnalysisCreateNestedOneWithoutPrioritizedModelsInput
    prsModel: PRSModelCreateNestedOneWithoutPrioritizedModelsInput
  }

  export type PrioritizedModelUncheckedCreateInput = {
    position: number
    prsModelId: number
    prsAnalysisId: number
    prsResultId?: number | null
    prsResult?: PRSResultUncheckedCreateNestedOneWithoutPrioritizedModelInput
  }

  export type PrioritizedModelUpdateInput = {
    position?: IntFieldUpdateOperationsInput | number
    prsResultId?: NullableIntFieldUpdateOperationsInput | number | null
    prsResult?: PRSResultUpdateOneWithoutPrioritizedModelNestedInput
    prsAnalysis?: PRSAnalysisUpdateOneRequiredWithoutPrioritizedModelsNestedInput
    prsModel?: PRSModelUpdateOneRequiredWithoutPrioritizedModelsNestedInput
  }

  export type PrioritizedModelUncheckedUpdateInput = {
    position?: IntFieldUpdateOperationsInput | number
    prsModelId?: IntFieldUpdateOperationsInput | number
    prsAnalysisId?: IntFieldUpdateOperationsInput | number
    prsResultId?: NullableIntFieldUpdateOperationsInput | number | null
    prsResult?: PRSResultUncheckedUpdateOneWithoutPrioritizedModelNestedInput
  }

  export type PrioritizedModelCreateManyInput = {
    position: number
    prsModelId: number
    prsAnalysisId: number
    prsResultId?: number | null
  }

  export type PrioritizedModelUpdateManyMutationInput = {
    position?: IntFieldUpdateOperationsInput | number
    prsResultId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PrioritizedModelUncheckedUpdateManyInput = {
    position?: IntFieldUpdateOperationsInput | number
    prsModelId?: IntFieldUpdateOperationsInput | number
    prsAnalysisId?: IntFieldUpdateOperationsInput | number
    prsResultId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PRSResultCreateInput = {
    prs: number
    percentile: string
    overlapPercent: number
    prioritizedModel: PrioritizedModelCreateNestedOneWithoutPrsResultInput
  }

  export type PRSResultUncheckedCreateInput = {
    id?: number
    prs: number
    percentile: string
    overlapPercent: number
    prsModelId: number
    prsAnalysisId: number
  }

  export type PRSResultUpdateInput = {
    prs?: FloatFieldUpdateOperationsInput | number
    percentile?: StringFieldUpdateOperationsInput | string
    overlapPercent?: FloatFieldUpdateOperationsInput | number
    prioritizedModel?: PrioritizedModelUpdateOneRequiredWithoutPrsResultNestedInput
  }

  export type PRSResultUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    prs?: FloatFieldUpdateOperationsInput | number
    percentile?: StringFieldUpdateOperationsInput | string
    overlapPercent?: FloatFieldUpdateOperationsInput | number
    prsModelId?: IntFieldUpdateOperationsInput | number
    prsAnalysisId?: IntFieldUpdateOperationsInput | number
  }

  export type PRSResultCreateManyInput = {
    id?: number
    prs: number
    percentile: string
    overlapPercent: number
    prsModelId: number
    prsAnalysisId: number
  }

  export type PRSResultUpdateManyMutationInput = {
    prs?: FloatFieldUpdateOperationsInput | number
    percentile?: StringFieldUpdateOperationsInput | string
    overlapPercent?: FloatFieldUpdateOperationsInput | number
  }

  export type PRSResultUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    prs?: FloatFieldUpdateOperationsInput | number
    percentile?: StringFieldUpdateOperationsInput | string
    overlapPercent?: FloatFieldUpdateOperationsInput | number
    prsModelId?: IntFieldUpdateOperationsInput | number
    prsAnalysisId?: IntFieldUpdateOperationsInput | number
  }

  export type PatientCreateInput = {
    patientId: string
    genotypingMethod?: string | null
    DataFilePath: string
    DataFilteFormat: string
    prsAnalyses?: PRSAnalysisCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: number
    patientId: string
    genotypingMethod?: string | null
    DataFilePath: string
    DataFilteFormat: string
    prsAnalyses?: PRSAnalysisUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    genotypingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    DataFilePath?: StringFieldUpdateOperationsInput | string
    DataFilteFormat?: StringFieldUpdateOperationsInput | string
    prsAnalyses?: PRSAnalysisUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    genotypingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    DataFilePath?: StringFieldUpdateOperationsInput | string
    DataFilteFormat?: StringFieldUpdateOperationsInput | string
    prsAnalyses?: PRSAnalysisUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: number
    patientId: string
    genotypingMethod?: string | null
    DataFilePath: string
    DataFilteFormat: string
  }

  export type PatientUpdateManyMutationInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    genotypingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    DataFilePath?: StringFieldUpdateOperationsInput | string
    DataFilteFormat?: StringFieldUpdateOperationsInput | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    genotypingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    DataFilePath?: StringFieldUpdateOperationsInput | string
    DataFilteFormat?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type TraitToTraitCategoryListRelationFilter = {
    every?: TraitToTraitCategoryWhereInput
    some?: TraitToTraitCategoryWhereInput
    none?: TraitToTraitCategoryWhereInput
  }

  export type TraitToTraitCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TraitCategoryOrderByRelevanceInput = {
    fields: TraitCategoryOrderByRelevanceFieldEnum | TraitCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TraitCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
  }

  export type TraitCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TraitCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
  }

  export type TraitCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
  }

  export type TraitCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type PRSModelToTraitListRelationFilter = {
    every?: PRSModelToTraitWhereInput
    some?: PRSModelToTraitWhereInput
    none?: PRSModelToTraitWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PRSModelToTraitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TraitOrderByRelevanceInput = {
    fields: TraitOrderByRelevanceFieldEnum | TraitOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TraitCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    description?: SortOrder
    URL?: SortOrder
    efoId?: SortOrder
    mondoId?: SortOrder
    hpoId?: SortOrder
    orphaId?: SortOrder
    otherId?: SortOrder
  }

  export type TraitAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TraitMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    description?: SortOrder
    URL?: SortOrder
    efoId?: SortOrder
    mondoId?: SortOrder
    hpoId?: SortOrder
    orphaId?: SortOrder
    otherId?: SortOrder
  }

  export type TraitMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    description?: SortOrder
    URL?: SortOrder
    efoId?: SortOrder
    mondoId?: SortOrder
    hpoId?: SortOrder
    orphaId?: SortOrder
    otherId?: SortOrder
  }

  export type TraitSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type TraitCategoryScalarRelationFilter = {
    is?: TraitCategoryWhereInput
    isNot?: TraitCategoryWhereInput
  }

  export type TraitScalarRelationFilter = {
    is?: TraitWhereInput
    isNot?: TraitWhereInput
  }

  export type TraitToTraitCategoryTraitIdTraitCategoryIdCompoundUniqueInput = {
    traitId: number
    traitCategoryId: number
  }

  export type TraitToTraitCategoryCountOrderByAggregateInput = {
    traitId?: SortOrder
    traitCategoryId?: SortOrder
  }

  export type TraitToTraitCategoryAvgOrderByAggregateInput = {
    traitId?: SortOrder
    traitCategoryId?: SortOrder
  }

  export type TraitToTraitCategoryMaxOrderByAggregateInput = {
    traitId?: SortOrder
    traitCategoryId?: SortOrder
  }

  export type TraitToTraitCategoryMinOrderByAggregateInput = {
    traitId?: SortOrder
    traitCategoryId?: SortOrder
  }

  export type TraitToTraitCategorySumOrderByAggregateInput = {
    traitId?: SortOrder
    traitCategoryId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BroadAncestryInModelListRelationFilter = {
    every?: BroadAncestryInModelWhereInput
    some?: BroadAncestryInModelWhereInput
    none?: BroadAncestryInModelWhereInput
  }

  export type DevelopmentPopulationSampleListRelationFilter = {
    every?: DevelopmentPopulationSampleWhereInput
    some?: DevelopmentPopulationSampleWhereInput
    none?: DevelopmentPopulationSampleWhereInput
  }

  export type ModelEvaluationListRelationFilter = {
    every?: ModelEvaluationWhereInput
    some?: ModelEvaluationWhereInput
    none?: ModelEvaluationWhereInput
  }

  export type PublicationScalarRelationFilter = {
    is?: PublicationWhereInput
    isNot?: PublicationWhereInput
  }

  export type PrioritizedModelListRelationFilter = {
    every?: PrioritizedModelWhereInput
    some?: PrioritizedModelWhereInput
    none?: PrioritizedModelWhereInput
  }

  export type ScoringFileNullableScalarRelationFilter = {
    is?: ScoringFileWhereInput | null
    isNot?: ScoringFileWhereInput | null
  }

  export type BroadAncestryInModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DevelopmentPopulationSampleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModelEvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrioritizedModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PRSModelOrderByRelevanceInput = {
    fields: PRSModelOrderByRelevanceFieldEnum | PRSModelOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PRSModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    numberOfSNP?: SortOrder
    pgscId?: SortOrder
    pgscURL?: SortOrder
    publicationId?: SortOrder
  }

  export type PRSModelAvgOrderByAggregateInput = {
    id?: SortOrder
    numberOfSNP?: SortOrder
    publicationId?: SortOrder
  }

  export type PRSModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    numberOfSNP?: SortOrder
    pgscId?: SortOrder
    pgscURL?: SortOrder
    publicationId?: SortOrder
  }

  export type PRSModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    numberOfSNP?: SortOrder
    pgscId?: SortOrder
    pgscURL?: SortOrder
    publicationId?: SortOrder
  }

  export type PRSModelSumOrderByAggregateInput = {
    id?: SortOrder
    numberOfSNP?: SortOrder
    publicationId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PRSModelScalarRelationFilter = {
    is?: PRSModelWhereInput
    isNot?: PRSModelWhereInput
  }

  export type PRSModelToTraitPrsModelIdTraitIdCompoundUniqueInput = {
    prsModelId: number
    traitId: number
  }

  export type PRSModelToTraitCountOrderByAggregateInput = {
    prsModelId?: SortOrder
    traitId?: SortOrder
  }

  export type PRSModelToTraitAvgOrderByAggregateInput = {
    prsModelId?: SortOrder
    traitId?: SortOrder
  }

  export type PRSModelToTraitMaxOrderByAggregateInput = {
    prsModelId?: SortOrder
    traitId?: SortOrder
  }

  export type PRSModelToTraitMinOrderByAggregateInput = {
    prsModelId?: SortOrder
    traitId?: SortOrder
  }

  export type PRSModelToTraitSumOrderByAggregateInput = {
    prsModelId?: SortOrder
    traitId?: SortOrder
  }

  export type EnumAssemblyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AssemblyType | EnumAssemblyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssemblyType[]
    notIn?: $Enums.AssemblyType[]
    not?: NestedEnumAssemblyTypeFilter<$PrismaModel> | $Enums.AssemblyType
  }

  export type ScoringFileOrderByRelevanceInput = {
    fields: ScoringFileOrderByRelevanceFieldEnum | ScoringFileOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ScoringFileCountOrderByAggregateInput = {
    id?: SortOrder
    assembly?: SortOrder
    path?: SortOrder
    prsModelId?: SortOrder
  }

  export type ScoringFileAvgOrderByAggregateInput = {
    id?: SortOrder
    prsModelId?: SortOrder
  }

  export type ScoringFileMaxOrderByAggregateInput = {
    id?: SortOrder
    assembly?: SortOrder
    path?: SortOrder
    prsModelId?: SortOrder
  }

  export type ScoringFileMinOrderByAggregateInput = {
    id?: SortOrder
    assembly?: SortOrder
    path?: SortOrder
    prsModelId?: SortOrder
  }

  export type ScoringFileSumOrderByAggregateInput = {
    id?: SortOrder
    prsModelId?: SortOrder
  }

  export type EnumAssemblyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssemblyType | EnumAssemblyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssemblyType[]
    notIn?: $Enums.AssemblyType[]
    not?: NestedEnumAssemblyTypeWithAggregatesFilter<$PrismaModel> | $Enums.AssemblyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssemblyTypeFilter<$PrismaModel>
    _max?: NestedEnumAssemblyTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PRSModelListRelationFilter = {
    every?: PRSModelWhereInput
    some?: PRSModelWhereInput
    none?: PRSModelWhereInput
  }

  export type PRSModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PublicationOrderByRelevanceInput = {
    fields: PublicationOrderByRelevanceFieldEnum | PublicationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PublicationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    journal?: SortOrder
    author?: SortOrder
    date?: SortOrder
    year?: SortOrder
    PMID?: SortOrder
    DOI?: SortOrder
    pgpId?: SortOrder
  }

  export type PublicationAvgOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
  }

  export type PublicationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    journal?: SortOrder
    author?: SortOrder
    date?: SortOrder
    year?: SortOrder
    PMID?: SortOrder
    DOI?: SortOrder
    pgpId?: SortOrder
  }

  export type PublicationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    journal?: SortOrder
    author?: SortOrder
    date?: SortOrder
    year?: SortOrder
    PMID?: SortOrder
    DOI?: SortOrder
    pgpId?: SortOrder
  }

  export type PublicationSumOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EvaluationPopulationSampleScalarRelationFilter = {
    is?: EvaluationPopulationSampleWhereInput
    isNot?: EvaluationPopulationSampleWhereInput
  }

  export type PerformanceMetricEvaluationListRelationFilter = {
    every?: PerformanceMetricEvaluationWhereInput
    some?: PerformanceMetricEvaluationWhereInput
    none?: PerformanceMetricEvaluationWhereInput
  }

  export type PerformanceMetricEvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModelEvaluationOrderByRelevanceInput = {
    fields: ModelEvaluationOrderByRelevanceFieldEnum | ModelEvaluationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ModelEvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    reportedTrait?: SortOrder
    covariates?: SortOrder
    ppmId?: SortOrder
    prsModelId?: SortOrder
    publicationId?: SortOrder
    evaluationPopulationSampleId?: SortOrder
  }

  export type ModelEvaluationAvgOrderByAggregateInput = {
    id?: SortOrder
    prsModelId?: SortOrder
    publicationId?: SortOrder
    evaluationPopulationSampleId?: SortOrder
  }

  export type ModelEvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    reportedTrait?: SortOrder
    covariates?: SortOrder
    ppmId?: SortOrder
    prsModelId?: SortOrder
    publicationId?: SortOrder
    evaluationPopulationSampleId?: SortOrder
  }

  export type ModelEvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    reportedTrait?: SortOrder
    covariates?: SortOrder
    ppmId?: SortOrder
    prsModelId?: SortOrder
    publicationId?: SortOrder
    evaluationPopulationSampleId?: SortOrder
  }

  export type ModelEvaluationSumOrderByAggregateInput = {
    id?: SortOrder
    prsModelId?: SortOrder
    publicationId?: SortOrder
    evaluationPopulationSampleId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ModelEvaluationScalarRelationFilter = {
    is?: ModelEvaluationWhereInput
    isNot?: ModelEvaluationWhereInput
  }

  export type PerformanceMetricScalarRelationFilter = {
    is?: PerformanceMetricWhereInput
    isNot?: PerformanceMetricWhereInput
  }

  export type PerformanceMetricEvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    estimate?: SortOrder
    CILower?: SortOrder
    CIUpper?: SortOrder
    modelEvaluationId?: SortOrder
    performanceMetricId?: SortOrder
  }

  export type PerformanceMetricEvaluationAvgOrderByAggregateInput = {
    id?: SortOrder
    estimate?: SortOrder
    CILower?: SortOrder
    CIUpper?: SortOrder
    modelEvaluationId?: SortOrder
    performanceMetricId?: SortOrder
  }

  export type PerformanceMetricEvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    estimate?: SortOrder
    CILower?: SortOrder
    CIUpper?: SortOrder
    modelEvaluationId?: SortOrder
    performanceMetricId?: SortOrder
  }

  export type PerformanceMetricEvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    estimate?: SortOrder
    CILower?: SortOrder
    CIUpper?: SortOrder
    modelEvaluationId?: SortOrder
    performanceMetricId?: SortOrder
  }

  export type PerformanceMetricEvaluationSumOrderByAggregateInput = {
    id?: SortOrder
    estimate?: SortOrder
    CILower?: SortOrder
    CIUpper?: SortOrder
    modelEvaluationId?: SortOrder
    performanceMetricId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumPerformanceMetricTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PerformanceMetricType | EnumPerformanceMetricTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PerformanceMetricType[]
    notIn?: $Enums.PerformanceMetricType[]
    not?: NestedEnumPerformanceMetricTypeFilter<$PrismaModel> | $Enums.PerformanceMetricType
  }

  export type PerformanceMetricOrderByRelevanceInput = {
    fields: PerformanceMetricOrderByRelevanceFieldEnum | PerformanceMetricOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PerformanceMetricCountOrderByAggregateInput = {
    id?: SortOrder
    nameShort?: SortOrder
    nameLong?: SortOrder
    type?: SortOrder
  }

  export type PerformanceMetricAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PerformanceMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    nameShort?: SortOrder
    nameLong?: SortOrder
    type?: SortOrder
  }

  export type PerformanceMetricMinOrderByAggregateInput = {
    id?: SortOrder
    nameShort?: SortOrder
    nameLong?: SortOrder
    type?: SortOrder
  }

  export type PerformanceMetricSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumPerformanceMetricTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PerformanceMetricType | EnumPerformanceMetricTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PerformanceMetricType[]
    notIn?: $Enums.PerformanceMetricType[]
    not?: NestedEnumPerformanceMetricTypeWithAggregatesFilter<$PrismaModel> | $Enums.PerformanceMetricType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPerformanceMetricTypeFilter<$PrismaModel>
    _max?: NestedEnumPerformanceMetricTypeFilter<$PrismaModel>
  }

  export type BroadAncestryCategoryScalarRelationFilter = {
    is?: BroadAncestryCategoryWhereInput
    isNot?: BroadAncestryCategoryWhereInput
  }

  export type EvaluationPopulationSampleOrderByRelevanceInput = {
    fields: EvaluationPopulationSampleOrderByRelevanceFieldEnum | EvaluationPopulationSampleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EvaluationPopulationSampleCountOrderByAggregateInput = {
    id?: SortOrder
    numberOfIndividuals?: SortOrder
    numberOfCases?: SortOrder
    numberOfControls?: SortOrder
    percentMale?: SortOrder
    age?: SortOrder
    ageUnits?: SortOrder
    ancestryBroad?: SortOrder
    ancestryDetails?: SortOrder
    cohort?: SortOrder
    gcId?: SortOrder
    sourcePMID?: SortOrder
    sourceDOI?: SortOrder
    phenotypeFree?: SortOrder
    pssId?: SortOrder
    broadAncestryId?: SortOrder
  }

  export type EvaluationPopulationSampleAvgOrderByAggregateInput = {
    id?: SortOrder
    numberOfIndividuals?: SortOrder
    numberOfCases?: SortOrder
    numberOfControls?: SortOrder
    percentMale?: SortOrder
    age?: SortOrder
    broadAncestryId?: SortOrder
  }

  export type EvaluationPopulationSampleMaxOrderByAggregateInput = {
    id?: SortOrder
    numberOfIndividuals?: SortOrder
    numberOfCases?: SortOrder
    numberOfControls?: SortOrder
    percentMale?: SortOrder
    age?: SortOrder
    ageUnits?: SortOrder
    ancestryBroad?: SortOrder
    ancestryDetails?: SortOrder
    cohort?: SortOrder
    gcId?: SortOrder
    sourcePMID?: SortOrder
    sourceDOI?: SortOrder
    phenotypeFree?: SortOrder
    pssId?: SortOrder
    broadAncestryId?: SortOrder
  }

  export type EvaluationPopulationSampleMinOrderByAggregateInput = {
    id?: SortOrder
    numberOfIndividuals?: SortOrder
    numberOfCases?: SortOrder
    numberOfControls?: SortOrder
    percentMale?: SortOrder
    age?: SortOrder
    ageUnits?: SortOrder
    ancestryBroad?: SortOrder
    ancestryDetails?: SortOrder
    cohort?: SortOrder
    gcId?: SortOrder
    sourcePMID?: SortOrder
    sourceDOI?: SortOrder
    phenotypeFree?: SortOrder
    pssId?: SortOrder
    broadAncestryId?: SortOrder
  }

  export type EvaluationPopulationSampleSumOrderByAggregateInput = {
    id?: SortOrder
    numberOfIndividuals?: SortOrder
    numberOfCases?: SortOrder
    numberOfControls?: SortOrder
    percentMale?: SortOrder
    age?: SortOrder
    broadAncestryId?: SortOrder
  }

  export type BroadAncestryInRefPopListRelationFilter = {
    every?: BroadAncestryInRefPopWhereInput
    some?: BroadAncestryInRefPopWhereInput
    none?: BroadAncestryInRefPopWhereInput
  }

  export type EvaluationPopulationSampleListRelationFilter = {
    every?: EvaluationPopulationSampleWhereInput
    some?: EvaluationPopulationSampleWhereInput
    none?: EvaluationPopulationSampleWhereInput
  }

  export type BroadAncestryInRefPopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvaluationPopulationSampleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BroadAncestryCategoryOrderByRelevanceInput = {
    fields: BroadAncestryCategoryOrderByRelevanceFieldEnum | BroadAncestryCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BroadAncestryCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    label?: SortOrder
  }

  export type BroadAncestryCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BroadAncestryCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    label?: SortOrder
  }

  export type BroadAncestryCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    label?: SortOrder
  }

  export type BroadAncestryCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BroadAncestryInModelBroadAncestryIdPrsModelIdCompoundUniqueInput = {
    broadAncestryId: number
    prsModelId: number
  }

  export type BroadAncestryInModelCountOrderByAggregateInput = {
    percentage?: SortOrder
    broadAncestryId?: SortOrder
    prsModelId?: SortOrder
  }

  export type BroadAncestryInModelAvgOrderByAggregateInput = {
    percentage?: SortOrder
    broadAncestryId?: SortOrder
    prsModelId?: SortOrder
  }

  export type BroadAncestryInModelMaxOrderByAggregateInput = {
    percentage?: SortOrder
    broadAncestryId?: SortOrder
    prsModelId?: SortOrder
  }

  export type BroadAncestryInModelMinOrderByAggregateInput = {
    percentage?: SortOrder
    broadAncestryId?: SortOrder
    prsModelId?: SortOrder
  }

  export type BroadAncestryInModelSumOrderByAggregateInput = {
    percentage?: SortOrder
    broadAncestryId?: SortOrder
    prsModelId?: SortOrder
  }

  export type EnumDevelopmentRoleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DevelopmentRoleType | EnumDevelopmentRoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DevelopmentRoleType[]
    notIn?: $Enums.DevelopmentRoleType[]
    not?: NestedEnumDevelopmentRoleTypeFilter<$PrismaModel> | $Enums.DevelopmentRoleType
  }

  export type DevelopmentPopulationSampleOrderByRelevanceInput = {
    fields: DevelopmentPopulationSampleOrderByRelevanceFieldEnum | DevelopmentPopulationSampleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DevelopmentPopulationSampleCountOrderByAggregateInput = {
    id?: SortOrder
    numberOfIndividuals?: SortOrder
    numberOfCases?: SortOrder
    numberOfControls?: SortOrder
    percentMale?: SortOrder
    age?: SortOrder
    ageUnits?: SortOrder
    ancestryBroad?: SortOrder
    ancestryDetails?: SortOrder
    cohort?: SortOrder
    gcId?: SortOrder
    sourcePMID?: SortOrder
    sourceDOI?: SortOrder
    role?: SortOrder
    prsModelId?: SortOrder
    broadAncestryId?: SortOrder
  }

  export type DevelopmentPopulationSampleAvgOrderByAggregateInput = {
    id?: SortOrder
    numberOfIndividuals?: SortOrder
    numberOfCases?: SortOrder
    numberOfControls?: SortOrder
    percentMale?: SortOrder
    age?: SortOrder
    prsModelId?: SortOrder
    broadAncestryId?: SortOrder
  }

  export type DevelopmentPopulationSampleMaxOrderByAggregateInput = {
    id?: SortOrder
    numberOfIndividuals?: SortOrder
    numberOfCases?: SortOrder
    numberOfControls?: SortOrder
    percentMale?: SortOrder
    age?: SortOrder
    ageUnits?: SortOrder
    ancestryBroad?: SortOrder
    ancestryDetails?: SortOrder
    cohort?: SortOrder
    gcId?: SortOrder
    sourcePMID?: SortOrder
    sourceDOI?: SortOrder
    role?: SortOrder
    prsModelId?: SortOrder
    broadAncestryId?: SortOrder
  }

  export type DevelopmentPopulationSampleMinOrderByAggregateInput = {
    id?: SortOrder
    numberOfIndividuals?: SortOrder
    numberOfCases?: SortOrder
    numberOfControls?: SortOrder
    percentMale?: SortOrder
    age?: SortOrder
    ageUnits?: SortOrder
    ancestryBroad?: SortOrder
    ancestryDetails?: SortOrder
    cohort?: SortOrder
    gcId?: SortOrder
    sourcePMID?: SortOrder
    sourceDOI?: SortOrder
    role?: SortOrder
    prsModelId?: SortOrder
    broadAncestryId?: SortOrder
  }

  export type DevelopmentPopulationSampleSumOrderByAggregateInput = {
    id?: SortOrder
    numberOfIndividuals?: SortOrder
    numberOfCases?: SortOrder
    numberOfControls?: SortOrder
    percentMale?: SortOrder
    age?: SortOrder
    prsModelId?: SortOrder
    broadAncestryId?: SortOrder
  }

  export type EnumDevelopmentRoleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DevelopmentRoleType | EnumDevelopmentRoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DevelopmentRoleType[]
    notIn?: $Enums.DevelopmentRoleType[]
    not?: NestedEnumDevelopmentRoleTypeWithAggregatesFilter<$PrismaModel> | $Enums.DevelopmentRoleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDevelopmentRoleTypeFilter<$PrismaModel>
    _max?: NestedEnumDevelopmentRoleTypeFilter<$PrismaModel>
  }

  export type ReferencePopulationScalarRelationFilter = {
    is?: ReferencePopulationWhereInput
    isNot?: ReferencePopulationWhereInput
  }

  export type BroadAncestryInRefPopBroadAncestryIdReferencePopulationIdCompoundUniqueInput = {
    broadAncestryId: number
    referencePopulationId: number
  }

  export type BroadAncestryInRefPopCountOrderByAggregateInput = {
    percentage?: SortOrder
    broadAncestryId?: SortOrder
    referencePopulationId?: SortOrder
  }

  export type BroadAncestryInRefPopAvgOrderByAggregateInput = {
    percentage?: SortOrder
    broadAncestryId?: SortOrder
    referencePopulationId?: SortOrder
  }

  export type BroadAncestryInRefPopMaxOrderByAggregateInput = {
    percentage?: SortOrder
    broadAncestryId?: SortOrder
    referencePopulationId?: SortOrder
  }

  export type BroadAncestryInRefPopMinOrderByAggregateInput = {
    percentage?: SortOrder
    broadAncestryId?: SortOrder
    referencePopulationId?: SortOrder
  }

  export type BroadAncestryInRefPopSumOrderByAggregateInput = {
    percentage?: SortOrder
    broadAncestryId?: SortOrder
    referencePopulationId?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PRSAnalysisListRelationFilter = {
    every?: PRSAnalysisWhereInput
    some?: PRSAnalysisWhereInput
    none?: PRSAnalysisWhereInput
  }

  export type PRSAnalysisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferencePopulationOrderByRelevanceInput = {
    fields: ReferencePopulationOrderByRelevanceFieldEnum | ReferencePopulationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReferencePopulationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    studyURL?: SortOrder
    assembly?: SortOrder
    numberOfindividuals?: SortOrder
    numberOfvariants?: SortOrder
    studyName?: SortOrder
    date?: SortOrder
    path?: SortOrder
  }

  export type ReferencePopulationAvgOrderByAggregateInput = {
    id?: SortOrder
    numberOfindividuals?: SortOrder
    numberOfvariants?: SortOrder
  }

  export type ReferencePopulationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    studyURL?: SortOrder
    assembly?: SortOrder
    numberOfindividuals?: SortOrder
    numberOfvariants?: SortOrder
    studyName?: SortOrder
    date?: SortOrder
    path?: SortOrder
  }

  export type ReferencePopulationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    studyURL?: SortOrder
    assembly?: SortOrder
    numberOfindividuals?: SortOrder
    numberOfvariants?: SortOrder
    studyName?: SortOrder
    date?: SortOrder
    path?: SortOrder
  }

  export type ReferencePopulationSumOrderByAggregateInput = {
    id?: SortOrder
    numberOfindividuals?: SortOrder
    numberOfvariants?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumAncestryAdjustmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AncestryAdjustmentType | EnumAncestryAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AncestryAdjustmentType[]
    notIn?: $Enums.AncestryAdjustmentType[]
    not?: NestedEnumAncestryAdjustmentTypeFilter<$PrismaModel> | $Enums.AncestryAdjustmentType
  }

  export type PatientScalarRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type PRSAnalysisOrderByRelevanceInput = {
    fields: PRSAnalysisOrderByRelevanceFieldEnum | PRSAnalysisOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PRSAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    HTMLResultPath?: SortOrder
    ancestryThreshold?: SortOrder
    overlapThreshold?: SortOrder
    ancestryAdjustment?: SortOrder
    assembly?: SortOrder
    patientId?: SortOrder
    referencePopulationId?: SortOrder
  }

  export type PRSAnalysisAvgOrderByAggregateInput = {
    id?: SortOrder
    ancestryThreshold?: SortOrder
    overlapThreshold?: SortOrder
    patientId?: SortOrder
    referencePopulationId?: SortOrder
  }

  export type PRSAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    HTMLResultPath?: SortOrder
    ancestryThreshold?: SortOrder
    overlapThreshold?: SortOrder
    ancestryAdjustment?: SortOrder
    assembly?: SortOrder
    patientId?: SortOrder
    referencePopulationId?: SortOrder
  }

  export type PRSAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    HTMLResultPath?: SortOrder
    ancestryThreshold?: SortOrder
    overlapThreshold?: SortOrder
    ancestryAdjustment?: SortOrder
    assembly?: SortOrder
    patientId?: SortOrder
    referencePopulationId?: SortOrder
  }

  export type PRSAnalysisSumOrderByAggregateInput = {
    id?: SortOrder
    ancestryThreshold?: SortOrder
    overlapThreshold?: SortOrder
    patientId?: SortOrder
    referencePopulationId?: SortOrder
  }

  export type EnumAncestryAdjustmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AncestryAdjustmentType | EnumAncestryAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AncestryAdjustmentType[]
    notIn?: $Enums.AncestryAdjustmentType[]
    not?: NestedEnumAncestryAdjustmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AncestryAdjustmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAncestryAdjustmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAncestryAdjustmentTypeFilter<$PrismaModel>
  }

  export type PRSResultNullableScalarRelationFilter = {
    is?: PRSResultWhereInput | null
    isNot?: PRSResultWhereInput | null
  }

  export type PRSAnalysisScalarRelationFilter = {
    is?: PRSAnalysisWhereInput
    isNot?: PRSAnalysisWhereInput
  }

  export type PrioritizedModelPrsModelIdPrsAnalysisIdCompoundUniqueInput = {
    prsModelId: number
    prsAnalysisId: number
  }

  export type PrioritizedModelCountOrderByAggregateInput = {
    position?: SortOrder
    prsModelId?: SortOrder
    prsAnalysisId?: SortOrder
    prsResultId?: SortOrder
  }

  export type PrioritizedModelAvgOrderByAggregateInput = {
    position?: SortOrder
    prsModelId?: SortOrder
    prsAnalysisId?: SortOrder
    prsResultId?: SortOrder
  }

  export type PrioritizedModelMaxOrderByAggregateInput = {
    position?: SortOrder
    prsModelId?: SortOrder
    prsAnalysisId?: SortOrder
    prsResultId?: SortOrder
  }

  export type PrioritizedModelMinOrderByAggregateInput = {
    position?: SortOrder
    prsModelId?: SortOrder
    prsAnalysisId?: SortOrder
    prsResultId?: SortOrder
  }

  export type PrioritizedModelSumOrderByAggregateInput = {
    position?: SortOrder
    prsModelId?: SortOrder
    prsAnalysisId?: SortOrder
    prsResultId?: SortOrder
  }

  export type PrioritizedModelScalarRelationFilter = {
    is?: PrioritizedModelWhereInput
    isNot?: PrioritizedModelWhereInput
  }

  export type PRSResultOrderByRelevanceInput = {
    fields: PRSResultOrderByRelevanceFieldEnum | PRSResultOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PRSResultPrsModelIdPrsAnalysisIdCompoundUniqueInput = {
    prsModelId: number
    prsAnalysisId: number
  }

  export type PRSResultCountOrderByAggregateInput = {
    id?: SortOrder
    prs?: SortOrder
    percentile?: SortOrder
    overlapPercent?: SortOrder
    prsModelId?: SortOrder
    prsAnalysisId?: SortOrder
  }

  export type PRSResultAvgOrderByAggregateInput = {
    id?: SortOrder
    prs?: SortOrder
    overlapPercent?: SortOrder
    prsModelId?: SortOrder
    prsAnalysisId?: SortOrder
  }

  export type PRSResultMaxOrderByAggregateInput = {
    id?: SortOrder
    prs?: SortOrder
    percentile?: SortOrder
    overlapPercent?: SortOrder
    prsModelId?: SortOrder
    prsAnalysisId?: SortOrder
  }

  export type PRSResultMinOrderByAggregateInput = {
    id?: SortOrder
    prs?: SortOrder
    percentile?: SortOrder
    overlapPercent?: SortOrder
    prsModelId?: SortOrder
    prsAnalysisId?: SortOrder
  }

  export type PRSResultSumOrderByAggregateInput = {
    id?: SortOrder
    prs?: SortOrder
    overlapPercent?: SortOrder
    prsModelId?: SortOrder
    prsAnalysisId?: SortOrder
  }

  export type PatientOrderByRelevanceInput = {
    fields: PatientOrderByRelevanceFieldEnum | PatientOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    genotypingMethod?: SortOrder
    DataFilePath?: SortOrder
    DataFilteFormat?: SortOrder
  }

  export type PatientAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    genotypingMethod?: SortOrder
    DataFilePath?: SortOrder
    DataFilteFormat?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    genotypingMethod?: SortOrder
    DataFilePath?: SortOrder
    DataFilteFormat?: SortOrder
  }

  export type PatientSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TraitToTraitCategoryCreateNestedManyWithoutTraitCategoryInput = {
    create?: XOR<TraitToTraitCategoryCreateWithoutTraitCategoryInput, TraitToTraitCategoryUncheckedCreateWithoutTraitCategoryInput> | TraitToTraitCategoryCreateWithoutTraitCategoryInput[] | TraitToTraitCategoryUncheckedCreateWithoutTraitCategoryInput[]
    connectOrCreate?: TraitToTraitCategoryCreateOrConnectWithoutTraitCategoryInput | TraitToTraitCategoryCreateOrConnectWithoutTraitCategoryInput[]
    createMany?: TraitToTraitCategoryCreateManyTraitCategoryInputEnvelope
    connect?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
  }

  export type TraitToTraitCategoryUncheckedCreateNestedManyWithoutTraitCategoryInput = {
    create?: XOR<TraitToTraitCategoryCreateWithoutTraitCategoryInput, TraitToTraitCategoryUncheckedCreateWithoutTraitCategoryInput> | TraitToTraitCategoryCreateWithoutTraitCategoryInput[] | TraitToTraitCategoryUncheckedCreateWithoutTraitCategoryInput[]
    connectOrCreate?: TraitToTraitCategoryCreateOrConnectWithoutTraitCategoryInput | TraitToTraitCategoryCreateOrConnectWithoutTraitCategoryInput[]
    createMany?: TraitToTraitCategoryCreateManyTraitCategoryInputEnvelope
    connect?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type TraitToTraitCategoryUpdateManyWithoutTraitCategoryNestedInput = {
    create?: XOR<TraitToTraitCategoryCreateWithoutTraitCategoryInput, TraitToTraitCategoryUncheckedCreateWithoutTraitCategoryInput> | TraitToTraitCategoryCreateWithoutTraitCategoryInput[] | TraitToTraitCategoryUncheckedCreateWithoutTraitCategoryInput[]
    connectOrCreate?: TraitToTraitCategoryCreateOrConnectWithoutTraitCategoryInput | TraitToTraitCategoryCreateOrConnectWithoutTraitCategoryInput[]
    upsert?: TraitToTraitCategoryUpsertWithWhereUniqueWithoutTraitCategoryInput | TraitToTraitCategoryUpsertWithWhereUniqueWithoutTraitCategoryInput[]
    createMany?: TraitToTraitCategoryCreateManyTraitCategoryInputEnvelope
    set?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
    disconnect?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
    delete?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
    connect?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
    update?: TraitToTraitCategoryUpdateWithWhereUniqueWithoutTraitCategoryInput | TraitToTraitCategoryUpdateWithWhereUniqueWithoutTraitCategoryInput[]
    updateMany?: TraitToTraitCategoryUpdateManyWithWhereWithoutTraitCategoryInput | TraitToTraitCategoryUpdateManyWithWhereWithoutTraitCategoryInput[]
    deleteMany?: TraitToTraitCategoryScalarWhereInput | TraitToTraitCategoryScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TraitToTraitCategoryUncheckedUpdateManyWithoutTraitCategoryNestedInput = {
    create?: XOR<TraitToTraitCategoryCreateWithoutTraitCategoryInput, TraitToTraitCategoryUncheckedCreateWithoutTraitCategoryInput> | TraitToTraitCategoryCreateWithoutTraitCategoryInput[] | TraitToTraitCategoryUncheckedCreateWithoutTraitCategoryInput[]
    connectOrCreate?: TraitToTraitCategoryCreateOrConnectWithoutTraitCategoryInput | TraitToTraitCategoryCreateOrConnectWithoutTraitCategoryInput[]
    upsert?: TraitToTraitCategoryUpsertWithWhereUniqueWithoutTraitCategoryInput | TraitToTraitCategoryUpsertWithWhereUniqueWithoutTraitCategoryInput[]
    createMany?: TraitToTraitCategoryCreateManyTraitCategoryInputEnvelope
    set?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
    disconnect?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
    delete?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
    connect?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
    update?: TraitToTraitCategoryUpdateWithWhereUniqueWithoutTraitCategoryInput | TraitToTraitCategoryUpdateWithWhereUniqueWithoutTraitCategoryInput[]
    updateMany?: TraitToTraitCategoryUpdateManyWithWhereWithoutTraitCategoryInput | TraitToTraitCategoryUpdateManyWithWhereWithoutTraitCategoryInput[]
    deleteMany?: TraitToTraitCategoryScalarWhereInput | TraitToTraitCategoryScalarWhereInput[]
  }

  export type PRSModelToTraitCreateNestedManyWithoutTraitInput = {
    create?: XOR<PRSModelToTraitCreateWithoutTraitInput, PRSModelToTraitUncheckedCreateWithoutTraitInput> | PRSModelToTraitCreateWithoutTraitInput[] | PRSModelToTraitUncheckedCreateWithoutTraitInput[]
    connectOrCreate?: PRSModelToTraitCreateOrConnectWithoutTraitInput | PRSModelToTraitCreateOrConnectWithoutTraitInput[]
    createMany?: PRSModelToTraitCreateManyTraitInputEnvelope
    connect?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
  }

  export type TraitToTraitCategoryCreateNestedManyWithoutTraitInput = {
    create?: XOR<TraitToTraitCategoryCreateWithoutTraitInput, TraitToTraitCategoryUncheckedCreateWithoutTraitInput> | TraitToTraitCategoryCreateWithoutTraitInput[] | TraitToTraitCategoryUncheckedCreateWithoutTraitInput[]
    connectOrCreate?: TraitToTraitCategoryCreateOrConnectWithoutTraitInput | TraitToTraitCategoryCreateOrConnectWithoutTraitInput[]
    createMany?: TraitToTraitCategoryCreateManyTraitInputEnvelope
    connect?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
  }

  export type PRSModelToTraitUncheckedCreateNestedManyWithoutTraitInput = {
    create?: XOR<PRSModelToTraitCreateWithoutTraitInput, PRSModelToTraitUncheckedCreateWithoutTraitInput> | PRSModelToTraitCreateWithoutTraitInput[] | PRSModelToTraitUncheckedCreateWithoutTraitInput[]
    connectOrCreate?: PRSModelToTraitCreateOrConnectWithoutTraitInput | PRSModelToTraitCreateOrConnectWithoutTraitInput[]
    createMany?: PRSModelToTraitCreateManyTraitInputEnvelope
    connect?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
  }

  export type TraitToTraitCategoryUncheckedCreateNestedManyWithoutTraitInput = {
    create?: XOR<TraitToTraitCategoryCreateWithoutTraitInput, TraitToTraitCategoryUncheckedCreateWithoutTraitInput> | TraitToTraitCategoryCreateWithoutTraitInput[] | TraitToTraitCategoryUncheckedCreateWithoutTraitInput[]
    connectOrCreate?: TraitToTraitCategoryCreateOrConnectWithoutTraitInput | TraitToTraitCategoryCreateOrConnectWithoutTraitInput[]
    createMany?: TraitToTraitCategoryCreateManyTraitInputEnvelope
    connect?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type PRSModelToTraitUpdateManyWithoutTraitNestedInput = {
    create?: XOR<PRSModelToTraitCreateWithoutTraitInput, PRSModelToTraitUncheckedCreateWithoutTraitInput> | PRSModelToTraitCreateWithoutTraitInput[] | PRSModelToTraitUncheckedCreateWithoutTraitInput[]
    connectOrCreate?: PRSModelToTraitCreateOrConnectWithoutTraitInput | PRSModelToTraitCreateOrConnectWithoutTraitInput[]
    upsert?: PRSModelToTraitUpsertWithWhereUniqueWithoutTraitInput | PRSModelToTraitUpsertWithWhereUniqueWithoutTraitInput[]
    createMany?: PRSModelToTraitCreateManyTraitInputEnvelope
    set?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
    disconnect?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
    delete?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
    connect?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
    update?: PRSModelToTraitUpdateWithWhereUniqueWithoutTraitInput | PRSModelToTraitUpdateWithWhereUniqueWithoutTraitInput[]
    updateMany?: PRSModelToTraitUpdateManyWithWhereWithoutTraitInput | PRSModelToTraitUpdateManyWithWhereWithoutTraitInput[]
    deleteMany?: PRSModelToTraitScalarWhereInput | PRSModelToTraitScalarWhereInput[]
  }

  export type TraitToTraitCategoryUpdateManyWithoutTraitNestedInput = {
    create?: XOR<TraitToTraitCategoryCreateWithoutTraitInput, TraitToTraitCategoryUncheckedCreateWithoutTraitInput> | TraitToTraitCategoryCreateWithoutTraitInput[] | TraitToTraitCategoryUncheckedCreateWithoutTraitInput[]
    connectOrCreate?: TraitToTraitCategoryCreateOrConnectWithoutTraitInput | TraitToTraitCategoryCreateOrConnectWithoutTraitInput[]
    upsert?: TraitToTraitCategoryUpsertWithWhereUniqueWithoutTraitInput | TraitToTraitCategoryUpsertWithWhereUniqueWithoutTraitInput[]
    createMany?: TraitToTraitCategoryCreateManyTraitInputEnvelope
    set?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
    disconnect?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
    delete?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
    connect?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
    update?: TraitToTraitCategoryUpdateWithWhereUniqueWithoutTraitInput | TraitToTraitCategoryUpdateWithWhereUniqueWithoutTraitInput[]
    updateMany?: TraitToTraitCategoryUpdateManyWithWhereWithoutTraitInput | TraitToTraitCategoryUpdateManyWithWhereWithoutTraitInput[]
    deleteMany?: TraitToTraitCategoryScalarWhereInput | TraitToTraitCategoryScalarWhereInput[]
  }

  export type PRSModelToTraitUncheckedUpdateManyWithoutTraitNestedInput = {
    create?: XOR<PRSModelToTraitCreateWithoutTraitInput, PRSModelToTraitUncheckedCreateWithoutTraitInput> | PRSModelToTraitCreateWithoutTraitInput[] | PRSModelToTraitUncheckedCreateWithoutTraitInput[]
    connectOrCreate?: PRSModelToTraitCreateOrConnectWithoutTraitInput | PRSModelToTraitCreateOrConnectWithoutTraitInput[]
    upsert?: PRSModelToTraitUpsertWithWhereUniqueWithoutTraitInput | PRSModelToTraitUpsertWithWhereUniqueWithoutTraitInput[]
    createMany?: PRSModelToTraitCreateManyTraitInputEnvelope
    set?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
    disconnect?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
    delete?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
    connect?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
    update?: PRSModelToTraitUpdateWithWhereUniqueWithoutTraitInput | PRSModelToTraitUpdateWithWhereUniqueWithoutTraitInput[]
    updateMany?: PRSModelToTraitUpdateManyWithWhereWithoutTraitInput | PRSModelToTraitUpdateManyWithWhereWithoutTraitInput[]
    deleteMany?: PRSModelToTraitScalarWhereInput | PRSModelToTraitScalarWhereInput[]
  }

  export type TraitToTraitCategoryUncheckedUpdateManyWithoutTraitNestedInput = {
    create?: XOR<TraitToTraitCategoryCreateWithoutTraitInput, TraitToTraitCategoryUncheckedCreateWithoutTraitInput> | TraitToTraitCategoryCreateWithoutTraitInput[] | TraitToTraitCategoryUncheckedCreateWithoutTraitInput[]
    connectOrCreate?: TraitToTraitCategoryCreateOrConnectWithoutTraitInput | TraitToTraitCategoryCreateOrConnectWithoutTraitInput[]
    upsert?: TraitToTraitCategoryUpsertWithWhereUniqueWithoutTraitInput | TraitToTraitCategoryUpsertWithWhereUniqueWithoutTraitInput[]
    createMany?: TraitToTraitCategoryCreateManyTraitInputEnvelope
    set?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
    disconnect?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
    delete?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
    connect?: TraitToTraitCategoryWhereUniqueInput | TraitToTraitCategoryWhereUniqueInput[]
    update?: TraitToTraitCategoryUpdateWithWhereUniqueWithoutTraitInput | TraitToTraitCategoryUpdateWithWhereUniqueWithoutTraitInput[]
    updateMany?: TraitToTraitCategoryUpdateManyWithWhereWithoutTraitInput | TraitToTraitCategoryUpdateManyWithWhereWithoutTraitInput[]
    deleteMany?: TraitToTraitCategoryScalarWhereInput | TraitToTraitCategoryScalarWhereInput[]
  }

  export type TraitCategoryCreateNestedOneWithoutTraitsInput = {
    create?: XOR<TraitCategoryCreateWithoutTraitsInput, TraitCategoryUncheckedCreateWithoutTraitsInput>
    connectOrCreate?: TraitCategoryCreateOrConnectWithoutTraitsInput
    connect?: TraitCategoryWhereUniqueInput
  }

  export type TraitCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<TraitCreateWithoutCategoriesInput, TraitUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: TraitCreateOrConnectWithoutCategoriesInput
    connect?: TraitWhereUniqueInput
  }

  export type TraitCategoryUpdateOneRequiredWithoutTraitsNestedInput = {
    create?: XOR<TraitCategoryCreateWithoutTraitsInput, TraitCategoryUncheckedCreateWithoutTraitsInput>
    connectOrCreate?: TraitCategoryCreateOrConnectWithoutTraitsInput
    upsert?: TraitCategoryUpsertWithoutTraitsInput
    connect?: TraitCategoryWhereUniqueInput
    update?: XOR<XOR<TraitCategoryUpdateToOneWithWhereWithoutTraitsInput, TraitCategoryUpdateWithoutTraitsInput>, TraitCategoryUncheckedUpdateWithoutTraitsInput>
  }

  export type TraitUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<TraitCreateWithoutCategoriesInput, TraitUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: TraitCreateOrConnectWithoutCategoriesInput
    upsert?: TraitUpsertWithoutCategoriesInput
    connect?: TraitWhereUniqueInput
    update?: XOR<XOR<TraitUpdateToOneWithWhereWithoutCategoriesInput, TraitUpdateWithoutCategoriesInput>, TraitUncheckedUpdateWithoutCategoriesInput>
  }

  export type BroadAncestryInModelCreateNestedManyWithoutPrsModelInput = {
    create?: XOR<BroadAncestryInModelCreateWithoutPrsModelInput, BroadAncestryInModelUncheckedCreateWithoutPrsModelInput> | BroadAncestryInModelCreateWithoutPrsModelInput[] | BroadAncestryInModelUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: BroadAncestryInModelCreateOrConnectWithoutPrsModelInput | BroadAncestryInModelCreateOrConnectWithoutPrsModelInput[]
    createMany?: BroadAncestryInModelCreateManyPrsModelInputEnvelope
    connect?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
  }

  export type DevelopmentPopulationSampleCreateNestedManyWithoutPrsModelInput = {
    create?: XOR<DevelopmentPopulationSampleCreateWithoutPrsModelInput, DevelopmentPopulationSampleUncheckedCreateWithoutPrsModelInput> | DevelopmentPopulationSampleCreateWithoutPrsModelInput[] | DevelopmentPopulationSampleUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: DevelopmentPopulationSampleCreateOrConnectWithoutPrsModelInput | DevelopmentPopulationSampleCreateOrConnectWithoutPrsModelInput[]
    createMany?: DevelopmentPopulationSampleCreateManyPrsModelInputEnvelope
    connect?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
  }

  export type ModelEvaluationCreateNestedManyWithoutPrsModelInput = {
    create?: XOR<ModelEvaluationCreateWithoutPrsModelInput, ModelEvaluationUncheckedCreateWithoutPrsModelInput> | ModelEvaluationCreateWithoutPrsModelInput[] | ModelEvaluationUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: ModelEvaluationCreateOrConnectWithoutPrsModelInput | ModelEvaluationCreateOrConnectWithoutPrsModelInput[]
    createMany?: ModelEvaluationCreateManyPrsModelInputEnvelope
    connect?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
  }

  export type PublicationCreateNestedOneWithoutPrsModelsInput = {
    create?: XOR<PublicationCreateWithoutPrsModelsInput, PublicationUncheckedCreateWithoutPrsModelsInput>
    connectOrCreate?: PublicationCreateOrConnectWithoutPrsModelsInput
    connect?: PublicationWhereUniqueInput
  }

  export type PRSModelToTraitCreateNestedManyWithoutPrsModelInput = {
    create?: XOR<PRSModelToTraitCreateWithoutPrsModelInput, PRSModelToTraitUncheckedCreateWithoutPrsModelInput> | PRSModelToTraitCreateWithoutPrsModelInput[] | PRSModelToTraitUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: PRSModelToTraitCreateOrConnectWithoutPrsModelInput | PRSModelToTraitCreateOrConnectWithoutPrsModelInput[]
    createMany?: PRSModelToTraitCreateManyPrsModelInputEnvelope
    connect?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
  }

  export type PrioritizedModelCreateNestedManyWithoutPrsModelInput = {
    create?: XOR<PrioritizedModelCreateWithoutPrsModelInput, PrioritizedModelUncheckedCreateWithoutPrsModelInput> | PrioritizedModelCreateWithoutPrsModelInput[] | PrioritizedModelUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: PrioritizedModelCreateOrConnectWithoutPrsModelInput | PrioritizedModelCreateOrConnectWithoutPrsModelInput[]
    createMany?: PrioritizedModelCreateManyPrsModelInputEnvelope
    connect?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
  }

  export type ScoringFileCreateNestedOneWithoutPrsModelInput = {
    create?: XOR<ScoringFileCreateWithoutPrsModelInput, ScoringFileUncheckedCreateWithoutPrsModelInput>
    connectOrCreate?: ScoringFileCreateOrConnectWithoutPrsModelInput
    connect?: ScoringFileWhereUniqueInput
  }

  export type BroadAncestryInModelUncheckedCreateNestedManyWithoutPrsModelInput = {
    create?: XOR<BroadAncestryInModelCreateWithoutPrsModelInput, BroadAncestryInModelUncheckedCreateWithoutPrsModelInput> | BroadAncestryInModelCreateWithoutPrsModelInput[] | BroadAncestryInModelUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: BroadAncestryInModelCreateOrConnectWithoutPrsModelInput | BroadAncestryInModelCreateOrConnectWithoutPrsModelInput[]
    createMany?: BroadAncestryInModelCreateManyPrsModelInputEnvelope
    connect?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
  }

  export type DevelopmentPopulationSampleUncheckedCreateNestedManyWithoutPrsModelInput = {
    create?: XOR<DevelopmentPopulationSampleCreateWithoutPrsModelInput, DevelopmentPopulationSampleUncheckedCreateWithoutPrsModelInput> | DevelopmentPopulationSampleCreateWithoutPrsModelInput[] | DevelopmentPopulationSampleUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: DevelopmentPopulationSampleCreateOrConnectWithoutPrsModelInput | DevelopmentPopulationSampleCreateOrConnectWithoutPrsModelInput[]
    createMany?: DevelopmentPopulationSampleCreateManyPrsModelInputEnvelope
    connect?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
  }

  export type ModelEvaluationUncheckedCreateNestedManyWithoutPrsModelInput = {
    create?: XOR<ModelEvaluationCreateWithoutPrsModelInput, ModelEvaluationUncheckedCreateWithoutPrsModelInput> | ModelEvaluationCreateWithoutPrsModelInput[] | ModelEvaluationUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: ModelEvaluationCreateOrConnectWithoutPrsModelInput | ModelEvaluationCreateOrConnectWithoutPrsModelInput[]
    createMany?: ModelEvaluationCreateManyPrsModelInputEnvelope
    connect?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
  }

  export type PRSModelToTraitUncheckedCreateNestedManyWithoutPrsModelInput = {
    create?: XOR<PRSModelToTraitCreateWithoutPrsModelInput, PRSModelToTraitUncheckedCreateWithoutPrsModelInput> | PRSModelToTraitCreateWithoutPrsModelInput[] | PRSModelToTraitUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: PRSModelToTraitCreateOrConnectWithoutPrsModelInput | PRSModelToTraitCreateOrConnectWithoutPrsModelInput[]
    createMany?: PRSModelToTraitCreateManyPrsModelInputEnvelope
    connect?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
  }

  export type PrioritizedModelUncheckedCreateNestedManyWithoutPrsModelInput = {
    create?: XOR<PrioritizedModelCreateWithoutPrsModelInput, PrioritizedModelUncheckedCreateWithoutPrsModelInput> | PrioritizedModelCreateWithoutPrsModelInput[] | PrioritizedModelUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: PrioritizedModelCreateOrConnectWithoutPrsModelInput | PrioritizedModelCreateOrConnectWithoutPrsModelInput[]
    createMany?: PrioritizedModelCreateManyPrsModelInputEnvelope
    connect?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
  }

  export type ScoringFileUncheckedCreateNestedOneWithoutPrsModelInput = {
    create?: XOR<ScoringFileCreateWithoutPrsModelInput, ScoringFileUncheckedCreateWithoutPrsModelInput>
    connectOrCreate?: ScoringFileCreateOrConnectWithoutPrsModelInput
    connect?: ScoringFileWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BroadAncestryInModelUpdateManyWithoutPrsModelNestedInput = {
    create?: XOR<BroadAncestryInModelCreateWithoutPrsModelInput, BroadAncestryInModelUncheckedCreateWithoutPrsModelInput> | BroadAncestryInModelCreateWithoutPrsModelInput[] | BroadAncestryInModelUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: BroadAncestryInModelCreateOrConnectWithoutPrsModelInput | BroadAncestryInModelCreateOrConnectWithoutPrsModelInput[]
    upsert?: BroadAncestryInModelUpsertWithWhereUniqueWithoutPrsModelInput | BroadAncestryInModelUpsertWithWhereUniqueWithoutPrsModelInput[]
    createMany?: BroadAncestryInModelCreateManyPrsModelInputEnvelope
    set?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
    disconnect?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
    delete?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
    connect?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
    update?: BroadAncestryInModelUpdateWithWhereUniqueWithoutPrsModelInput | BroadAncestryInModelUpdateWithWhereUniqueWithoutPrsModelInput[]
    updateMany?: BroadAncestryInModelUpdateManyWithWhereWithoutPrsModelInput | BroadAncestryInModelUpdateManyWithWhereWithoutPrsModelInput[]
    deleteMany?: BroadAncestryInModelScalarWhereInput | BroadAncestryInModelScalarWhereInput[]
  }

  export type DevelopmentPopulationSampleUpdateManyWithoutPrsModelNestedInput = {
    create?: XOR<DevelopmentPopulationSampleCreateWithoutPrsModelInput, DevelopmentPopulationSampleUncheckedCreateWithoutPrsModelInput> | DevelopmentPopulationSampleCreateWithoutPrsModelInput[] | DevelopmentPopulationSampleUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: DevelopmentPopulationSampleCreateOrConnectWithoutPrsModelInput | DevelopmentPopulationSampleCreateOrConnectWithoutPrsModelInput[]
    upsert?: DevelopmentPopulationSampleUpsertWithWhereUniqueWithoutPrsModelInput | DevelopmentPopulationSampleUpsertWithWhereUniqueWithoutPrsModelInput[]
    createMany?: DevelopmentPopulationSampleCreateManyPrsModelInputEnvelope
    set?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
    disconnect?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
    delete?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
    connect?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
    update?: DevelopmentPopulationSampleUpdateWithWhereUniqueWithoutPrsModelInput | DevelopmentPopulationSampleUpdateWithWhereUniqueWithoutPrsModelInput[]
    updateMany?: DevelopmentPopulationSampleUpdateManyWithWhereWithoutPrsModelInput | DevelopmentPopulationSampleUpdateManyWithWhereWithoutPrsModelInput[]
    deleteMany?: DevelopmentPopulationSampleScalarWhereInput | DevelopmentPopulationSampleScalarWhereInput[]
  }

  export type ModelEvaluationUpdateManyWithoutPrsModelNestedInput = {
    create?: XOR<ModelEvaluationCreateWithoutPrsModelInput, ModelEvaluationUncheckedCreateWithoutPrsModelInput> | ModelEvaluationCreateWithoutPrsModelInput[] | ModelEvaluationUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: ModelEvaluationCreateOrConnectWithoutPrsModelInput | ModelEvaluationCreateOrConnectWithoutPrsModelInput[]
    upsert?: ModelEvaluationUpsertWithWhereUniqueWithoutPrsModelInput | ModelEvaluationUpsertWithWhereUniqueWithoutPrsModelInput[]
    createMany?: ModelEvaluationCreateManyPrsModelInputEnvelope
    set?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    disconnect?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    delete?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    connect?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    update?: ModelEvaluationUpdateWithWhereUniqueWithoutPrsModelInput | ModelEvaluationUpdateWithWhereUniqueWithoutPrsModelInput[]
    updateMany?: ModelEvaluationUpdateManyWithWhereWithoutPrsModelInput | ModelEvaluationUpdateManyWithWhereWithoutPrsModelInput[]
    deleteMany?: ModelEvaluationScalarWhereInput | ModelEvaluationScalarWhereInput[]
  }

  export type PublicationUpdateOneRequiredWithoutPrsModelsNestedInput = {
    create?: XOR<PublicationCreateWithoutPrsModelsInput, PublicationUncheckedCreateWithoutPrsModelsInput>
    connectOrCreate?: PublicationCreateOrConnectWithoutPrsModelsInput
    upsert?: PublicationUpsertWithoutPrsModelsInput
    connect?: PublicationWhereUniqueInput
    update?: XOR<XOR<PublicationUpdateToOneWithWhereWithoutPrsModelsInput, PublicationUpdateWithoutPrsModelsInput>, PublicationUncheckedUpdateWithoutPrsModelsInput>
  }

  export type PRSModelToTraitUpdateManyWithoutPrsModelNestedInput = {
    create?: XOR<PRSModelToTraitCreateWithoutPrsModelInput, PRSModelToTraitUncheckedCreateWithoutPrsModelInput> | PRSModelToTraitCreateWithoutPrsModelInput[] | PRSModelToTraitUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: PRSModelToTraitCreateOrConnectWithoutPrsModelInput | PRSModelToTraitCreateOrConnectWithoutPrsModelInput[]
    upsert?: PRSModelToTraitUpsertWithWhereUniqueWithoutPrsModelInput | PRSModelToTraitUpsertWithWhereUniqueWithoutPrsModelInput[]
    createMany?: PRSModelToTraitCreateManyPrsModelInputEnvelope
    set?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
    disconnect?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
    delete?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
    connect?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
    update?: PRSModelToTraitUpdateWithWhereUniqueWithoutPrsModelInput | PRSModelToTraitUpdateWithWhereUniqueWithoutPrsModelInput[]
    updateMany?: PRSModelToTraitUpdateManyWithWhereWithoutPrsModelInput | PRSModelToTraitUpdateManyWithWhereWithoutPrsModelInput[]
    deleteMany?: PRSModelToTraitScalarWhereInput | PRSModelToTraitScalarWhereInput[]
  }

  export type PrioritizedModelUpdateManyWithoutPrsModelNestedInput = {
    create?: XOR<PrioritizedModelCreateWithoutPrsModelInput, PrioritizedModelUncheckedCreateWithoutPrsModelInput> | PrioritizedModelCreateWithoutPrsModelInput[] | PrioritizedModelUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: PrioritizedModelCreateOrConnectWithoutPrsModelInput | PrioritizedModelCreateOrConnectWithoutPrsModelInput[]
    upsert?: PrioritizedModelUpsertWithWhereUniqueWithoutPrsModelInput | PrioritizedModelUpsertWithWhereUniqueWithoutPrsModelInput[]
    createMany?: PrioritizedModelCreateManyPrsModelInputEnvelope
    set?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
    disconnect?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
    delete?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
    connect?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
    update?: PrioritizedModelUpdateWithWhereUniqueWithoutPrsModelInput | PrioritizedModelUpdateWithWhereUniqueWithoutPrsModelInput[]
    updateMany?: PrioritizedModelUpdateManyWithWhereWithoutPrsModelInput | PrioritizedModelUpdateManyWithWhereWithoutPrsModelInput[]
    deleteMany?: PrioritizedModelScalarWhereInput | PrioritizedModelScalarWhereInput[]
  }

  export type ScoringFileUpdateOneWithoutPrsModelNestedInput = {
    create?: XOR<ScoringFileCreateWithoutPrsModelInput, ScoringFileUncheckedCreateWithoutPrsModelInput>
    connectOrCreate?: ScoringFileCreateOrConnectWithoutPrsModelInput
    upsert?: ScoringFileUpsertWithoutPrsModelInput
    disconnect?: ScoringFileWhereInput | boolean
    delete?: ScoringFileWhereInput | boolean
    connect?: ScoringFileWhereUniqueInput
    update?: XOR<XOR<ScoringFileUpdateToOneWithWhereWithoutPrsModelInput, ScoringFileUpdateWithoutPrsModelInput>, ScoringFileUncheckedUpdateWithoutPrsModelInput>
  }

  export type BroadAncestryInModelUncheckedUpdateManyWithoutPrsModelNestedInput = {
    create?: XOR<BroadAncestryInModelCreateWithoutPrsModelInput, BroadAncestryInModelUncheckedCreateWithoutPrsModelInput> | BroadAncestryInModelCreateWithoutPrsModelInput[] | BroadAncestryInModelUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: BroadAncestryInModelCreateOrConnectWithoutPrsModelInput | BroadAncestryInModelCreateOrConnectWithoutPrsModelInput[]
    upsert?: BroadAncestryInModelUpsertWithWhereUniqueWithoutPrsModelInput | BroadAncestryInModelUpsertWithWhereUniqueWithoutPrsModelInput[]
    createMany?: BroadAncestryInModelCreateManyPrsModelInputEnvelope
    set?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
    disconnect?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
    delete?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
    connect?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
    update?: BroadAncestryInModelUpdateWithWhereUniqueWithoutPrsModelInput | BroadAncestryInModelUpdateWithWhereUniqueWithoutPrsModelInput[]
    updateMany?: BroadAncestryInModelUpdateManyWithWhereWithoutPrsModelInput | BroadAncestryInModelUpdateManyWithWhereWithoutPrsModelInput[]
    deleteMany?: BroadAncestryInModelScalarWhereInput | BroadAncestryInModelScalarWhereInput[]
  }

  export type DevelopmentPopulationSampleUncheckedUpdateManyWithoutPrsModelNestedInput = {
    create?: XOR<DevelopmentPopulationSampleCreateWithoutPrsModelInput, DevelopmentPopulationSampleUncheckedCreateWithoutPrsModelInput> | DevelopmentPopulationSampleCreateWithoutPrsModelInput[] | DevelopmentPopulationSampleUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: DevelopmentPopulationSampleCreateOrConnectWithoutPrsModelInput | DevelopmentPopulationSampleCreateOrConnectWithoutPrsModelInput[]
    upsert?: DevelopmentPopulationSampleUpsertWithWhereUniqueWithoutPrsModelInput | DevelopmentPopulationSampleUpsertWithWhereUniqueWithoutPrsModelInput[]
    createMany?: DevelopmentPopulationSampleCreateManyPrsModelInputEnvelope
    set?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
    disconnect?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
    delete?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
    connect?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
    update?: DevelopmentPopulationSampleUpdateWithWhereUniqueWithoutPrsModelInput | DevelopmentPopulationSampleUpdateWithWhereUniqueWithoutPrsModelInput[]
    updateMany?: DevelopmentPopulationSampleUpdateManyWithWhereWithoutPrsModelInput | DevelopmentPopulationSampleUpdateManyWithWhereWithoutPrsModelInput[]
    deleteMany?: DevelopmentPopulationSampleScalarWhereInput | DevelopmentPopulationSampleScalarWhereInput[]
  }

  export type ModelEvaluationUncheckedUpdateManyWithoutPrsModelNestedInput = {
    create?: XOR<ModelEvaluationCreateWithoutPrsModelInput, ModelEvaluationUncheckedCreateWithoutPrsModelInput> | ModelEvaluationCreateWithoutPrsModelInput[] | ModelEvaluationUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: ModelEvaluationCreateOrConnectWithoutPrsModelInput | ModelEvaluationCreateOrConnectWithoutPrsModelInput[]
    upsert?: ModelEvaluationUpsertWithWhereUniqueWithoutPrsModelInput | ModelEvaluationUpsertWithWhereUniqueWithoutPrsModelInput[]
    createMany?: ModelEvaluationCreateManyPrsModelInputEnvelope
    set?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    disconnect?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    delete?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    connect?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    update?: ModelEvaluationUpdateWithWhereUniqueWithoutPrsModelInput | ModelEvaluationUpdateWithWhereUniqueWithoutPrsModelInput[]
    updateMany?: ModelEvaluationUpdateManyWithWhereWithoutPrsModelInput | ModelEvaluationUpdateManyWithWhereWithoutPrsModelInput[]
    deleteMany?: ModelEvaluationScalarWhereInput | ModelEvaluationScalarWhereInput[]
  }

  export type PRSModelToTraitUncheckedUpdateManyWithoutPrsModelNestedInput = {
    create?: XOR<PRSModelToTraitCreateWithoutPrsModelInput, PRSModelToTraitUncheckedCreateWithoutPrsModelInput> | PRSModelToTraitCreateWithoutPrsModelInput[] | PRSModelToTraitUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: PRSModelToTraitCreateOrConnectWithoutPrsModelInput | PRSModelToTraitCreateOrConnectWithoutPrsModelInput[]
    upsert?: PRSModelToTraitUpsertWithWhereUniqueWithoutPrsModelInput | PRSModelToTraitUpsertWithWhereUniqueWithoutPrsModelInput[]
    createMany?: PRSModelToTraitCreateManyPrsModelInputEnvelope
    set?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
    disconnect?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
    delete?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
    connect?: PRSModelToTraitWhereUniqueInput | PRSModelToTraitWhereUniqueInput[]
    update?: PRSModelToTraitUpdateWithWhereUniqueWithoutPrsModelInput | PRSModelToTraitUpdateWithWhereUniqueWithoutPrsModelInput[]
    updateMany?: PRSModelToTraitUpdateManyWithWhereWithoutPrsModelInput | PRSModelToTraitUpdateManyWithWhereWithoutPrsModelInput[]
    deleteMany?: PRSModelToTraitScalarWhereInput | PRSModelToTraitScalarWhereInput[]
  }

  export type PrioritizedModelUncheckedUpdateManyWithoutPrsModelNestedInput = {
    create?: XOR<PrioritizedModelCreateWithoutPrsModelInput, PrioritizedModelUncheckedCreateWithoutPrsModelInput> | PrioritizedModelCreateWithoutPrsModelInput[] | PrioritizedModelUncheckedCreateWithoutPrsModelInput[]
    connectOrCreate?: PrioritizedModelCreateOrConnectWithoutPrsModelInput | PrioritizedModelCreateOrConnectWithoutPrsModelInput[]
    upsert?: PrioritizedModelUpsertWithWhereUniqueWithoutPrsModelInput | PrioritizedModelUpsertWithWhereUniqueWithoutPrsModelInput[]
    createMany?: PrioritizedModelCreateManyPrsModelInputEnvelope
    set?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
    disconnect?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
    delete?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
    connect?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
    update?: PrioritizedModelUpdateWithWhereUniqueWithoutPrsModelInput | PrioritizedModelUpdateWithWhereUniqueWithoutPrsModelInput[]
    updateMany?: PrioritizedModelUpdateManyWithWhereWithoutPrsModelInput | PrioritizedModelUpdateManyWithWhereWithoutPrsModelInput[]
    deleteMany?: PrioritizedModelScalarWhereInput | PrioritizedModelScalarWhereInput[]
  }

  export type ScoringFileUncheckedUpdateOneWithoutPrsModelNestedInput = {
    create?: XOR<ScoringFileCreateWithoutPrsModelInput, ScoringFileUncheckedCreateWithoutPrsModelInput>
    connectOrCreate?: ScoringFileCreateOrConnectWithoutPrsModelInput
    upsert?: ScoringFileUpsertWithoutPrsModelInput
    disconnect?: ScoringFileWhereInput | boolean
    delete?: ScoringFileWhereInput | boolean
    connect?: ScoringFileWhereUniqueInput
    update?: XOR<XOR<ScoringFileUpdateToOneWithWhereWithoutPrsModelInput, ScoringFileUpdateWithoutPrsModelInput>, ScoringFileUncheckedUpdateWithoutPrsModelInput>
  }

  export type PRSModelCreateNestedOneWithoutTraitsInput = {
    create?: XOR<PRSModelCreateWithoutTraitsInput, PRSModelUncheckedCreateWithoutTraitsInput>
    connectOrCreate?: PRSModelCreateOrConnectWithoutTraitsInput
    connect?: PRSModelWhereUniqueInput
  }

  export type TraitCreateNestedOneWithoutPrsModelsInput = {
    create?: XOR<TraitCreateWithoutPrsModelsInput, TraitUncheckedCreateWithoutPrsModelsInput>
    connectOrCreate?: TraitCreateOrConnectWithoutPrsModelsInput
    connect?: TraitWhereUniqueInput
  }

  export type PRSModelUpdateOneRequiredWithoutTraitsNestedInput = {
    create?: XOR<PRSModelCreateWithoutTraitsInput, PRSModelUncheckedCreateWithoutTraitsInput>
    connectOrCreate?: PRSModelCreateOrConnectWithoutTraitsInput
    upsert?: PRSModelUpsertWithoutTraitsInput
    connect?: PRSModelWhereUniqueInput
    update?: XOR<XOR<PRSModelUpdateToOneWithWhereWithoutTraitsInput, PRSModelUpdateWithoutTraitsInput>, PRSModelUncheckedUpdateWithoutTraitsInput>
  }

  export type TraitUpdateOneRequiredWithoutPrsModelsNestedInput = {
    create?: XOR<TraitCreateWithoutPrsModelsInput, TraitUncheckedCreateWithoutPrsModelsInput>
    connectOrCreate?: TraitCreateOrConnectWithoutPrsModelsInput
    upsert?: TraitUpsertWithoutPrsModelsInput
    connect?: TraitWhereUniqueInput
    update?: XOR<XOR<TraitUpdateToOneWithWhereWithoutPrsModelsInput, TraitUpdateWithoutPrsModelsInput>, TraitUncheckedUpdateWithoutPrsModelsInput>
  }

  export type PRSModelCreateNestedOneWithoutScoringFilesInput = {
    create?: XOR<PRSModelCreateWithoutScoringFilesInput, PRSModelUncheckedCreateWithoutScoringFilesInput>
    connectOrCreate?: PRSModelCreateOrConnectWithoutScoringFilesInput
    connect?: PRSModelWhereUniqueInput
  }

  export type EnumAssemblyTypeFieldUpdateOperationsInput = {
    set?: $Enums.AssemblyType
  }

  export type PRSModelUpdateOneRequiredWithoutScoringFilesNestedInput = {
    create?: XOR<PRSModelCreateWithoutScoringFilesInput, PRSModelUncheckedCreateWithoutScoringFilesInput>
    connectOrCreate?: PRSModelCreateOrConnectWithoutScoringFilesInput
    upsert?: PRSModelUpsertWithoutScoringFilesInput
    connect?: PRSModelWhereUniqueInput
    update?: XOR<XOR<PRSModelUpdateToOneWithWhereWithoutScoringFilesInput, PRSModelUpdateWithoutScoringFilesInput>, PRSModelUncheckedUpdateWithoutScoringFilesInput>
  }

  export type ModelEvaluationCreateNestedManyWithoutPublicationInput = {
    create?: XOR<ModelEvaluationCreateWithoutPublicationInput, ModelEvaluationUncheckedCreateWithoutPublicationInput> | ModelEvaluationCreateWithoutPublicationInput[] | ModelEvaluationUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: ModelEvaluationCreateOrConnectWithoutPublicationInput | ModelEvaluationCreateOrConnectWithoutPublicationInput[]
    createMany?: ModelEvaluationCreateManyPublicationInputEnvelope
    connect?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
  }

  export type PRSModelCreateNestedManyWithoutPublicationInput = {
    create?: XOR<PRSModelCreateWithoutPublicationInput, PRSModelUncheckedCreateWithoutPublicationInput> | PRSModelCreateWithoutPublicationInput[] | PRSModelUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: PRSModelCreateOrConnectWithoutPublicationInput | PRSModelCreateOrConnectWithoutPublicationInput[]
    createMany?: PRSModelCreateManyPublicationInputEnvelope
    connect?: PRSModelWhereUniqueInput | PRSModelWhereUniqueInput[]
  }

  export type ModelEvaluationUncheckedCreateNestedManyWithoutPublicationInput = {
    create?: XOR<ModelEvaluationCreateWithoutPublicationInput, ModelEvaluationUncheckedCreateWithoutPublicationInput> | ModelEvaluationCreateWithoutPublicationInput[] | ModelEvaluationUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: ModelEvaluationCreateOrConnectWithoutPublicationInput | ModelEvaluationCreateOrConnectWithoutPublicationInput[]
    createMany?: ModelEvaluationCreateManyPublicationInputEnvelope
    connect?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
  }

  export type PRSModelUncheckedCreateNestedManyWithoutPublicationInput = {
    create?: XOR<PRSModelCreateWithoutPublicationInput, PRSModelUncheckedCreateWithoutPublicationInput> | PRSModelCreateWithoutPublicationInput[] | PRSModelUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: PRSModelCreateOrConnectWithoutPublicationInput | PRSModelCreateOrConnectWithoutPublicationInput[]
    createMany?: PRSModelCreateManyPublicationInputEnvelope
    connect?: PRSModelWhereUniqueInput | PRSModelWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ModelEvaluationUpdateManyWithoutPublicationNestedInput = {
    create?: XOR<ModelEvaluationCreateWithoutPublicationInput, ModelEvaluationUncheckedCreateWithoutPublicationInput> | ModelEvaluationCreateWithoutPublicationInput[] | ModelEvaluationUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: ModelEvaluationCreateOrConnectWithoutPublicationInput | ModelEvaluationCreateOrConnectWithoutPublicationInput[]
    upsert?: ModelEvaluationUpsertWithWhereUniqueWithoutPublicationInput | ModelEvaluationUpsertWithWhereUniqueWithoutPublicationInput[]
    createMany?: ModelEvaluationCreateManyPublicationInputEnvelope
    set?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    disconnect?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    delete?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    connect?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    update?: ModelEvaluationUpdateWithWhereUniqueWithoutPublicationInput | ModelEvaluationUpdateWithWhereUniqueWithoutPublicationInput[]
    updateMany?: ModelEvaluationUpdateManyWithWhereWithoutPublicationInput | ModelEvaluationUpdateManyWithWhereWithoutPublicationInput[]
    deleteMany?: ModelEvaluationScalarWhereInput | ModelEvaluationScalarWhereInput[]
  }

  export type PRSModelUpdateManyWithoutPublicationNestedInput = {
    create?: XOR<PRSModelCreateWithoutPublicationInput, PRSModelUncheckedCreateWithoutPublicationInput> | PRSModelCreateWithoutPublicationInput[] | PRSModelUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: PRSModelCreateOrConnectWithoutPublicationInput | PRSModelCreateOrConnectWithoutPublicationInput[]
    upsert?: PRSModelUpsertWithWhereUniqueWithoutPublicationInput | PRSModelUpsertWithWhereUniqueWithoutPublicationInput[]
    createMany?: PRSModelCreateManyPublicationInputEnvelope
    set?: PRSModelWhereUniqueInput | PRSModelWhereUniqueInput[]
    disconnect?: PRSModelWhereUniqueInput | PRSModelWhereUniqueInput[]
    delete?: PRSModelWhereUniqueInput | PRSModelWhereUniqueInput[]
    connect?: PRSModelWhereUniqueInput | PRSModelWhereUniqueInput[]
    update?: PRSModelUpdateWithWhereUniqueWithoutPublicationInput | PRSModelUpdateWithWhereUniqueWithoutPublicationInput[]
    updateMany?: PRSModelUpdateManyWithWhereWithoutPublicationInput | PRSModelUpdateManyWithWhereWithoutPublicationInput[]
    deleteMany?: PRSModelScalarWhereInput | PRSModelScalarWhereInput[]
  }

  export type ModelEvaluationUncheckedUpdateManyWithoutPublicationNestedInput = {
    create?: XOR<ModelEvaluationCreateWithoutPublicationInput, ModelEvaluationUncheckedCreateWithoutPublicationInput> | ModelEvaluationCreateWithoutPublicationInput[] | ModelEvaluationUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: ModelEvaluationCreateOrConnectWithoutPublicationInput | ModelEvaluationCreateOrConnectWithoutPublicationInput[]
    upsert?: ModelEvaluationUpsertWithWhereUniqueWithoutPublicationInput | ModelEvaluationUpsertWithWhereUniqueWithoutPublicationInput[]
    createMany?: ModelEvaluationCreateManyPublicationInputEnvelope
    set?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    disconnect?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    delete?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    connect?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    update?: ModelEvaluationUpdateWithWhereUniqueWithoutPublicationInput | ModelEvaluationUpdateWithWhereUniqueWithoutPublicationInput[]
    updateMany?: ModelEvaluationUpdateManyWithWhereWithoutPublicationInput | ModelEvaluationUpdateManyWithWhereWithoutPublicationInput[]
    deleteMany?: ModelEvaluationScalarWhereInput | ModelEvaluationScalarWhereInput[]
  }

  export type PRSModelUncheckedUpdateManyWithoutPublicationNestedInput = {
    create?: XOR<PRSModelCreateWithoutPublicationInput, PRSModelUncheckedCreateWithoutPublicationInput> | PRSModelCreateWithoutPublicationInput[] | PRSModelUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: PRSModelCreateOrConnectWithoutPublicationInput | PRSModelCreateOrConnectWithoutPublicationInput[]
    upsert?: PRSModelUpsertWithWhereUniqueWithoutPublicationInput | PRSModelUpsertWithWhereUniqueWithoutPublicationInput[]
    createMany?: PRSModelCreateManyPublicationInputEnvelope
    set?: PRSModelWhereUniqueInput | PRSModelWhereUniqueInput[]
    disconnect?: PRSModelWhereUniqueInput | PRSModelWhereUniqueInput[]
    delete?: PRSModelWhereUniqueInput | PRSModelWhereUniqueInput[]
    connect?: PRSModelWhereUniqueInput | PRSModelWhereUniqueInput[]
    update?: PRSModelUpdateWithWhereUniqueWithoutPublicationInput | PRSModelUpdateWithWhereUniqueWithoutPublicationInput[]
    updateMany?: PRSModelUpdateManyWithWhereWithoutPublicationInput | PRSModelUpdateManyWithWhereWithoutPublicationInput[]
    deleteMany?: PRSModelScalarWhereInput | PRSModelScalarWhereInput[]
  }

  export type EvaluationPopulationSampleCreateNestedOneWithoutModelEvaluationsInput = {
    create?: XOR<EvaluationPopulationSampleCreateWithoutModelEvaluationsInput, EvaluationPopulationSampleUncheckedCreateWithoutModelEvaluationsInput>
    connectOrCreate?: EvaluationPopulationSampleCreateOrConnectWithoutModelEvaluationsInput
    connect?: EvaluationPopulationSampleWhereUniqueInput
  }

  export type PRSModelCreateNestedOneWithoutModelEvaluationsInput = {
    create?: XOR<PRSModelCreateWithoutModelEvaluationsInput, PRSModelUncheckedCreateWithoutModelEvaluationsInput>
    connectOrCreate?: PRSModelCreateOrConnectWithoutModelEvaluationsInput
    connect?: PRSModelWhereUniqueInput
  }

  export type PublicationCreateNestedOneWithoutModelEvaluationsInput = {
    create?: XOR<PublicationCreateWithoutModelEvaluationsInput, PublicationUncheckedCreateWithoutModelEvaluationsInput>
    connectOrCreate?: PublicationCreateOrConnectWithoutModelEvaluationsInput
    connect?: PublicationWhereUniqueInput
  }

  export type PerformanceMetricEvaluationCreateNestedManyWithoutModelEvaluationInput = {
    create?: XOR<PerformanceMetricEvaluationCreateWithoutModelEvaluationInput, PerformanceMetricEvaluationUncheckedCreateWithoutModelEvaluationInput> | PerformanceMetricEvaluationCreateWithoutModelEvaluationInput[] | PerformanceMetricEvaluationUncheckedCreateWithoutModelEvaluationInput[]
    connectOrCreate?: PerformanceMetricEvaluationCreateOrConnectWithoutModelEvaluationInput | PerformanceMetricEvaluationCreateOrConnectWithoutModelEvaluationInput[]
    createMany?: PerformanceMetricEvaluationCreateManyModelEvaluationInputEnvelope
    connect?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
  }

  export type PerformanceMetricEvaluationUncheckedCreateNestedManyWithoutModelEvaluationInput = {
    create?: XOR<PerformanceMetricEvaluationCreateWithoutModelEvaluationInput, PerformanceMetricEvaluationUncheckedCreateWithoutModelEvaluationInput> | PerformanceMetricEvaluationCreateWithoutModelEvaluationInput[] | PerformanceMetricEvaluationUncheckedCreateWithoutModelEvaluationInput[]
    connectOrCreate?: PerformanceMetricEvaluationCreateOrConnectWithoutModelEvaluationInput | PerformanceMetricEvaluationCreateOrConnectWithoutModelEvaluationInput[]
    createMany?: PerformanceMetricEvaluationCreateManyModelEvaluationInputEnvelope
    connect?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
  }

  export type EvaluationPopulationSampleUpdateOneRequiredWithoutModelEvaluationsNestedInput = {
    create?: XOR<EvaluationPopulationSampleCreateWithoutModelEvaluationsInput, EvaluationPopulationSampleUncheckedCreateWithoutModelEvaluationsInput>
    connectOrCreate?: EvaluationPopulationSampleCreateOrConnectWithoutModelEvaluationsInput
    upsert?: EvaluationPopulationSampleUpsertWithoutModelEvaluationsInput
    connect?: EvaluationPopulationSampleWhereUniqueInput
    update?: XOR<XOR<EvaluationPopulationSampleUpdateToOneWithWhereWithoutModelEvaluationsInput, EvaluationPopulationSampleUpdateWithoutModelEvaluationsInput>, EvaluationPopulationSampleUncheckedUpdateWithoutModelEvaluationsInput>
  }

  export type PRSModelUpdateOneRequiredWithoutModelEvaluationsNestedInput = {
    create?: XOR<PRSModelCreateWithoutModelEvaluationsInput, PRSModelUncheckedCreateWithoutModelEvaluationsInput>
    connectOrCreate?: PRSModelCreateOrConnectWithoutModelEvaluationsInput
    upsert?: PRSModelUpsertWithoutModelEvaluationsInput
    connect?: PRSModelWhereUniqueInput
    update?: XOR<XOR<PRSModelUpdateToOneWithWhereWithoutModelEvaluationsInput, PRSModelUpdateWithoutModelEvaluationsInput>, PRSModelUncheckedUpdateWithoutModelEvaluationsInput>
  }

  export type PublicationUpdateOneRequiredWithoutModelEvaluationsNestedInput = {
    create?: XOR<PublicationCreateWithoutModelEvaluationsInput, PublicationUncheckedCreateWithoutModelEvaluationsInput>
    connectOrCreate?: PublicationCreateOrConnectWithoutModelEvaluationsInput
    upsert?: PublicationUpsertWithoutModelEvaluationsInput
    connect?: PublicationWhereUniqueInput
    update?: XOR<XOR<PublicationUpdateToOneWithWhereWithoutModelEvaluationsInput, PublicationUpdateWithoutModelEvaluationsInput>, PublicationUncheckedUpdateWithoutModelEvaluationsInput>
  }

  export type PerformanceMetricEvaluationUpdateManyWithoutModelEvaluationNestedInput = {
    create?: XOR<PerformanceMetricEvaluationCreateWithoutModelEvaluationInput, PerformanceMetricEvaluationUncheckedCreateWithoutModelEvaluationInput> | PerformanceMetricEvaluationCreateWithoutModelEvaluationInput[] | PerformanceMetricEvaluationUncheckedCreateWithoutModelEvaluationInput[]
    connectOrCreate?: PerformanceMetricEvaluationCreateOrConnectWithoutModelEvaluationInput | PerformanceMetricEvaluationCreateOrConnectWithoutModelEvaluationInput[]
    upsert?: PerformanceMetricEvaluationUpsertWithWhereUniqueWithoutModelEvaluationInput | PerformanceMetricEvaluationUpsertWithWhereUniqueWithoutModelEvaluationInput[]
    createMany?: PerformanceMetricEvaluationCreateManyModelEvaluationInputEnvelope
    set?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
    disconnect?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
    delete?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
    connect?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
    update?: PerformanceMetricEvaluationUpdateWithWhereUniqueWithoutModelEvaluationInput | PerformanceMetricEvaluationUpdateWithWhereUniqueWithoutModelEvaluationInput[]
    updateMany?: PerformanceMetricEvaluationUpdateManyWithWhereWithoutModelEvaluationInput | PerformanceMetricEvaluationUpdateManyWithWhereWithoutModelEvaluationInput[]
    deleteMany?: PerformanceMetricEvaluationScalarWhereInput | PerformanceMetricEvaluationScalarWhereInput[]
  }

  export type PerformanceMetricEvaluationUncheckedUpdateManyWithoutModelEvaluationNestedInput = {
    create?: XOR<PerformanceMetricEvaluationCreateWithoutModelEvaluationInput, PerformanceMetricEvaluationUncheckedCreateWithoutModelEvaluationInput> | PerformanceMetricEvaluationCreateWithoutModelEvaluationInput[] | PerformanceMetricEvaluationUncheckedCreateWithoutModelEvaluationInput[]
    connectOrCreate?: PerformanceMetricEvaluationCreateOrConnectWithoutModelEvaluationInput | PerformanceMetricEvaluationCreateOrConnectWithoutModelEvaluationInput[]
    upsert?: PerformanceMetricEvaluationUpsertWithWhereUniqueWithoutModelEvaluationInput | PerformanceMetricEvaluationUpsertWithWhereUniqueWithoutModelEvaluationInput[]
    createMany?: PerformanceMetricEvaluationCreateManyModelEvaluationInputEnvelope
    set?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
    disconnect?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
    delete?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
    connect?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
    update?: PerformanceMetricEvaluationUpdateWithWhereUniqueWithoutModelEvaluationInput | PerformanceMetricEvaluationUpdateWithWhereUniqueWithoutModelEvaluationInput[]
    updateMany?: PerformanceMetricEvaluationUpdateManyWithWhereWithoutModelEvaluationInput | PerformanceMetricEvaluationUpdateManyWithWhereWithoutModelEvaluationInput[]
    deleteMany?: PerformanceMetricEvaluationScalarWhereInput | PerformanceMetricEvaluationScalarWhereInput[]
  }

  export type ModelEvaluationCreateNestedOneWithoutMetricEvaluationsInput = {
    create?: XOR<ModelEvaluationCreateWithoutMetricEvaluationsInput, ModelEvaluationUncheckedCreateWithoutMetricEvaluationsInput>
    connectOrCreate?: ModelEvaluationCreateOrConnectWithoutMetricEvaluationsInput
    connect?: ModelEvaluationWhereUniqueInput
  }

  export type PerformanceMetricCreateNestedOneWithoutPerformanceMetricEvaluationsInput = {
    create?: XOR<PerformanceMetricCreateWithoutPerformanceMetricEvaluationsInput, PerformanceMetricUncheckedCreateWithoutPerformanceMetricEvaluationsInput>
    connectOrCreate?: PerformanceMetricCreateOrConnectWithoutPerformanceMetricEvaluationsInput
    connect?: PerformanceMetricWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ModelEvaluationUpdateOneRequiredWithoutMetricEvaluationsNestedInput = {
    create?: XOR<ModelEvaluationCreateWithoutMetricEvaluationsInput, ModelEvaluationUncheckedCreateWithoutMetricEvaluationsInput>
    connectOrCreate?: ModelEvaluationCreateOrConnectWithoutMetricEvaluationsInput
    upsert?: ModelEvaluationUpsertWithoutMetricEvaluationsInput
    connect?: ModelEvaluationWhereUniqueInput
    update?: XOR<XOR<ModelEvaluationUpdateToOneWithWhereWithoutMetricEvaluationsInput, ModelEvaluationUpdateWithoutMetricEvaluationsInput>, ModelEvaluationUncheckedUpdateWithoutMetricEvaluationsInput>
  }

  export type PerformanceMetricUpdateOneRequiredWithoutPerformanceMetricEvaluationsNestedInput = {
    create?: XOR<PerformanceMetricCreateWithoutPerformanceMetricEvaluationsInput, PerformanceMetricUncheckedCreateWithoutPerformanceMetricEvaluationsInput>
    connectOrCreate?: PerformanceMetricCreateOrConnectWithoutPerformanceMetricEvaluationsInput
    upsert?: PerformanceMetricUpsertWithoutPerformanceMetricEvaluationsInput
    connect?: PerformanceMetricWhereUniqueInput
    update?: XOR<XOR<PerformanceMetricUpdateToOneWithWhereWithoutPerformanceMetricEvaluationsInput, PerformanceMetricUpdateWithoutPerformanceMetricEvaluationsInput>, PerformanceMetricUncheckedUpdateWithoutPerformanceMetricEvaluationsInput>
  }

  export type PerformanceMetricEvaluationCreateNestedManyWithoutPerformanceMetricInput = {
    create?: XOR<PerformanceMetricEvaluationCreateWithoutPerformanceMetricInput, PerformanceMetricEvaluationUncheckedCreateWithoutPerformanceMetricInput> | PerformanceMetricEvaluationCreateWithoutPerformanceMetricInput[] | PerformanceMetricEvaluationUncheckedCreateWithoutPerformanceMetricInput[]
    connectOrCreate?: PerformanceMetricEvaluationCreateOrConnectWithoutPerformanceMetricInput | PerformanceMetricEvaluationCreateOrConnectWithoutPerformanceMetricInput[]
    createMany?: PerformanceMetricEvaluationCreateManyPerformanceMetricInputEnvelope
    connect?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
  }

  export type PerformanceMetricEvaluationUncheckedCreateNestedManyWithoutPerformanceMetricInput = {
    create?: XOR<PerformanceMetricEvaluationCreateWithoutPerformanceMetricInput, PerformanceMetricEvaluationUncheckedCreateWithoutPerformanceMetricInput> | PerformanceMetricEvaluationCreateWithoutPerformanceMetricInput[] | PerformanceMetricEvaluationUncheckedCreateWithoutPerformanceMetricInput[]
    connectOrCreate?: PerformanceMetricEvaluationCreateOrConnectWithoutPerformanceMetricInput | PerformanceMetricEvaluationCreateOrConnectWithoutPerformanceMetricInput[]
    createMany?: PerformanceMetricEvaluationCreateManyPerformanceMetricInputEnvelope
    connect?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
  }

  export type EnumPerformanceMetricTypeFieldUpdateOperationsInput = {
    set?: $Enums.PerformanceMetricType
  }

  export type PerformanceMetricEvaluationUpdateManyWithoutPerformanceMetricNestedInput = {
    create?: XOR<PerformanceMetricEvaluationCreateWithoutPerformanceMetricInput, PerformanceMetricEvaluationUncheckedCreateWithoutPerformanceMetricInput> | PerformanceMetricEvaluationCreateWithoutPerformanceMetricInput[] | PerformanceMetricEvaluationUncheckedCreateWithoutPerformanceMetricInput[]
    connectOrCreate?: PerformanceMetricEvaluationCreateOrConnectWithoutPerformanceMetricInput | PerformanceMetricEvaluationCreateOrConnectWithoutPerformanceMetricInput[]
    upsert?: PerformanceMetricEvaluationUpsertWithWhereUniqueWithoutPerformanceMetricInput | PerformanceMetricEvaluationUpsertWithWhereUniqueWithoutPerformanceMetricInput[]
    createMany?: PerformanceMetricEvaluationCreateManyPerformanceMetricInputEnvelope
    set?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
    disconnect?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
    delete?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
    connect?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
    update?: PerformanceMetricEvaluationUpdateWithWhereUniqueWithoutPerformanceMetricInput | PerformanceMetricEvaluationUpdateWithWhereUniqueWithoutPerformanceMetricInput[]
    updateMany?: PerformanceMetricEvaluationUpdateManyWithWhereWithoutPerformanceMetricInput | PerformanceMetricEvaluationUpdateManyWithWhereWithoutPerformanceMetricInput[]
    deleteMany?: PerformanceMetricEvaluationScalarWhereInput | PerformanceMetricEvaluationScalarWhereInput[]
  }

  export type PerformanceMetricEvaluationUncheckedUpdateManyWithoutPerformanceMetricNestedInput = {
    create?: XOR<PerformanceMetricEvaluationCreateWithoutPerformanceMetricInput, PerformanceMetricEvaluationUncheckedCreateWithoutPerformanceMetricInput> | PerformanceMetricEvaluationCreateWithoutPerformanceMetricInput[] | PerformanceMetricEvaluationUncheckedCreateWithoutPerformanceMetricInput[]
    connectOrCreate?: PerformanceMetricEvaluationCreateOrConnectWithoutPerformanceMetricInput | PerformanceMetricEvaluationCreateOrConnectWithoutPerformanceMetricInput[]
    upsert?: PerformanceMetricEvaluationUpsertWithWhereUniqueWithoutPerformanceMetricInput | PerformanceMetricEvaluationUpsertWithWhereUniqueWithoutPerformanceMetricInput[]
    createMany?: PerformanceMetricEvaluationCreateManyPerformanceMetricInputEnvelope
    set?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
    disconnect?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
    delete?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
    connect?: PerformanceMetricEvaluationWhereUniqueInput | PerformanceMetricEvaluationWhereUniqueInput[]
    update?: PerformanceMetricEvaluationUpdateWithWhereUniqueWithoutPerformanceMetricInput | PerformanceMetricEvaluationUpdateWithWhereUniqueWithoutPerformanceMetricInput[]
    updateMany?: PerformanceMetricEvaluationUpdateManyWithWhereWithoutPerformanceMetricInput | PerformanceMetricEvaluationUpdateManyWithWhereWithoutPerformanceMetricInput[]
    deleteMany?: PerformanceMetricEvaluationScalarWhereInput | PerformanceMetricEvaluationScalarWhereInput[]
  }

  export type BroadAncestryCategoryCreateNestedOneWithoutEvaluationPopulationSamplesInput = {
    create?: XOR<BroadAncestryCategoryCreateWithoutEvaluationPopulationSamplesInput, BroadAncestryCategoryUncheckedCreateWithoutEvaluationPopulationSamplesInput>
    connectOrCreate?: BroadAncestryCategoryCreateOrConnectWithoutEvaluationPopulationSamplesInput
    connect?: BroadAncestryCategoryWhereUniqueInput
  }

  export type ModelEvaluationCreateNestedManyWithoutEvaluationPopulationSampleInput = {
    create?: XOR<ModelEvaluationCreateWithoutEvaluationPopulationSampleInput, ModelEvaluationUncheckedCreateWithoutEvaluationPopulationSampleInput> | ModelEvaluationCreateWithoutEvaluationPopulationSampleInput[] | ModelEvaluationUncheckedCreateWithoutEvaluationPopulationSampleInput[]
    connectOrCreate?: ModelEvaluationCreateOrConnectWithoutEvaluationPopulationSampleInput | ModelEvaluationCreateOrConnectWithoutEvaluationPopulationSampleInput[]
    createMany?: ModelEvaluationCreateManyEvaluationPopulationSampleInputEnvelope
    connect?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
  }

  export type ModelEvaluationUncheckedCreateNestedManyWithoutEvaluationPopulationSampleInput = {
    create?: XOR<ModelEvaluationCreateWithoutEvaluationPopulationSampleInput, ModelEvaluationUncheckedCreateWithoutEvaluationPopulationSampleInput> | ModelEvaluationCreateWithoutEvaluationPopulationSampleInput[] | ModelEvaluationUncheckedCreateWithoutEvaluationPopulationSampleInput[]
    connectOrCreate?: ModelEvaluationCreateOrConnectWithoutEvaluationPopulationSampleInput | ModelEvaluationCreateOrConnectWithoutEvaluationPopulationSampleInput[]
    createMany?: ModelEvaluationCreateManyEvaluationPopulationSampleInputEnvelope
    connect?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
  }

  export type BroadAncestryCategoryUpdateOneRequiredWithoutEvaluationPopulationSamplesNestedInput = {
    create?: XOR<BroadAncestryCategoryCreateWithoutEvaluationPopulationSamplesInput, BroadAncestryCategoryUncheckedCreateWithoutEvaluationPopulationSamplesInput>
    connectOrCreate?: BroadAncestryCategoryCreateOrConnectWithoutEvaluationPopulationSamplesInput
    upsert?: BroadAncestryCategoryUpsertWithoutEvaluationPopulationSamplesInput
    connect?: BroadAncestryCategoryWhereUniqueInput
    update?: XOR<XOR<BroadAncestryCategoryUpdateToOneWithWhereWithoutEvaluationPopulationSamplesInput, BroadAncestryCategoryUpdateWithoutEvaluationPopulationSamplesInput>, BroadAncestryCategoryUncheckedUpdateWithoutEvaluationPopulationSamplesInput>
  }

  export type ModelEvaluationUpdateManyWithoutEvaluationPopulationSampleNestedInput = {
    create?: XOR<ModelEvaluationCreateWithoutEvaluationPopulationSampleInput, ModelEvaluationUncheckedCreateWithoutEvaluationPopulationSampleInput> | ModelEvaluationCreateWithoutEvaluationPopulationSampleInput[] | ModelEvaluationUncheckedCreateWithoutEvaluationPopulationSampleInput[]
    connectOrCreate?: ModelEvaluationCreateOrConnectWithoutEvaluationPopulationSampleInput | ModelEvaluationCreateOrConnectWithoutEvaluationPopulationSampleInput[]
    upsert?: ModelEvaluationUpsertWithWhereUniqueWithoutEvaluationPopulationSampleInput | ModelEvaluationUpsertWithWhereUniqueWithoutEvaluationPopulationSampleInput[]
    createMany?: ModelEvaluationCreateManyEvaluationPopulationSampleInputEnvelope
    set?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    disconnect?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    delete?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    connect?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    update?: ModelEvaluationUpdateWithWhereUniqueWithoutEvaluationPopulationSampleInput | ModelEvaluationUpdateWithWhereUniqueWithoutEvaluationPopulationSampleInput[]
    updateMany?: ModelEvaluationUpdateManyWithWhereWithoutEvaluationPopulationSampleInput | ModelEvaluationUpdateManyWithWhereWithoutEvaluationPopulationSampleInput[]
    deleteMany?: ModelEvaluationScalarWhereInput | ModelEvaluationScalarWhereInput[]
  }

  export type ModelEvaluationUncheckedUpdateManyWithoutEvaluationPopulationSampleNestedInput = {
    create?: XOR<ModelEvaluationCreateWithoutEvaluationPopulationSampleInput, ModelEvaluationUncheckedCreateWithoutEvaluationPopulationSampleInput> | ModelEvaluationCreateWithoutEvaluationPopulationSampleInput[] | ModelEvaluationUncheckedCreateWithoutEvaluationPopulationSampleInput[]
    connectOrCreate?: ModelEvaluationCreateOrConnectWithoutEvaluationPopulationSampleInput | ModelEvaluationCreateOrConnectWithoutEvaluationPopulationSampleInput[]
    upsert?: ModelEvaluationUpsertWithWhereUniqueWithoutEvaluationPopulationSampleInput | ModelEvaluationUpsertWithWhereUniqueWithoutEvaluationPopulationSampleInput[]
    createMany?: ModelEvaluationCreateManyEvaluationPopulationSampleInputEnvelope
    set?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    disconnect?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    delete?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    connect?: ModelEvaluationWhereUniqueInput | ModelEvaluationWhereUniqueInput[]
    update?: ModelEvaluationUpdateWithWhereUniqueWithoutEvaluationPopulationSampleInput | ModelEvaluationUpdateWithWhereUniqueWithoutEvaluationPopulationSampleInput[]
    updateMany?: ModelEvaluationUpdateManyWithWhereWithoutEvaluationPopulationSampleInput | ModelEvaluationUpdateManyWithWhereWithoutEvaluationPopulationSampleInput[]
    deleteMany?: ModelEvaluationScalarWhereInput | ModelEvaluationScalarWhereInput[]
  }

  export type BroadAncestryInModelCreateNestedManyWithoutBroadAncestryCategoryInput = {
    create?: XOR<BroadAncestryInModelCreateWithoutBroadAncestryCategoryInput, BroadAncestryInModelUncheckedCreateWithoutBroadAncestryCategoryInput> | BroadAncestryInModelCreateWithoutBroadAncestryCategoryInput[] | BroadAncestryInModelUncheckedCreateWithoutBroadAncestryCategoryInput[]
    connectOrCreate?: BroadAncestryInModelCreateOrConnectWithoutBroadAncestryCategoryInput | BroadAncestryInModelCreateOrConnectWithoutBroadAncestryCategoryInput[]
    createMany?: BroadAncestryInModelCreateManyBroadAncestryCategoryInputEnvelope
    connect?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
  }

  export type BroadAncestryInRefPopCreateNestedManyWithoutBroadAncestryCategoryInput = {
    create?: XOR<BroadAncestryInRefPopCreateWithoutBroadAncestryCategoryInput, BroadAncestryInRefPopUncheckedCreateWithoutBroadAncestryCategoryInput> | BroadAncestryInRefPopCreateWithoutBroadAncestryCategoryInput[] | BroadAncestryInRefPopUncheckedCreateWithoutBroadAncestryCategoryInput[]
    connectOrCreate?: BroadAncestryInRefPopCreateOrConnectWithoutBroadAncestryCategoryInput | BroadAncestryInRefPopCreateOrConnectWithoutBroadAncestryCategoryInput[]
    createMany?: BroadAncestryInRefPopCreateManyBroadAncestryCategoryInputEnvelope
    connect?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
  }

  export type DevelopmentPopulationSampleCreateNestedManyWithoutBroadAncestryCategoryInput = {
    create?: XOR<DevelopmentPopulationSampleCreateWithoutBroadAncestryCategoryInput, DevelopmentPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput> | DevelopmentPopulationSampleCreateWithoutBroadAncestryCategoryInput[] | DevelopmentPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput[]
    connectOrCreate?: DevelopmentPopulationSampleCreateOrConnectWithoutBroadAncestryCategoryInput | DevelopmentPopulationSampleCreateOrConnectWithoutBroadAncestryCategoryInput[]
    createMany?: DevelopmentPopulationSampleCreateManyBroadAncestryCategoryInputEnvelope
    connect?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
  }

  export type EvaluationPopulationSampleCreateNestedManyWithoutBroadAncestryCategoryInput = {
    create?: XOR<EvaluationPopulationSampleCreateWithoutBroadAncestryCategoryInput, EvaluationPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput> | EvaluationPopulationSampleCreateWithoutBroadAncestryCategoryInput[] | EvaluationPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput[]
    connectOrCreate?: EvaluationPopulationSampleCreateOrConnectWithoutBroadAncestryCategoryInput | EvaluationPopulationSampleCreateOrConnectWithoutBroadAncestryCategoryInput[]
    createMany?: EvaluationPopulationSampleCreateManyBroadAncestryCategoryInputEnvelope
    connect?: EvaluationPopulationSampleWhereUniqueInput | EvaluationPopulationSampleWhereUniqueInput[]
  }

  export type BroadAncestryInModelUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput = {
    create?: XOR<BroadAncestryInModelCreateWithoutBroadAncestryCategoryInput, BroadAncestryInModelUncheckedCreateWithoutBroadAncestryCategoryInput> | BroadAncestryInModelCreateWithoutBroadAncestryCategoryInput[] | BroadAncestryInModelUncheckedCreateWithoutBroadAncestryCategoryInput[]
    connectOrCreate?: BroadAncestryInModelCreateOrConnectWithoutBroadAncestryCategoryInput | BroadAncestryInModelCreateOrConnectWithoutBroadAncestryCategoryInput[]
    createMany?: BroadAncestryInModelCreateManyBroadAncestryCategoryInputEnvelope
    connect?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
  }

  export type BroadAncestryInRefPopUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput = {
    create?: XOR<BroadAncestryInRefPopCreateWithoutBroadAncestryCategoryInput, BroadAncestryInRefPopUncheckedCreateWithoutBroadAncestryCategoryInput> | BroadAncestryInRefPopCreateWithoutBroadAncestryCategoryInput[] | BroadAncestryInRefPopUncheckedCreateWithoutBroadAncestryCategoryInput[]
    connectOrCreate?: BroadAncestryInRefPopCreateOrConnectWithoutBroadAncestryCategoryInput | BroadAncestryInRefPopCreateOrConnectWithoutBroadAncestryCategoryInput[]
    createMany?: BroadAncestryInRefPopCreateManyBroadAncestryCategoryInputEnvelope
    connect?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
  }

  export type DevelopmentPopulationSampleUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput = {
    create?: XOR<DevelopmentPopulationSampleCreateWithoutBroadAncestryCategoryInput, DevelopmentPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput> | DevelopmentPopulationSampleCreateWithoutBroadAncestryCategoryInput[] | DevelopmentPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput[]
    connectOrCreate?: DevelopmentPopulationSampleCreateOrConnectWithoutBroadAncestryCategoryInput | DevelopmentPopulationSampleCreateOrConnectWithoutBroadAncestryCategoryInput[]
    createMany?: DevelopmentPopulationSampleCreateManyBroadAncestryCategoryInputEnvelope
    connect?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
  }

  export type EvaluationPopulationSampleUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput = {
    create?: XOR<EvaluationPopulationSampleCreateWithoutBroadAncestryCategoryInput, EvaluationPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput> | EvaluationPopulationSampleCreateWithoutBroadAncestryCategoryInput[] | EvaluationPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput[]
    connectOrCreate?: EvaluationPopulationSampleCreateOrConnectWithoutBroadAncestryCategoryInput | EvaluationPopulationSampleCreateOrConnectWithoutBroadAncestryCategoryInput[]
    createMany?: EvaluationPopulationSampleCreateManyBroadAncestryCategoryInputEnvelope
    connect?: EvaluationPopulationSampleWhereUniqueInput | EvaluationPopulationSampleWhereUniqueInput[]
  }

  export type BroadAncestryInModelUpdateManyWithoutBroadAncestryCategoryNestedInput = {
    create?: XOR<BroadAncestryInModelCreateWithoutBroadAncestryCategoryInput, BroadAncestryInModelUncheckedCreateWithoutBroadAncestryCategoryInput> | BroadAncestryInModelCreateWithoutBroadAncestryCategoryInput[] | BroadAncestryInModelUncheckedCreateWithoutBroadAncestryCategoryInput[]
    connectOrCreate?: BroadAncestryInModelCreateOrConnectWithoutBroadAncestryCategoryInput | BroadAncestryInModelCreateOrConnectWithoutBroadAncestryCategoryInput[]
    upsert?: BroadAncestryInModelUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput | BroadAncestryInModelUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput[]
    createMany?: BroadAncestryInModelCreateManyBroadAncestryCategoryInputEnvelope
    set?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
    disconnect?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
    delete?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
    connect?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
    update?: BroadAncestryInModelUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput | BroadAncestryInModelUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput[]
    updateMany?: BroadAncestryInModelUpdateManyWithWhereWithoutBroadAncestryCategoryInput | BroadAncestryInModelUpdateManyWithWhereWithoutBroadAncestryCategoryInput[]
    deleteMany?: BroadAncestryInModelScalarWhereInput | BroadAncestryInModelScalarWhereInput[]
  }

  export type BroadAncestryInRefPopUpdateManyWithoutBroadAncestryCategoryNestedInput = {
    create?: XOR<BroadAncestryInRefPopCreateWithoutBroadAncestryCategoryInput, BroadAncestryInRefPopUncheckedCreateWithoutBroadAncestryCategoryInput> | BroadAncestryInRefPopCreateWithoutBroadAncestryCategoryInput[] | BroadAncestryInRefPopUncheckedCreateWithoutBroadAncestryCategoryInput[]
    connectOrCreate?: BroadAncestryInRefPopCreateOrConnectWithoutBroadAncestryCategoryInput | BroadAncestryInRefPopCreateOrConnectWithoutBroadAncestryCategoryInput[]
    upsert?: BroadAncestryInRefPopUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput | BroadAncestryInRefPopUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput[]
    createMany?: BroadAncestryInRefPopCreateManyBroadAncestryCategoryInputEnvelope
    set?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
    disconnect?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
    delete?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
    connect?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
    update?: BroadAncestryInRefPopUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput | BroadAncestryInRefPopUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput[]
    updateMany?: BroadAncestryInRefPopUpdateManyWithWhereWithoutBroadAncestryCategoryInput | BroadAncestryInRefPopUpdateManyWithWhereWithoutBroadAncestryCategoryInput[]
    deleteMany?: BroadAncestryInRefPopScalarWhereInput | BroadAncestryInRefPopScalarWhereInput[]
  }

  export type DevelopmentPopulationSampleUpdateManyWithoutBroadAncestryCategoryNestedInput = {
    create?: XOR<DevelopmentPopulationSampleCreateWithoutBroadAncestryCategoryInput, DevelopmentPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput> | DevelopmentPopulationSampleCreateWithoutBroadAncestryCategoryInput[] | DevelopmentPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput[]
    connectOrCreate?: DevelopmentPopulationSampleCreateOrConnectWithoutBroadAncestryCategoryInput | DevelopmentPopulationSampleCreateOrConnectWithoutBroadAncestryCategoryInput[]
    upsert?: DevelopmentPopulationSampleUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput | DevelopmentPopulationSampleUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput[]
    createMany?: DevelopmentPopulationSampleCreateManyBroadAncestryCategoryInputEnvelope
    set?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
    disconnect?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
    delete?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
    connect?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
    update?: DevelopmentPopulationSampleUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput | DevelopmentPopulationSampleUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput[]
    updateMany?: DevelopmentPopulationSampleUpdateManyWithWhereWithoutBroadAncestryCategoryInput | DevelopmentPopulationSampleUpdateManyWithWhereWithoutBroadAncestryCategoryInput[]
    deleteMany?: DevelopmentPopulationSampleScalarWhereInput | DevelopmentPopulationSampleScalarWhereInput[]
  }

  export type EvaluationPopulationSampleUpdateManyWithoutBroadAncestryCategoryNestedInput = {
    create?: XOR<EvaluationPopulationSampleCreateWithoutBroadAncestryCategoryInput, EvaluationPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput> | EvaluationPopulationSampleCreateWithoutBroadAncestryCategoryInput[] | EvaluationPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput[]
    connectOrCreate?: EvaluationPopulationSampleCreateOrConnectWithoutBroadAncestryCategoryInput | EvaluationPopulationSampleCreateOrConnectWithoutBroadAncestryCategoryInput[]
    upsert?: EvaluationPopulationSampleUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput | EvaluationPopulationSampleUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput[]
    createMany?: EvaluationPopulationSampleCreateManyBroadAncestryCategoryInputEnvelope
    set?: EvaluationPopulationSampleWhereUniqueInput | EvaluationPopulationSampleWhereUniqueInput[]
    disconnect?: EvaluationPopulationSampleWhereUniqueInput | EvaluationPopulationSampleWhereUniqueInput[]
    delete?: EvaluationPopulationSampleWhereUniqueInput | EvaluationPopulationSampleWhereUniqueInput[]
    connect?: EvaluationPopulationSampleWhereUniqueInput | EvaluationPopulationSampleWhereUniqueInput[]
    update?: EvaluationPopulationSampleUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput | EvaluationPopulationSampleUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput[]
    updateMany?: EvaluationPopulationSampleUpdateManyWithWhereWithoutBroadAncestryCategoryInput | EvaluationPopulationSampleUpdateManyWithWhereWithoutBroadAncestryCategoryInput[]
    deleteMany?: EvaluationPopulationSampleScalarWhereInput | EvaluationPopulationSampleScalarWhereInput[]
  }

  export type BroadAncestryInModelUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput = {
    create?: XOR<BroadAncestryInModelCreateWithoutBroadAncestryCategoryInput, BroadAncestryInModelUncheckedCreateWithoutBroadAncestryCategoryInput> | BroadAncestryInModelCreateWithoutBroadAncestryCategoryInput[] | BroadAncestryInModelUncheckedCreateWithoutBroadAncestryCategoryInput[]
    connectOrCreate?: BroadAncestryInModelCreateOrConnectWithoutBroadAncestryCategoryInput | BroadAncestryInModelCreateOrConnectWithoutBroadAncestryCategoryInput[]
    upsert?: BroadAncestryInModelUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput | BroadAncestryInModelUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput[]
    createMany?: BroadAncestryInModelCreateManyBroadAncestryCategoryInputEnvelope
    set?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
    disconnect?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
    delete?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
    connect?: BroadAncestryInModelWhereUniqueInput | BroadAncestryInModelWhereUniqueInput[]
    update?: BroadAncestryInModelUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput | BroadAncestryInModelUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput[]
    updateMany?: BroadAncestryInModelUpdateManyWithWhereWithoutBroadAncestryCategoryInput | BroadAncestryInModelUpdateManyWithWhereWithoutBroadAncestryCategoryInput[]
    deleteMany?: BroadAncestryInModelScalarWhereInput | BroadAncestryInModelScalarWhereInput[]
  }

  export type BroadAncestryInRefPopUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput = {
    create?: XOR<BroadAncestryInRefPopCreateWithoutBroadAncestryCategoryInput, BroadAncestryInRefPopUncheckedCreateWithoutBroadAncestryCategoryInput> | BroadAncestryInRefPopCreateWithoutBroadAncestryCategoryInput[] | BroadAncestryInRefPopUncheckedCreateWithoutBroadAncestryCategoryInput[]
    connectOrCreate?: BroadAncestryInRefPopCreateOrConnectWithoutBroadAncestryCategoryInput | BroadAncestryInRefPopCreateOrConnectWithoutBroadAncestryCategoryInput[]
    upsert?: BroadAncestryInRefPopUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput | BroadAncestryInRefPopUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput[]
    createMany?: BroadAncestryInRefPopCreateManyBroadAncestryCategoryInputEnvelope
    set?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
    disconnect?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
    delete?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
    connect?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
    update?: BroadAncestryInRefPopUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput | BroadAncestryInRefPopUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput[]
    updateMany?: BroadAncestryInRefPopUpdateManyWithWhereWithoutBroadAncestryCategoryInput | BroadAncestryInRefPopUpdateManyWithWhereWithoutBroadAncestryCategoryInput[]
    deleteMany?: BroadAncestryInRefPopScalarWhereInput | BroadAncestryInRefPopScalarWhereInput[]
  }

  export type DevelopmentPopulationSampleUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput = {
    create?: XOR<DevelopmentPopulationSampleCreateWithoutBroadAncestryCategoryInput, DevelopmentPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput> | DevelopmentPopulationSampleCreateWithoutBroadAncestryCategoryInput[] | DevelopmentPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput[]
    connectOrCreate?: DevelopmentPopulationSampleCreateOrConnectWithoutBroadAncestryCategoryInput | DevelopmentPopulationSampleCreateOrConnectWithoutBroadAncestryCategoryInput[]
    upsert?: DevelopmentPopulationSampleUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput | DevelopmentPopulationSampleUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput[]
    createMany?: DevelopmentPopulationSampleCreateManyBroadAncestryCategoryInputEnvelope
    set?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
    disconnect?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
    delete?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
    connect?: DevelopmentPopulationSampleWhereUniqueInput | DevelopmentPopulationSampleWhereUniqueInput[]
    update?: DevelopmentPopulationSampleUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput | DevelopmentPopulationSampleUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput[]
    updateMany?: DevelopmentPopulationSampleUpdateManyWithWhereWithoutBroadAncestryCategoryInput | DevelopmentPopulationSampleUpdateManyWithWhereWithoutBroadAncestryCategoryInput[]
    deleteMany?: DevelopmentPopulationSampleScalarWhereInput | DevelopmentPopulationSampleScalarWhereInput[]
  }

  export type EvaluationPopulationSampleUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput = {
    create?: XOR<EvaluationPopulationSampleCreateWithoutBroadAncestryCategoryInput, EvaluationPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput> | EvaluationPopulationSampleCreateWithoutBroadAncestryCategoryInput[] | EvaluationPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput[]
    connectOrCreate?: EvaluationPopulationSampleCreateOrConnectWithoutBroadAncestryCategoryInput | EvaluationPopulationSampleCreateOrConnectWithoutBroadAncestryCategoryInput[]
    upsert?: EvaluationPopulationSampleUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput | EvaluationPopulationSampleUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput[]
    createMany?: EvaluationPopulationSampleCreateManyBroadAncestryCategoryInputEnvelope
    set?: EvaluationPopulationSampleWhereUniqueInput | EvaluationPopulationSampleWhereUniqueInput[]
    disconnect?: EvaluationPopulationSampleWhereUniqueInput | EvaluationPopulationSampleWhereUniqueInput[]
    delete?: EvaluationPopulationSampleWhereUniqueInput | EvaluationPopulationSampleWhereUniqueInput[]
    connect?: EvaluationPopulationSampleWhereUniqueInput | EvaluationPopulationSampleWhereUniqueInput[]
    update?: EvaluationPopulationSampleUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput | EvaluationPopulationSampleUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput[]
    updateMany?: EvaluationPopulationSampleUpdateManyWithWhereWithoutBroadAncestryCategoryInput | EvaluationPopulationSampleUpdateManyWithWhereWithoutBroadAncestryCategoryInput[]
    deleteMany?: EvaluationPopulationSampleScalarWhereInput | EvaluationPopulationSampleScalarWhereInput[]
  }

  export type BroadAncestryCategoryCreateNestedOneWithoutBroadAncestryInModelsInput = {
    create?: XOR<BroadAncestryCategoryCreateWithoutBroadAncestryInModelsInput, BroadAncestryCategoryUncheckedCreateWithoutBroadAncestryInModelsInput>
    connectOrCreate?: BroadAncestryCategoryCreateOrConnectWithoutBroadAncestryInModelsInput
    connect?: BroadAncestryCategoryWhereUniqueInput
  }

  export type PRSModelCreateNestedOneWithoutBroadAncestryCategoriesInput = {
    create?: XOR<PRSModelCreateWithoutBroadAncestryCategoriesInput, PRSModelUncheckedCreateWithoutBroadAncestryCategoriesInput>
    connectOrCreate?: PRSModelCreateOrConnectWithoutBroadAncestryCategoriesInput
    connect?: PRSModelWhereUniqueInput
  }

  export type BroadAncestryCategoryUpdateOneRequiredWithoutBroadAncestryInModelsNestedInput = {
    create?: XOR<BroadAncestryCategoryCreateWithoutBroadAncestryInModelsInput, BroadAncestryCategoryUncheckedCreateWithoutBroadAncestryInModelsInput>
    connectOrCreate?: BroadAncestryCategoryCreateOrConnectWithoutBroadAncestryInModelsInput
    upsert?: BroadAncestryCategoryUpsertWithoutBroadAncestryInModelsInput
    connect?: BroadAncestryCategoryWhereUniqueInput
    update?: XOR<XOR<BroadAncestryCategoryUpdateToOneWithWhereWithoutBroadAncestryInModelsInput, BroadAncestryCategoryUpdateWithoutBroadAncestryInModelsInput>, BroadAncestryCategoryUncheckedUpdateWithoutBroadAncestryInModelsInput>
  }

  export type PRSModelUpdateOneRequiredWithoutBroadAncestryCategoriesNestedInput = {
    create?: XOR<PRSModelCreateWithoutBroadAncestryCategoriesInput, PRSModelUncheckedCreateWithoutBroadAncestryCategoriesInput>
    connectOrCreate?: PRSModelCreateOrConnectWithoutBroadAncestryCategoriesInput
    upsert?: PRSModelUpsertWithoutBroadAncestryCategoriesInput
    connect?: PRSModelWhereUniqueInput
    update?: XOR<XOR<PRSModelUpdateToOneWithWhereWithoutBroadAncestryCategoriesInput, PRSModelUpdateWithoutBroadAncestryCategoriesInput>, PRSModelUncheckedUpdateWithoutBroadAncestryCategoriesInput>
  }

  export type BroadAncestryCategoryCreateNestedOneWithoutDevelopmentPopulationSamplesInput = {
    create?: XOR<BroadAncestryCategoryCreateWithoutDevelopmentPopulationSamplesInput, BroadAncestryCategoryUncheckedCreateWithoutDevelopmentPopulationSamplesInput>
    connectOrCreate?: BroadAncestryCategoryCreateOrConnectWithoutDevelopmentPopulationSamplesInput
    connect?: BroadAncestryCategoryWhereUniqueInput
  }

  export type PRSModelCreateNestedOneWithoutDevelopmentPopulationSamplesInput = {
    create?: XOR<PRSModelCreateWithoutDevelopmentPopulationSamplesInput, PRSModelUncheckedCreateWithoutDevelopmentPopulationSamplesInput>
    connectOrCreate?: PRSModelCreateOrConnectWithoutDevelopmentPopulationSamplesInput
    connect?: PRSModelWhereUniqueInput
  }

  export type EnumDevelopmentRoleTypeFieldUpdateOperationsInput = {
    set?: $Enums.DevelopmentRoleType
  }

  export type BroadAncestryCategoryUpdateOneRequiredWithoutDevelopmentPopulationSamplesNestedInput = {
    create?: XOR<BroadAncestryCategoryCreateWithoutDevelopmentPopulationSamplesInput, BroadAncestryCategoryUncheckedCreateWithoutDevelopmentPopulationSamplesInput>
    connectOrCreate?: BroadAncestryCategoryCreateOrConnectWithoutDevelopmentPopulationSamplesInput
    upsert?: BroadAncestryCategoryUpsertWithoutDevelopmentPopulationSamplesInput
    connect?: BroadAncestryCategoryWhereUniqueInput
    update?: XOR<XOR<BroadAncestryCategoryUpdateToOneWithWhereWithoutDevelopmentPopulationSamplesInput, BroadAncestryCategoryUpdateWithoutDevelopmentPopulationSamplesInput>, BroadAncestryCategoryUncheckedUpdateWithoutDevelopmentPopulationSamplesInput>
  }

  export type PRSModelUpdateOneRequiredWithoutDevelopmentPopulationSamplesNestedInput = {
    create?: XOR<PRSModelCreateWithoutDevelopmentPopulationSamplesInput, PRSModelUncheckedCreateWithoutDevelopmentPopulationSamplesInput>
    connectOrCreate?: PRSModelCreateOrConnectWithoutDevelopmentPopulationSamplesInput
    upsert?: PRSModelUpsertWithoutDevelopmentPopulationSamplesInput
    connect?: PRSModelWhereUniqueInput
    update?: XOR<XOR<PRSModelUpdateToOneWithWhereWithoutDevelopmentPopulationSamplesInput, PRSModelUpdateWithoutDevelopmentPopulationSamplesInput>, PRSModelUncheckedUpdateWithoutDevelopmentPopulationSamplesInput>
  }

  export type BroadAncestryCategoryCreateNestedOneWithoutBroadAncestryInRefPopsInput = {
    create?: XOR<BroadAncestryCategoryCreateWithoutBroadAncestryInRefPopsInput, BroadAncestryCategoryUncheckedCreateWithoutBroadAncestryInRefPopsInput>
    connectOrCreate?: BroadAncestryCategoryCreateOrConnectWithoutBroadAncestryInRefPopsInput
    connect?: BroadAncestryCategoryWhereUniqueInput
  }

  export type ReferencePopulationCreateNestedOneWithoutBroadAncestryCategoriesInput = {
    create?: XOR<ReferencePopulationCreateWithoutBroadAncestryCategoriesInput, ReferencePopulationUncheckedCreateWithoutBroadAncestryCategoriesInput>
    connectOrCreate?: ReferencePopulationCreateOrConnectWithoutBroadAncestryCategoriesInput
    connect?: ReferencePopulationWhereUniqueInput
  }

  export type BroadAncestryCategoryUpdateOneRequiredWithoutBroadAncestryInRefPopsNestedInput = {
    create?: XOR<BroadAncestryCategoryCreateWithoutBroadAncestryInRefPopsInput, BroadAncestryCategoryUncheckedCreateWithoutBroadAncestryInRefPopsInput>
    connectOrCreate?: BroadAncestryCategoryCreateOrConnectWithoutBroadAncestryInRefPopsInput
    upsert?: BroadAncestryCategoryUpsertWithoutBroadAncestryInRefPopsInput
    connect?: BroadAncestryCategoryWhereUniqueInput
    update?: XOR<XOR<BroadAncestryCategoryUpdateToOneWithWhereWithoutBroadAncestryInRefPopsInput, BroadAncestryCategoryUpdateWithoutBroadAncestryInRefPopsInput>, BroadAncestryCategoryUncheckedUpdateWithoutBroadAncestryInRefPopsInput>
  }

  export type ReferencePopulationUpdateOneRequiredWithoutBroadAncestryCategoriesNestedInput = {
    create?: XOR<ReferencePopulationCreateWithoutBroadAncestryCategoriesInput, ReferencePopulationUncheckedCreateWithoutBroadAncestryCategoriesInput>
    connectOrCreate?: ReferencePopulationCreateOrConnectWithoutBroadAncestryCategoriesInput
    upsert?: ReferencePopulationUpsertWithoutBroadAncestryCategoriesInput
    connect?: ReferencePopulationWhereUniqueInput
    update?: XOR<XOR<ReferencePopulationUpdateToOneWithWhereWithoutBroadAncestryCategoriesInput, ReferencePopulationUpdateWithoutBroadAncestryCategoriesInput>, ReferencePopulationUncheckedUpdateWithoutBroadAncestryCategoriesInput>
  }

  export type BroadAncestryInRefPopCreateNestedManyWithoutReferencePopulationInput = {
    create?: XOR<BroadAncestryInRefPopCreateWithoutReferencePopulationInput, BroadAncestryInRefPopUncheckedCreateWithoutReferencePopulationInput> | BroadAncestryInRefPopCreateWithoutReferencePopulationInput[] | BroadAncestryInRefPopUncheckedCreateWithoutReferencePopulationInput[]
    connectOrCreate?: BroadAncestryInRefPopCreateOrConnectWithoutReferencePopulationInput | BroadAncestryInRefPopCreateOrConnectWithoutReferencePopulationInput[]
    createMany?: BroadAncestryInRefPopCreateManyReferencePopulationInputEnvelope
    connect?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
  }

  export type PRSAnalysisCreateNestedManyWithoutReferencePopulationInput = {
    create?: XOR<PRSAnalysisCreateWithoutReferencePopulationInput, PRSAnalysisUncheckedCreateWithoutReferencePopulationInput> | PRSAnalysisCreateWithoutReferencePopulationInput[] | PRSAnalysisUncheckedCreateWithoutReferencePopulationInput[]
    connectOrCreate?: PRSAnalysisCreateOrConnectWithoutReferencePopulationInput | PRSAnalysisCreateOrConnectWithoutReferencePopulationInput[]
    createMany?: PRSAnalysisCreateManyReferencePopulationInputEnvelope
    connect?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
  }

  export type BroadAncestryInRefPopUncheckedCreateNestedManyWithoutReferencePopulationInput = {
    create?: XOR<BroadAncestryInRefPopCreateWithoutReferencePopulationInput, BroadAncestryInRefPopUncheckedCreateWithoutReferencePopulationInput> | BroadAncestryInRefPopCreateWithoutReferencePopulationInput[] | BroadAncestryInRefPopUncheckedCreateWithoutReferencePopulationInput[]
    connectOrCreate?: BroadAncestryInRefPopCreateOrConnectWithoutReferencePopulationInput | BroadAncestryInRefPopCreateOrConnectWithoutReferencePopulationInput[]
    createMany?: BroadAncestryInRefPopCreateManyReferencePopulationInputEnvelope
    connect?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
  }

  export type PRSAnalysisUncheckedCreateNestedManyWithoutReferencePopulationInput = {
    create?: XOR<PRSAnalysisCreateWithoutReferencePopulationInput, PRSAnalysisUncheckedCreateWithoutReferencePopulationInput> | PRSAnalysisCreateWithoutReferencePopulationInput[] | PRSAnalysisUncheckedCreateWithoutReferencePopulationInput[]
    connectOrCreate?: PRSAnalysisCreateOrConnectWithoutReferencePopulationInput | PRSAnalysisCreateOrConnectWithoutReferencePopulationInput[]
    createMany?: PRSAnalysisCreateManyReferencePopulationInputEnvelope
    connect?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BroadAncestryInRefPopUpdateManyWithoutReferencePopulationNestedInput = {
    create?: XOR<BroadAncestryInRefPopCreateWithoutReferencePopulationInput, BroadAncestryInRefPopUncheckedCreateWithoutReferencePopulationInput> | BroadAncestryInRefPopCreateWithoutReferencePopulationInput[] | BroadAncestryInRefPopUncheckedCreateWithoutReferencePopulationInput[]
    connectOrCreate?: BroadAncestryInRefPopCreateOrConnectWithoutReferencePopulationInput | BroadAncestryInRefPopCreateOrConnectWithoutReferencePopulationInput[]
    upsert?: BroadAncestryInRefPopUpsertWithWhereUniqueWithoutReferencePopulationInput | BroadAncestryInRefPopUpsertWithWhereUniqueWithoutReferencePopulationInput[]
    createMany?: BroadAncestryInRefPopCreateManyReferencePopulationInputEnvelope
    set?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
    disconnect?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
    delete?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
    connect?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
    update?: BroadAncestryInRefPopUpdateWithWhereUniqueWithoutReferencePopulationInput | BroadAncestryInRefPopUpdateWithWhereUniqueWithoutReferencePopulationInput[]
    updateMany?: BroadAncestryInRefPopUpdateManyWithWhereWithoutReferencePopulationInput | BroadAncestryInRefPopUpdateManyWithWhereWithoutReferencePopulationInput[]
    deleteMany?: BroadAncestryInRefPopScalarWhereInput | BroadAncestryInRefPopScalarWhereInput[]
  }

  export type PRSAnalysisUpdateManyWithoutReferencePopulationNestedInput = {
    create?: XOR<PRSAnalysisCreateWithoutReferencePopulationInput, PRSAnalysisUncheckedCreateWithoutReferencePopulationInput> | PRSAnalysisCreateWithoutReferencePopulationInput[] | PRSAnalysisUncheckedCreateWithoutReferencePopulationInput[]
    connectOrCreate?: PRSAnalysisCreateOrConnectWithoutReferencePopulationInput | PRSAnalysisCreateOrConnectWithoutReferencePopulationInput[]
    upsert?: PRSAnalysisUpsertWithWhereUniqueWithoutReferencePopulationInput | PRSAnalysisUpsertWithWhereUniqueWithoutReferencePopulationInput[]
    createMany?: PRSAnalysisCreateManyReferencePopulationInputEnvelope
    set?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
    disconnect?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
    delete?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
    connect?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
    update?: PRSAnalysisUpdateWithWhereUniqueWithoutReferencePopulationInput | PRSAnalysisUpdateWithWhereUniqueWithoutReferencePopulationInput[]
    updateMany?: PRSAnalysisUpdateManyWithWhereWithoutReferencePopulationInput | PRSAnalysisUpdateManyWithWhereWithoutReferencePopulationInput[]
    deleteMany?: PRSAnalysisScalarWhereInput | PRSAnalysisScalarWhereInput[]
  }

  export type BroadAncestryInRefPopUncheckedUpdateManyWithoutReferencePopulationNestedInput = {
    create?: XOR<BroadAncestryInRefPopCreateWithoutReferencePopulationInput, BroadAncestryInRefPopUncheckedCreateWithoutReferencePopulationInput> | BroadAncestryInRefPopCreateWithoutReferencePopulationInput[] | BroadAncestryInRefPopUncheckedCreateWithoutReferencePopulationInput[]
    connectOrCreate?: BroadAncestryInRefPopCreateOrConnectWithoutReferencePopulationInput | BroadAncestryInRefPopCreateOrConnectWithoutReferencePopulationInput[]
    upsert?: BroadAncestryInRefPopUpsertWithWhereUniqueWithoutReferencePopulationInput | BroadAncestryInRefPopUpsertWithWhereUniqueWithoutReferencePopulationInput[]
    createMany?: BroadAncestryInRefPopCreateManyReferencePopulationInputEnvelope
    set?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
    disconnect?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
    delete?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
    connect?: BroadAncestryInRefPopWhereUniqueInput | BroadAncestryInRefPopWhereUniqueInput[]
    update?: BroadAncestryInRefPopUpdateWithWhereUniqueWithoutReferencePopulationInput | BroadAncestryInRefPopUpdateWithWhereUniqueWithoutReferencePopulationInput[]
    updateMany?: BroadAncestryInRefPopUpdateManyWithWhereWithoutReferencePopulationInput | BroadAncestryInRefPopUpdateManyWithWhereWithoutReferencePopulationInput[]
    deleteMany?: BroadAncestryInRefPopScalarWhereInput | BroadAncestryInRefPopScalarWhereInput[]
  }

  export type PRSAnalysisUncheckedUpdateManyWithoutReferencePopulationNestedInput = {
    create?: XOR<PRSAnalysisCreateWithoutReferencePopulationInput, PRSAnalysisUncheckedCreateWithoutReferencePopulationInput> | PRSAnalysisCreateWithoutReferencePopulationInput[] | PRSAnalysisUncheckedCreateWithoutReferencePopulationInput[]
    connectOrCreate?: PRSAnalysisCreateOrConnectWithoutReferencePopulationInput | PRSAnalysisCreateOrConnectWithoutReferencePopulationInput[]
    upsert?: PRSAnalysisUpsertWithWhereUniqueWithoutReferencePopulationInput | PRSAnalysisUpsertWithWhereUniqueWithoutReferencePopulationInput[]
    createMany?: PRSAnalysisCreateManyReferencePopulationInputEnvelope
    set?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
    disconnect?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
    delete?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
    connect?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
    update?: PRSAnalysisUpdateWithWhereUniqueWithoutReferencePopulationInput | PRSAnalysisUpdateWithWhereUniqueWithoutReferencePopulationInput[]
    updateMany?: PRSAnalysisUpdateManyWithWhereWithoutReferencePopulationInput | PRSAnalysisUpdateManyWithWhereWithoutReferencePopulationInput[]
    deleteMany?: PRSAnalysisScalarWhereInput | PRSAnalysisScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutPrsAnalysesInput = {
    create?: XOR<PatientCreateWithoutPrsAnalysesInput, PatientUncheckedCreateWithoutPrsAnalysesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrsAnalysesInput
    connect?: PatientWhereUniqueInput
  }

  export type ReferencePopulationCreateNestedOneWithoutPrsAnalysesInput = {
    create?: XOR<ReferencePopulationCreateWithoutPrsAnalysesInput, ReferencePopulationUncheckedCreateWithoutPrsAnalysesInput>
    connectOrCreate?: ReferencePopulationCreateOrConnectWithoutPrsAnalysesInput
    connect?: ReferencePopulationWhereUniqueInput
  }

  export type PrioritizedModelCreateNestedManyWithoutPrsAnalysisInput = {
    create?: XOR<PrioritizedModelCreateWithoutPrsAnalysisInput, PrioritizedModelUncheckedCreateWithoutPrsAnalysisInput> | PrioritizedModelCreateWithoutPrsAnalysisInput[] | PrioritizedModelUncheckedCreateWithoutPrsAnalysisInput[]
    connectOrCreate?: PrioritizedModelCreateOrConnectWithoutPrsAnalysisInput | PrioritizedModelCreateOrConnectWithoutPrsAnalysisInput[]
    createMany?: PrioritizedModelCreateManyPrsAnalysisInputEnvelope
    connect?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
  }

  export type PrioritizedModelUncheckedCreateNestedManyWithoutPrsAnalysisInput = {
    create?: XOR<PrioritizedModelCreateWithoutPrsAnalysisInput, PrioritizedModelUncheckedCreateWithoutPrsAnalysisInput> | PrioritizedModelCreateWithoutPrsAnalysisInput[] | PrioritizedModelUncheckedCreateWithoutPrsAnalysisInput[]
    connectOrCreate?: PrioritizedModelCreateOrConnectWithoutPrsAnalysisInput | PrioritizedModelCreateOrConnectWithoutPrsAnalysisInput[]
    createMany?: PrioritizedModelCreateManyPrsAnalysisInputEnvelope
    connect?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
  }

  export type EnumAncestryAdjustmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AncestryAdjustmentType
  }

  export type PatientUpdateOneRequiredWithoutPrsAnalysesNestedInput = {
    create?: XOR<PatientCreateWithoutPrsAnalysesInput, PatientUncheckedCreateWithoutPrsAnalysesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrsAnalysesInput
    upsert?: PatientUpsertWithoutPrsAnalysesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPrsAnalysesInput, PatientUpdateWithoutPrsAnalysesInput>, PatientUncheckedUpdateWithoutPrsAnalysesInput>
  }

  export type ReferencePopulationUpdateOneRequiredWithoutPrsAnalysesNestedInput = {
    create?: XOR<ReferencePopulationCreateWithoutPrsAnalysesInput, ReferencePopulationUncheckedCreateWithoutPrsAnalysesInput>
    connectOrCreate?: ReferencePopulationCreateOrConnectWithoutPrsAnalysesInput
    upsert?: ReferencePopulationUpsertWithoutPrsAnalysesInput
    connect?: ReferencePopulationWhereUniqueInput
    update?: XOR<XOR<ReferencePopulationUpdateToOneWithWhereWithoutPrsAnalysesInput, ReferencePopulationUpdateWithoutPrsAnalysesInput>, ReferencePopulationUncheckedUpdateWithoutPrsAnalysesInput>
  }

  export type PrioritizedModelUpdateManyWithoutPrsAnalysisNestedInput = {
    create?: XOR<PrioritizedModelCreateWithoutPrsAnalysisInput, PrioritizedModelUncheckedCreateWithoutPrsAnalysisInput> | PrioritizedModelCreateWithoutPrsAnalysisInput[] | PrioritizedModelUncheckedCreateWithoutPrsAnalysisInput[]
    connectOrCreate?: PrioritizedModelCreateOrConnectWithoutPrsAnalysisInput | PrioritizedModelCreateOrConnectWithoutPrsAnalysisInput[]
    upsert?: PrioritizedModelUpsertWithWhereUniqueWithoutPrsAnalysisInput | PrioritizedModelUpsertWithWhereUniqueWithoutPrsAnalysisInput[]
    createMany?: PrioritizedModelCreateManyPrsAnalysisInputEnvelope
    set?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
    disconnect?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
    delete?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
    connect?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
    update?: PrioritizedModelUpdateWithWhereUniqueWithoutPrsAnalysisInput | PrioritizedModelUpdateWithWhereUniqueWithoutPrsAnalysisInput[]
    updateMany?: PrioritizedModelUpdateManyWithWhereWithoutPrsAnalysisInput | PrioritizedModelUpdateManyWithWhereWithoutPrsAnalysisInput[]
    deleteMany?: PrioritizedModelScalarWhereInput | PrioritizedModelScalarWhereInput[]
  }

  export type PrioritizedModelUncheckedUpdateManyWithoutPrsAnalysisNestedInput = {
    create?: XOR<PrioritizedModelCreateWithoutPrsAnalysisInput, PrioritizedModelUncheckedCreateWithoutPrsAnalysisInput> | PrioritizedModelCreateWithoutPrsAnalysisInput[] | PrioritizedModelUncheckedCreateWithoutPrsAnalysisInput[]
    connectOrCreate?: PrioritizedModelCreateOrConnectWithoutPrsAnalysisInput | PrioritizedModelCreateOrConnectWithoutPrsAnalysisInput[]
    upsert?: PrioritizedModelUpsertWithWhereUniqueWithoutPrsAnalysisInput | PrioritizedModelUpsertWithWhereUniqueWithoutPrsAnalysisInput[]
    createMany?: PrioritizedModelCreateManyPrsAnalysisInputEnvelope
    set?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
    disconnect?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
    delete?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
    connect?: PrioritizedModelWhereUniqueInput | PrioritizedModelWhereUniqueInput[]
    update?: PrioritizedModelUpdateWithWhereUniqueWithoutPrsAnalysisInput | PrioritizedModelUpdateWithWhereUniqueWithoutPrsAnalysisInput[]
    updateMany?: PrioritizedModelUpdateManyWithWhereWithoutPrsAnalysisInput | PrioritizedModelUpdateManyWithWhereWithoutPrsAnalysisInput[]
    deleteMany?: PrioritizedModelScalarWhereInput | PrioritizedModelScalarWhereInput[]
  }

  export type PRSResultCreateNestedOneWithoutPrioritizedModelInput = {
    create?: XOR<PRSResultCreateWithoutPrioritizedModelInput, PRSResultUncheckedCreateWithoutPrioritizedModelInput>
    connectOrCreate?: PRSResultCreateOrConnectWithoutPrioritizedModelInput
    connect?: PRSResultWhereUniqueInput
  }

  export type PRSAnalysisCreateNestedOneWithoutPrioritizedModelsInput = {
    create?: XOR<PRSAnalysisCreateWithoutPrioritizedModelsInput, PRSAnalysisUncheckedCreateWithoutPrioritizedModelsInput>
    connectOrCreate?: PRSAnalysisCreateOrConnectWithoutPrioritizedModelsInput
    connect?: PRSAnalysisWhereUniqueInput
  }

  export type PRSModelCreateNestedOneWithoutPrioritizedModelsInput = {
    create?: XOR<PRSModelCreateWithoutPrioritizedModelsInput, PRSModelUncheckedCreateWithoutPrioritizedModelsInput>
    connectOrCreate?: PRSModelCreateOrConnectWithoutPrioritizedModelsInput
    connect?: PRSModelWhereUniqueInput
  }

  export type PRSResultUncheckedCreateNestedOneWithoutPrioritizedModelInput = {
    create?: XOR<PRSResultCreateWithoutPrioritizedModelInput, PRSResultUncheckedCreateWithoutPrioritizedModelInput>
    connectOrCreate?: PRSResultCreateOrConnectWithoutPrioritizedModelInput
    connect?: PRSResultWhereUniqueInput
  }

  export type PRSResultUpdateOneWithoutPrioritizedModelNestedInput = {
    create?: XOR<PRSResultCreateWithoutPrioritizedModelInput, PRSResultUncheckedCreateWithoutPrioritizedModelInput>
    connectOrCreate?: PRSResultCreateOrConnectWithoutPrioritizedModelInput
    upsert?: PRSResultUpsertWithoutPrioritizedModelInput
    disconnect?: PRSResultWhereInput | boolean
    delete?: PRSResultWhereInput | boolean
    connect?: PRSResultWhereUniqueInput
    update?: XOR<XOR<PRSResultUpdateToOneWithWhereWithoutPrioritizedModelInput, PRSResultUpdateWithoutPrioritizedModelInput>, PRSResultUncheckedUpdateWithoutPrioritizedModelInput>
  }

  export type PRSAnalysisUpdateOneRequiredWithoutPrioritizedModelsNestedInput = {
    create?: XOR<PRSAnalysisCreateWithoutPrioritizedModelsInput, PRSAnalysisUncheckedCreateWithoutPrioritizedModelsInput>
    connectOrCreate?: PRSAnalysisCreateOrConnectWithoutPrioritizedModelsInput
    upsert?: PRSAnalysisUpsertWithoutPrioritizedModelsInput
    connect?: PRSAnalysisWhereUniqueInput
    update?: XOR<XOR<PRSAnalysisUpdateToOneWithWhereWithoutPrioritizedModelsInput, PRSAnalysisUpdateWithoutPrioritizedModelsInput>, PRSAnalysisUncheckedUpdateWithoutPrioritizedModelsInput>
  }

  export type PRSModelUpdateOneRequiredWithoutPrioritizedModelsNestedInput = {
    create?: XOR<PRSModelCreateWithoutPrioritizedModelsInput, PRSModelUncheckedCreateWithoutPrioritizedModelsInput>
    connectOrCreate?: PRSModelCreateOrConnectWithoutPrioritizedModelsInput
    upsert?: PRSModelUpsertWithoutPrioritizedModelsInput
    connect?: PRSModelWhereUniqueInput
    update?: XOR<XOR<PRSModelUpdateToOneWithWhereWithoutPrioritizedModelsInput, PRSModelUpdateWithoutPrioritizedModelsInput>, PRSModelUncheckedUpdateWithoutPrioritizedModelsInput>
  }

  export type PRSResultUncheckedUpdateOneWithoutPrioritizedModelNestedInput = {
    create?: XOR<PRSResultCreateWithoutPrioritizedModelInput, PRSResultUncheckedCreateWithoutPrioritizedModelInput>
    connectOrCreate?: PRSResultCreateOrConnectWithoutPrioritizedModelInput
    upsert?: PRSResultUpsertWithoutPrioritizedModelInput
    disconnect?: PRSResultWhereInput | boolean
    delete?: PRSResultWhereInput | boolean
    connect?: PRSResultWhereUniqueInput
    update?: XOR<XOR<PRSResultUpdateToOneWithWhereWithoutPrioritizedModelInput, PRSResultUpdateWithoutPrioritizedModelInput>, PRSResultUncheckedUpdateWithoutPrioritizedModelInput>
  }

  export type PrioritizedModelCreateNestedOneWithoutPrsResultInput = {
    create?: XOR<PrioritizedModelCreateWithoutPrsResultInput, PrioritizedModelUncheckedCreateWithoutPrsResultInput>
    connectOrCreate?: PrioritizedModelCreateOrConnectWithoutPrsResultInput
    connect?: PrioritizedModelWhereUniqueInput
  }

  export type PrioritizedModelUpdateOneRequiredWithoutPrsResultNestedInput = {
    create?: XOR<PrioritizedModelCreateWithoutPrsResultInput, PrioritizedModelUncheckedCreateWithoutPrsResultInput>
    connectOrCreate?: PrioritizedModelCreateOrConnectWithoutPrsResultInput
    upsert?: PrioritizedModelUpsertWithoutPrsResultInput
    connect?: PrioritizedModelWhereUniqueInput
    update?: XOR<XOR<PrioritizedModelUpdateToOneWithWhereWithoutPrsResultInput, PrioritizedModelUpdateWithoutPrsResultInput>, PrioritizedModelUncheckedUpdateWithoutPrsResultInput>
  }

  export type PRSAnalysisCreateNestedManyWithoutPatientInput = {
    create?: XOR<PRSAnalysisCreateWithoutPatientInput, PRSAnalysisUncheckedCreateWithoutPatientInput> | PRSAnalysisCreateWithoutPatientInput[] | PRSAnalysisUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PRSAnalysisCreateOrConnectWithoutPatientInput | PRSAnalysisCreateOrConnectWithoutPatientInput[]
    createMany?: PRSAnalysisCreateManyPatientInputEnvelope
    connect?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
  }

  export type PRSAnalysisUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PRSAnalysisCreateWithoutPatientInput, PRSAnalysisUncheckedCreateWithoutPatientInput> | PRSAnalysisCreateWithoutPatientInput[] | PRSAnalysisUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PRSAnalysisCreateOrConnectWithoutPatientInput | PRSAnalysisCreateOrConnectWithoutPatientInput[]
    createMany?: PRSAnalysisCreateManyPatientInputEnvelope
    connect?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
  }

  export type PRSAnalysisUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PRSAnalysisCreateWithoutPatientInput, PRSAnalysisUncheckedCreateWithoutPatientInput> | PRSAnalysisCreateWithoutPatientInput[] | PRSAnalysisUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PRSAnalysisCreateOrConnectWithoutPatientInput | PRSAnalysisCreateOrConnectWithoutPatientInput[]
    upsert?: PRSAnalysisUpsertWithWhereUniqueWithoutPatientInput | PRSAnalysisUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PRSAnalysisCreateManyPatientInputEnvelope
    set?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
    disconnect?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
    delete?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
    connect?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
    update?: PRSAnalysisUpdateWithWhereUniqueWithoutPatientInput | PRSAnalysisUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PRSAnalysisUpdateManyWithWhereWithoutPatientInput | PRSAnalysisUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PRSAnalysisScalarWhereInput | PRSAnalysisScalarWhereInput[]
  }

  export type PRSAnalysisUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PRSAnalysisCreateWithoutPatientInput, PRSAnalysisUncheckedCreateWithoutPatientInput> | PRSAnalysisCreateWithoutPatientInput[] | PRSAnalysisUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PRSAnalysisCreateOrConnectWithoutPatientInput | PRSAnalysisCreateOrConnectWithoutPatientInput[]
    upsert?: PRSAnalysisUpsertWithWhereUniqueWithoutPatientInput | PRSAnalysisUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PRSAnalysisCreateManyPatientInputEnvelope
    set?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
    disconnect?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
    delete?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
    connect?: PRSAnalysisWhereUniqueInput | PRSAnalysisWhereUniqueInput[]
    update?: PRSAnalysisUpdateWithWhereUniqueWithoutPatientInput | PRSAnalysisUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PRSAnalysisUpdateManyWithWhereWithoutPatientInput | PRSAnalysisUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PRSAnalysisScalarWhereInput | PRSAnalysisScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAssemblyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AssemblyType | EnumAssemblyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssemblyType[]
    notIn?: $Enums.AssemblyType[]
    not?: NestedEnumAssemblyTypeFilter<$PrismaModel> | $Enums.AssemblyType
  }

  export type NestedEnumAssemblyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssemblyType | EnumAssemblyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssemblyType[]
    notIn?: $Enums.AssemblyType[]
    not?: NestedEnumAssemblyTypeWithAggregatesFilter<$PrismaModel> | $Enums.AssemblyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssemblyTypeFilter<$PrismaModel>
    _max?: NestedEnumAssemblyTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumPerformanceMetricTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PerformanceMetricType | EnumPerformanceMetricTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PerformanceMetricType[]
    notIn?: $Enums.PerformanceMetricType[]
    not?: NestedEnumPerformanceMetricTypeFilter<$PrismaModel> | $Enums.PerformanceMetricType
  }

  export type NestedEnumPerformanceMetricTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PerformanceMetricType | EnumPerformanceMetricTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PerformanceMetricType[]
    notIn?: $Enums.PerformanceMetricType[]
    not?: NestedEnumPerformanceMetricTypeWithAggregatesFilter<$PrismaModel> | $Enums.PerformanceMetricType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPerformanceMetricTypeFilter<$PrismaModel>
    _max?: NestedEnumPerformanceMetricTypeFilter<$PrismaModel>
  }

  export type NestedEnumDevelopmentRoleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DevelopmentRoleType | EnumDevelopmentRoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DevelopmentRoleType[]
    notIn?: $Enums.DevelopmentRoleType[]
    not?: NestedEnumDevelopmentRoleTypeFilter<$PrismaModel> | $Enums.DevelopmentRoleType
  }

  export type NestedEnumDevelopmentRoleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DevelopmentRoleType | EnumDevelopmentRoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DevelopmentRoleType[]
    notIn?: $Enums.DevelopmentRoleType[]
    not?: NestedEnumDevelopmentRoleTypeWithAggregatesFilter<$PrismaModel> | $Enums.DevelopmentRoleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDevelopmentRoleTypeFilter<$PrismaModel>
    _max?: NestedEnumDevelopmentRoleTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumAncestryAdjustmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AncestryAdjustmentType | EnumAncestryAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AncestryAdjustmentType[]
    notIn?: $Enums.AncestryAdjustmentType[]
    not?: NestedEnumAncestryAdjustmentTypeFilter<$PrismaModel> | $Enums.AncestryAdjustmentType
  }

  export type NestedEnumAncestryAdjustmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AncestryAdjustmentType | EnumAncestryAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AncestryAdjustmentType[]
    notIn?: $Enums.AncestryAdjustmentType[]
    not?: NestedEnumAncestryAdjustmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AncestryAdjustmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAncestryAdjustmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAncestryAdjustmentTypeFilter<$PrismaModel>
  }

  export type TraitToTraitCategoryCreateWithoutTraitCategoryInput = {
    trait: TraitCreateNestedOneWithoutCategoriesInput
  }

  export type TraitToTraitCategoryUncheckedCreateWithoutTraitCategoryInput = {
    traitId: number
  }

  export type TraitToTraitCategoryCreateOrConnectWithoutTraitCategoryInput = {
    where: TraitToTraitCategoryWhereUniqueInput
    create: XOR<TraitToTraitCategoryCreateWithoutTraitCategoryInput, TraitToTraitCategoryUncheckedCreateWithoutTraitCategoryInput>
  }

  export type TraitToTraitCategoryCreateManyTraitCategoryInputEnvelope = {
    data: TraitToTraitCategoryCreateManyTraitCategoryInput | TraitToTraitCategoryCreateManyTraitCategoryInput[]
    skipDuplicates?: boolean
  }

  export type TraitToTraitCategoryUpsertWithWhereUniqueWithoutTraitCategoryInput = {
    where: TraitToTraitCategoryWhereUniqueInput
    update: XOR<TraitToTraitCategoryUpdateWithoutTraitCategoryInput, TraitToTraitCategoryUncheckedUpdateWithoutTraitCategoryInput>
    create: XOR<TraitToTraitCategoryCreateWithoutTraitCategoryInput, TraitToTraitCategoryUncheckedCreateWithoutTraitCategoryInput>
  }

  export type TraitToTraitCategoryUpdateWithWhereUniqueWithoutTraitCategoryInput = {
    where: TraitToTraitCategoryWhereUniqueInput
    data: XOR<TraitToTraitCategoryUpdateWithoutTraitCategoryInput, TraitToTraitCategoryUncheckedUpdateWithoutTraitCategoryInput>
  }

  export type TraitToTraitCategoryUpdateManyWithWhereWithoutTraitCategoryInput = {
    where: TraitToTraitCategoryScalarWhereInput
    data: XOR<TraitToTraitCategoryUpdateManyMutationInput, TraitToTraitCategoryUncheckedUpdateManyWithoutTraitCategoryInput>
  }

  export type TraitToTraitCategoryScalarWhereInput = {
    AND?: TraitToTraitCategoryScalarWhereInput | TraitToTraitCategoryScalarWhereInput[]
    OR?: TraitToTraitCategoryScalarWhereInput[]
    NOT?: TraitToTraitCategoryScalarWhereInput | TraitToTraitCategoryScalarWhereInput[]
    traitId?: IntFilter<"TraitToTraitCategory"> | number
    traitCategoryId?: IntFilter<"TraitToTraitCategory"> | number
  }

  export type PRSModelToTraitCreateWithoutTraitInput = {
    prsModel: PRSModelCreateNestedOneWithoutTraitsInput
  }

  export type PRSModelToTraitUncheckedCreateWithoutTraitInput = {
    prsModelId: number
  }

  export type PRSModelToTraitCreateOrConnectWithoutTraitInput = {
    where: PRSModelToTraitWhereUniqueInput
    create: XOR<PRSModelToTraitCreateWithoutTraitInput, PRSModelToTraitUncheckedCreateWithoutTraitInput>
  }

  export type PRSModelToTraitCreateManyTraitInputEnvelope = {
    data: PRSModelToTraitCreateManyTraitInput | PRSModelToTraitCreateManyTraitInput[]
    skipDuplicates?: boolean
  }

  export type TraitToTraitCategoryCreateWithoutTraitInput = {
    traitCategory: TraitCategoryCreateNestedOneWithoutTraitsInput
  }

  export type TraitToTraitCategoryUncheckedCreateWithoutTraitInput = {
    traitCategoryId: number
  }

  export type TraitToTraitCategoryCreateOrConnectWithoutTraitInput = {
    where: TraitToTraitCategoryWhereUniqueInput
    create: XOR<TraitToTraitCategoryCreateWithoutTraitInput, TraitToTraitCategoryUncheckedCreateWithoutTraitInput>
  }

  export type TraitToTraitCategoryCreateManyTraitInputEnvelope = {
    data: TraitToTraitCategoryCreateManyTraitInput | TraitToTraitCategoryCreateManyTraitInput[]
    skipDuplicates?: boolean
  }

  export type PRSModelToTraitUpsertWithWhereUniqueWithoutTraitInput = {
    where: PRSModelToTraitWhereUniqueInput
    update: XOR<PRSModelToTraitUpdateWithoutTraitInput, PRSModelToTraitUncheckedUpdateWithoutTraitInput>
    create: XOR<PRSModelToTraitCreateWithoutTraitInput, PRSModelToTraitUncheckedCreateWithoutTraitInput>
  }

  export type PRSModelToTraitUpdateWithWhereUniqueWithoutTraitInput = {
    where: PRSModelToTraitWhereUniqueInput
    data: XOR<PRSModelToTraitUpdateWithoutTraitInput, PRSModelToTraitUncheckedUpdateWithoutTraitInput>
  }

  export type PRSModelToTraitUpdateManyWithWhereWithoutTraitInput = {
    where: PRSModelToTraitScalarWhereInput
    data: XOR<PRSModelToTraitUpdateManyMutationInput, PRSModelToTraitUncheckedUpdateManyWithoutTraitInput>
  }

  export type PRSModelToTraitScalarWhereInput = {
    AND?: PRSModelToTraitScalarWhereInput | PRSModelToTraitScalarWhereInput[]
    OR?: PRSModelToTraitScalarWhereInput[]
    NOT?: PRSModelToTraitScalarWhereInput | PRSModelToTraitScalarWhereInput[]
    prsModelId?: IntFilter<"PRSModelToTrait"> | number
    traitId?: IntFilter<"PRSModelToTrait"> | number
  }

  export type TraitToTraitCategoryUpsertWithWhereUniqueWithoutTraitInput = {
    where: TraitToTraitCategoryWhereUniqueInput
    update: XOR<TraitToTraitCategoryUpdateWithoutTraitInput, TraitToTraitCategoryUncheckedUpdateWithoutTraitInput>
    create: XOR<TraitToTraitCategoryCreateWithoutTraitInput, TraitToTraitCategoryUncheckedCreateWithoutTraitInput>
  }

  export type TraitToTraitCategoryUpdateWithWhereUniqueWithoutTraitInput = {
    where: TraitToTraitCategoryWhereUniqueInput
    data: XOR<TraitToTraitCategoryUpdateWithoutTraitInput, TraitToTraitCategoryUncheckedUpdateWithoutTraitInput>
  }

  export type TraitToTraitCategoryUpdateManyWithWhereWithoutTraitInput = {
    where: TraitToTraitCategoryScalarWhereInput
    data: XOR<TraitToTraitCategoryUpdateManyMutationInput, TraitToTraitCategoryUncheckedUpdateManyWithoutTraitInput>
  }

  export type TraitCategoryCreateWithoutTraitsInput = {
    label: string
  }

  export type TraitCategoryUncheckedCreateWithoutTraitsInput = {
    id?: number
    label: string
  }

  export type TraitCategoryCreateOrConnectWithoutTraitsInput = {
    where: TraitCategoryWhereUniqueInput
    create: XOR<TraitCategoryCreateWithoutTraitsInput, TraitCategoryUncheckedCreateWithoutTraitsInput>
  }

  export type TraitCreateWithoutCategoriesInput = {
    label: string
    description?: string | null
    URL?: string | null
    efoId?: string | null
    mondoId?: string | null
    hpoId?: string | null
    orphaId?: string | null
    otherId?: string | null
    prsModels?: PRSModelToTraitCreateNestedManyWithoutTraitInput
  }

  export type TraitUncheckedCreateWithoutCategoriesInput = {
    id?: number
    label: string
    description?: string | null
    URL?: string | null
    efoId?: string | null
    mondoId?: string | null
    hpoId?: string | null
    orphaId?: string | null
    otherId?: string | null
    prsModels?: PRSModelToTraitUncheckedCreateNestedManyWithoutTraitInput
  }

  export type TraitCreateOrConnectWithoutCategoriesInput = {
    where: TraitWhereUniqueInput
    create: XOR<TraitCreateWithoutCategoriesInput, TraitUncheckedCreateWithoutCategoriesInput>
  }

  export type TraitCategoryUpsertWithoutTraitsInput = {
    update: XOR<TraitCategoryUpdateWithoutTraitsInput, TraitCategoryUncheckedUpdateWithoutTraitsInput>
    create: XOR<TraitCategoryCreateWithoutTraitsInput, TraitCategoryUncheckedCreateWithoutTraitsInput>
    where?: TraitCategoryWhereInput
  }

  export type TraitCategoryUpdateToOneWithWhereWithoutTraitsInput = {
    where?: TraitCategoryWhereInput
    data: XOR<TraitCategoryUpdateWithoutTraitsInput, TraitCategoryUncheckedUpdateWithoutTraitsInput>
  }

  export type TraitCategoryUpdateWithoutTraitsInput = {
    label?: StringFieldUpdateOperationsInput | string
  }

  export type TraitCategoryUncheckedUpdateWithoutTraitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
  }

  export type TraitUpsertWithoutCategoriesInput = {
    update: XOR<TraitUpdateWithoutCategoriesInput, TraitUncheckedUpdateWithoutCategoriesInput>
    create: XOR<TraitCreateWithoutCategoriesInput, TraitUncheckedCreateWithoutCategoriesInput>
    where?: TraitWhereInput
  }

  export type TraitUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: TraitWhereInput
    data: XOR<TraitUpdateWithoutCategoriesInput, TraitUncheckedUpdateWithoutCategoriesInput>
  }

  export type TraitUpdateWithoutCategoriesInput = {
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    efoId?: NullableStringFieldUpdateOperationsInput | string | null
    mondoId?: NullableStringFieldUpdateOperationsInput | string | null
    hpoId?: NullableStringFieldUpdateOperationsInput | string | null
    orphaId?: NullableStringFieldUpdateOperationsInput | string | null
    otherId?: NullableStringFieldUpdateOperationsInput | string | null
    prsModels?: PRSModelToTraitUpdateManyWithoutTraitNestedInput
  }

  export type TraitUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    efoId?: NullableStringFieldUpdateOperationsInput | string | null
    mondoId?: NullableStringFieldUpdateOperationsInput | string | null
    hpoId?: NullableStringFieldUpdateOperationsInput | string | null
    orphaId?: NullableStringFieldUpdateOperationsInput | string | null
    otherId?: NullableStringFieldUpdateOperationsInput | string | null
    prsModels?: PRSModelToTraitUncheckedUpdateManyWithoutTraitNestedInput
  }

  export type BroadAncestryInModelCreateWithoutPrsModelInput = {
    percentage: number
    broadAncestryCategory: BroadAncestryCategoryCreateNestedOneWithoutBroadAncestryInModelsInput
  }

  export type BroadAncestryInModelUncheckedCreateWithoutPrsModelInput = {
    percentage: number
    broadAncestryId: number
  }

  export type BroadAncestryInModelCreateOrConnectWithoutPrsModelInput = {
    where: BroadAncestryInModelWhereUniqueInput
    create: XOR<BroadAncestryInModelCreateWithoutPrsModelInput, BroadAncestryInModelUncheckedCreateWithoutPrsModelInput>
  }

  export type BroadAncestryInModelCreateManyPrsModelInputEnvelope = {
    data: BroadAncestryInModelCreateManyPrsModelInput | BroadAncestryInModelCreateManyPrsModelInput[]
    skipDuplicates?: boolean
  }

  export type DevelopmentPopulationSampleCreateWithoutPrsModelInput = {
    numberOfIndividuals?: number | null
    numberOfCases?: number | null
    numberOfControls?: number | null
    percentMale?: number | null
    age?: number | null
    ageUnits?: string | null
    ancestryBroad: string
    ancestryDetails?: string | null
    cohort: string
    gcId?: string | null
    sourcePMID?: string | null
    sourceDOI?: string | null
    role: $Enums.DevelopmentRoleType
    broadAncestryCategory: BroadAncestryCategoryCreateNestedOneWithoutDevelopmentPopulationSamplesInput
  }

  export type DevelopmentPopulationSampleUncheckedCreateWithoutPrsModelInput = {
    id?: number
    numberOfIndividuals?: number | null
    numberOfCases?: number | null
    numberOfControls?: number | null
    percentMale?: number | null
    age?: number | null
    ageUnits?: string | null
    ancestryBroad: string
    ancestryDetails?: string | null
    cohort: string
    gcId?: string | null
    sourcePMID?: string | null
    sourceDOI?: string | null
    role: $Enums.DevelopmentRoleType
    broadAncestryId: number
  }

  export type DevelopmentPopulationSampleCreateOrConnectWithoutPrsModelInput = {
    where: DevelopmentPopulationSampleWhereUniqueInput
    create: XOR<DevelopmentPopulationSampleCreateWithoutPrsModelInput, DevelopmentPopulationSampleUncheckedCreateWithoutPrsModelInput>
  }

  export type DevelopmentPopulationSampleCreateManyPrsModelInputEnvelope = {
    data: DevelopmentPopulationSampleCreateManyPrsModelInput | DevelopmentPopulationSampleCreateManyPrsModelInput[]
    skipDuplicates?: boolean
  }

  export type ModelEvaluationCreateWithoutPrsModelInput = {
    reportedTrait: string
    covariates?: string | null
    ppmId?: string | null
    evaluationPopulationSample: EvaluationPopulationSampleCreateNestedOneWithoutModelEvaluationsInput
    publication: PublicationCreateNestedOneWithoutModelEvaluationsInput
    metricEvaluations?: PerformanceMetricEvaluationCreateNestedManyWithoutModelEvaluationInput
  }

  export type ModelEvaluationUncheckedCreateWithoutPrsModelInput = {
    id?: number
    reportedTrait: string
    covariates?: string | null
    ppmId?: string | null
    publicationId: number
    evaluationPopulationSampleId: number
    metricEvaluations?: PerformanceMetricEvaluationUncheckedCreateNestedManyWithoutModelEvaluationInput
  }

  export type ModelEvaluationCreateOrConnectWithoutPrsModelInput = {
    where: ModelEvaluationWhereUniqueInput
    create: XOR<ModelEvaluationCreateWithoutPrsModelInput, ModelEvaluationUncheckedCreateWithoutPrsModelInput>
  }

  export type ModelEvaluationCreateManyPrsModelInputEnvelope = {
    data: ModelEvaluationCreateManyPrsModelInput | ModelEvaluationCreateManyPrsModelInput[]
    skipDuplicates?: boolean
  }

  export type PublicationCreateWithoutPrsModelsInput = {
    title: string
    journal: string
    author: string
    date?: Date | string | null
    year: number
    PMID?: string | null
    DOI?: string | null
    pgpId?: string | null
    modelEvaluations?: ModelEvaluationCreateNestedManyWithoutPublicationInput
  }

  export type PublicationUncheckedCreateWithoutPrsModelsInput = {
    id?: number
    title: string
    journal: string
    author: string
    date?: Date | string | null
    year: number
    PMID?: string | null
    DOI?: string | null
    pgpId?: string | null
    modelEvaluations?: ModelEvaluationUncheckedCreateNestedManyWithoutPublicationInput
  }

  export type PublicationCreateOrConnectWithoutPrsModelsInput = {
    where: PublicationWhereUniqueInput
    create: XOR<PublicationCreateWithoutPrsModelsInput, PublicationUncheckedCreateWithoutPrsModelsInput>
  }

  export type PRSModelToTraitCreateWithoutPrsModelInput = {
    trait: TraitCreateNestedOneWithoutPrsModelsInput
  }

  export type PRSModelToTraitUncheckedCreateWithoutPrsModelInput = {
    traitId: number
  }

  export type PRSModelToTraitCreateOrConnectWithoutPrsModelInput = {
    where: PRSModelToTraitWhereUniqueInput
    create: XOR<PRSModelToTraitCreateWithoutPrsModelInput, PRSModelToTraitUncheckedCreateWithoutPrsModelInput>
  }

  export type PRSModelToTraitCreateManyPrsModelInputEnvelope = {
    data: PRSModelToTraitCreateManyPrsModelInput | PRSModelToTraitCreateManyPrsModelInput[]
    skipDuplicates?: boolean
  }

  export type PrioritizedModelCreateWithoutPrsModelInput = {
    position: number
    prsResultId?: number | null
    prsResult?: PRSResultCreateNestedOneWithoutPrioritizedModelInput
    prsAnalysis: PRSAnalysisCreateNestedOneWithoutPrioritizedModelsInput
  }

  export type PrioritizedModelUncheckedCreateWithoutPrsModelInput = {
    position: number
    prsAnalysisId: number
    prsResultId?: number | null
    prsResult?: PRSResultUncheckedCreateNestedOneWithoutPrioritizedModelInput
  }

  export type PrioritizedModelCreateOrConnectWithoutPrsModelInput = {
    where: PrioritizedModelWhereUniqueInput
    create: XOR<PrioritizedModelCreateWithoutPrsModelInput, PrioritizedModelUncheckedCreateWithoutPrsModelInput>
  }

  export type PrioritizedModelCreateManyPrsModelInputEnvelope = {
    data: PrioritizedModelCreateManyPrsModelInput | PrioritizedModelCreateManyPrsModelInput[]
    skipDuplicates?: boolean
  }

  export type ScoringFileCreateWithoutPrsModelInput = {
    assembly: $Enums.AssemblyType
    path: string
  }

  export type ScoringFileUncheckedCreateWithoutPrsModelInput = {
    id?: number
    assembly: $Enums.AssemblyType
    path: string
  }

  export type ScoringFileCreateOrConnectWithoutPrsModelInput = {
    where: ScoringFileWhereUniqueInput
    create: XOR<ScoringFileCreateWithoutPrsModelInput, ScoringFileUncheckedCreateWithoutPrsModelInput>
  }

  export type BroadAncestryInModelUpsertWithWhereUniqueWithoutPrsModelInput = {
    where: BroadAncestryInModelWhereUniqueInput
    update: XOR<BroadAncestryInModelUpdateWithoutPrsModelInput, BroadAncestryInModelUncheckedUpdateWithoutPrsModelInput>
    create: XOR<BroadAncestryInModelCreateWithoutPrsModelInput, BroadAncestryInModelUncheckedCreateWithoutPrsModelInput>
  }

  export type BroadAncestryInModelUpdateWithWhereUniqueWithoutPrsModelInput = {
    where: BroadAncestryInModelWhereUniqueInput
    data: XOR<BroadAncestryInModelUpdateWithoutPrsModelInput, BroadAncestryInModelUncheckedUpdateWithoutPrsModelInput>
  }

  export type BroadAncestryInModelUpdateManyWithWhereWithoutPrsModelInput = {
    where: BroadAncestryInModelScalarWhereInput
    data: XOR<BroadAncestryInModelUpdateManyMutationInput, BroadAncestryInModelUncheckedUpdateManyWithoutPrsModelInput>
  }

  export type BroadAncestryInModelScalarWhereInput = {
    AND?: BroadAncestryInModelScalarWhereInput | BroadAncestryInModelScalarWhereInput[]
    OR?: BroadAncestryInModelScalarWhereInput[]
    NOT?: BroadAncestryInModelScalarWhereInput | BroadAncestryInModelScalarWhereInput[]
    percentage?: FloatFilter<"BroadAncestryInModel"> | number
    broadAncestryId?: IntFilter<"BroadAncestryInModel"> | number
    prsModelId?: IntFilter<"BroadAncestryInModel"> | number
  }

  export type DevelopmentPopulationSampleUpsertWithWhereUniqueWithoutPrsModelInput = {
    where: DevelopmentPopulationSampleWhereUniqueInput
    update: XOR<DevelopmentPopulationSampleUpdateWithoutPrsModelInput, DevelopmentPopulationSampleUncheckedUpdateWithoutPrsModelInput>
    create: XOR<DevelopmentPopulationSampleCreateWithoutPrsModelInput, DevelopmentPopulationSampleUncheckedCreateWithoutPrsModelInput>
  }

  export type DevelopmentPopulationSampleUpdateWithWhereUniqueWithoutPrsModelInput = {
    where: DevelopmentPopulationSampleWhereUniqueInput
    data: XOR<DevelopmentPopulationSampleUpdateWithoutPrsModelInput, DevelopmentPopulationSampleUncheckedUpdateWithoutPrsModelInput>
  }

  export type DevelopmentPopulationSampleUpdateManyWithWhereWithoutPrsModelInput = {
    where: DevelopmentPopulationSampleScalarWhereInput
    data: XOR<DevelopmentPopulationSampleUpdateManyMutationInput, DevelopmentPopulationSampleUncheckedUpdateManyWithoutPrsModelInput>
  }

  export type DevelopmentPopulationSampleScalarWhereInput = {
    AND?: DevelopmentPopulationSampleScalarWhereInput | DevelopmentPopulationSampleScalarWhereInput[]
    OR?: DevelopmentPopulationSampleScalarWhereInput[]
    NOT?: DevelopmentPopulationSampleScalarWhereInput | DevelopmentPopulationSampleScalarWhereInput[]
    id?: IntFilter<"DevelopmentPopulationSample"> | number
    numberOfIndividuals?: IntNullableFilter<"DevelopmentPopulationSample"> | number | null
    numberOfCases?: IntNullableFilter<"DevelopmentPopulationSample"> | number | null
    numberOfControls?: IntNullableFilter<"DevelopmentPopulationSample"> | number | null
    percentMale?: FloatNullableFilter<"DevelopmentPopulationSample"> | number | null
    age?: FloatNullableFilter<"DevelopmentPopulationSample"> | number | null
    ageUnits?: StringNullableFilter<"DevelopmentPopulationSample"> | string | null
    ancestryBroad?: StringFilter<"DevelopmentPopulationSample"> | string
    ancestryDetails?: StringNullableFilter<"DevelopmentPopulationSample"> | string | null
    cohort?: StringFilter<"DevelopmentPopulationSample"> | string
    gcId?: StringNullableFilter<"DevelopmentPopulationSample"> | string | null
    sourcePMID?: StringNullableFilter<"DevelopmentPopulationSample"> | string | null
    sourceDOI?: StringNullableFilter<"DevelopmentPopulationSample"> | string | null
    role?: EnumDevelopmentRoleTypeFilter<"DevelopmentPopulationSample"> | $Enums.DevelopmentRoleType
    prsModelId?: IntFilter<"DevelopmentPopulationSample"> | number
    broadAncestryId?: IntFilter<"DevelopmentPopulationSample"> | number
  }

  export type ModelEvaluationUpsertWithWhereUniqueWithoutPrsModelInput = {
    where: ModelEvaluationWhereUniqueInput
    update: XOR<ModelEvaluationUpdateWithoutPrsModelInput, ModelEvaluationUncheckedUpdateWithoutPrsModelInput>
    create: XOR<ModelEvaluationCreateWithoutPrsModelInput, ModelEvaluationUncheckedCreateWithoutPrsModelInput>
  }

  export type ModelEvaluationUpdateWithWhereUniqueWithoutPrsModelInput = {
    where: ModelEvaluationWhereUniqueInput
    data: XOR<ModelEvaluationUpdateWithoutPrsModelInput, ModelEvaluationUncheckedUpdateWithoutPrsModelInput>
  }

  export type ModelEvaluationUpdateManyWithWhereWithoutPrsModelInput = {
    where: ModelEvaluationScalarWhereInput
    data: XOR<ModelEvaluationUpdateManyMutationInput, ModelEvaluationUncheckedUpdateManyWithoutPrsModelInput>
  }

  export type ModelEvaluationScalarWhereInput = {
    AND?: ModelEvaluationScalarWhereInput | ModelEvaluationScalarWhereInput[]
    OR?: ModelEvaluationScalarWhereInput[]
    NOT?: ModelEvaluationScalarWhereInput | ModelEvaluationScalarWhereInput[]
    id?: IntFilter<"ModelEvaluation"> | number
    reportedTrait?: StringFilter<"ModelEvaluation"> | string
    covariates?: StringNullableFilter<"ModelEvaluation"> | string | null
    ppmId?: StringNullableFilter<"ModelEvaluation"> | string | null
    prsModelId?: IntFilter<"ModelEvaluation"> | number
    publicationId?: IntFilter<"ModelEvaluation"> | number
    evaluationPopulationSampleId?: IntFilter<"ModelEvaluation"> | number
  }

  export type PublicationUpsertWithoutPrsModelsInput = {
    update: XOR<PublicationUpdateWithoutPrsModelsInput, PublicationUncheckedUpdateWithoutPrsModelsInput>
    create: XOR<PublicationCreateWithoutPrsModelsInput, PublicationUncheckedCreateWithoutPrsModelsInput>
    where?: PublicationWhereInput
  }

  export type PublicationUpdateToOneWithWhereWithoutPrsModelsInput = {
    where?: PublicationWhereInput
    data: XOR<PublicationUpdateWithoutPrsModelsInput, PublicationUncheckedUpdateWithoutPrsModelsInput>
  }

  export type PublicationUpdateWithoutPrsModelsInput = {
    title?: StringFieldUpdateOperationsInput | string
    journal?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    year?: IntFieldUpdateOperationsInput | number
    PMID?: NullableStringFieldUpdateOperationsInput | string | null
    DOI?: NullableStringFieldUpdateOperationsInput | string | null
    pgpId?: NullableStringFieldUpdateOperationsInput | string | null
    modelEvaluations?: ModelEvaluationUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationUncheckedUpdateWithoutPrsModelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    journal?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    year?: IntFieldUpdateOperationsInput | number
    PMID?: NullableStringFieldUpdateOperationsInput | string | null
    DOI?: NullableStringFieldUpdateOperationsInput | string | null
    pgpId?: NullableStringFieldUpdateOperationsInput | string | null
    modelEvaluations?: ModelEvaluationUncheckedUpdateManyWithoutPublicationNestedInput
  }

  export type PRSModelToTraitUpsertWithWhereUniqueWithoutPrsModelInput = {
    where: PRSModelToTraitWhereUniqueInput
    update: XOR<PRSModelToTraitUpdateWithoutPrsModelInput, PRSModelToTraitUncheckedUpdateWithoutPrsModelInput>
    create: XOR<PRSModelToTraitCreateWithoutPrsModelInput, PRSModelToTraitUncheckedCreateWithoutPrsModelInput>
  }

  export type PRSModelToTraitUpdateWithWhereUniqueWithoutPrsModelInput = {
    where: PRSModelToTraitWhereUniqueInput
    data: XOR<PRSModelToTraitUpdateWithoutPrsModelInput, PRSModelToTraitUncheckedUpdateWithoutPrsModelInput>
  }

  export type PRSModelToTraitUpdateManyWithWhereWithoutPrsModelInput = {
    where: PRSModelToTraitScalarWhereInput
    data: XOR<PRSModelToTraitUpdateManyMutationInput, PRSModelToTraitUncheckedUpdateManyWithoutPrsModelInput>
  }

  export type PrioritizedModelUpsertWithWhereUniqueWithoutPrsModelInput = {
    where: PrioritizedModelWhereUniqueInput
    update: XOR<PrioritizedModelUpdateWithoutPrsModelInput, PrioritizedModelUncheckedUpdateWithoutPrsModelInput>
    create: XOR<PrioritizedModelCreateWithoutPrsModelInput, PrioritizedModelUncheckedCreateWithoutPrsModelInput>
  }

  export type PrioritizedModelUpdateWithWhereUniqueWithoutPrsModelInput = {
    where: PrioritizedModelWhereUniqueInput
    data: XOR<PrioritizedModelUpdateWithoutPrsModelInput, PrioritizedModelUncheckedUpdateWithoutPrsModelInput>
  }

  export type PrioritizedModelUpdateManyWithWhereWithoutPrsModelInput = {
    where: PrioritizedModelScalarWhereInput
    data: XOR<PrioritizedModelUpdateManyMutationInput, PrioritizedModelUncheckedUpdateManyWithoutPrsModelInput>
  }

  export type PrioritizedModelScalarWhereInput = {
    AND?: PrioritizedModelScalarWhereInput | PrioritizedModelScalarWhereInput[]
    OR?: PrioritizedModelScalarWhereInput[]
    NOT?: PrioritizedModelScalarWhereInput | PrioritizedModelScalarWhereInput[]
    position?: IntFilter<"PrioritizedModel"> | number
    prsModelId?: IntFilter<"PrioritizedModel"> | number
    prsAnalysisId?: IntFilter<"PrioritizedModel"> | number
    prsResultId?: IntNullableFilter<"PrioritizedModel"> | number | null
  }

  export type ScoringFileUpsertWithoutPrsModelInput = {
    update: XOR<ScoringFileUpdateWithoutPrsModelInput, ScoringFileUncheckedUpdateWithoutPrsModelInput>
    create: XOR<ScoringFileCreateWithoutPrsModelInput, ScoringFileUncheckedCreateWithoutPrsModelInput>
    where?: ScoringFileWhereInput
  }

  export type ScoringFileUpdateToOneWithWhereWithoutPrsModelInput = {
    where?: ScoringFileWhereInput
    data: XOR<ScoringFileUpdateWithoutPrsModelInput, ScoringFileUncheckedUpdateWithoutPrsModelInput>
  }

  export type ScoringFileUpdateWithoutPrsModelInput = {
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    path?: StringFieldUpdateOperationsInput | string
  }

  export type ScoringFileUncheckedUpdateWithoutPrsModelInput = {
    id?: IntFieldUpdateOperationsInput | number
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    path?: StringFieldUpdateOperationsInput | string
  }

  export type PRSModelCreateWithoutTraitsInput = {
    name: string
    numberOfSNP?: number | null
    pgscId?: string | null
    pgscURL?: string | null
    broadAncestryCategories?: BroadAncestryInModelCreateNestedManyWithoutPrsModelInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleCreateNestedManyWithoutPrsModelInput
    modelEvaluations?: ModelEvaluationCreateNestedManyWithoutPrsModelInput
    publication: PublicationCreateNestedOneWithoutPrsModelsInput
    prioritizedModels?: PrioritizedModelCreateNestedManyWithoutPrsModelInput
    scoringFiles?: ScoringFileCreateNestedOneWithoutPrsModelInput
  }

  export type PRSModelUncheckedCreateWithoutTraitsInput = {
    id?: number
    name: string
    numberOfSNP?: number | null
    pgscId?: string | null
    pgscURL?: string | null
    publicationId: number
    broadAncestryCategories?: BroadAncestryInModelUncheckedCreateNestedManyWithoutPrsModelInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedCreateNestedManyWithoutPrsModelInput
    modelEvaluations?: ModelEvaluationUncheckedCreateNestedManyWithoutPrsModelInput
    prioritizedModels?: PrioritizedModelUncheckedCreateNestedManyWithoutPrsModelInput
    scoringFiles?: ScoringFileUncheckedCreateNestedOneWithoutPrsModelInput
  }

  export type PRSModelCreateOrConnectWithoutTraitsInput = {
    where: PRSModelWhereUniqueInput
    create: XOR<PRSModelCreateWithoutTraitsInput, PRSModelUncheckedCreateWithoutTraitsInput>
  }

  export type TraitCreateWithoutPrsModelsInput = {
    label: string
    description?: string | null
    URL?: string | null
    efoId?: string | null
    mondoId?: string | null
    hpoId?: string | null
    orphaId?: string | null
    otherId?: string | null
    categories?: TraitToTraitCategoryCreateNestedManyWithoutTraitInput
  }

  export type TraitUncheckedCreateWithoutPrsModelsInput = {
    id?: number
    label: string
    description?: string | null
    URL?: string | null
    efoId?: string | null
    mondoId?: string | null
    hpoId?: string | null
    orphaId?: string | null
    otherId?: string | null
    categories?: TraitToTraitCategoryUncheckedCreateNestedManyWithoutTraitInput
  }

  export type TraitCreateOrConnectWithoutPrsModelsInput = {
    where: TraitWhereUniqueInput
    create: XOR<TraitCreateWithoutPrsModelsInput, TraitUncheckedCreateWithoutPrsModelsInput>
  }

  export type PRSModelUpsertWithoutTraitsInput = {
    update: XOR<PRSModelUpdateWithoutTraitsInput, PRSModelUncheckedUpdateWithoutTraitsInput>
    create: XOR<PRSModelCreateWithoutTraitsInput, PRSModelUncheckedCreateWithoutTraitsInput>
    where?: PRSModelWhereInput
  }

  export type PRSModelUpdateToOneWithWhereWithoutTraitsInput = {
    where?: PRSModelWhereInput
    data: XOR<PRSModelUpdateWithoutTraitsInput, PRSModelUncheckedUpdateWithoutTraitsInput>
  }

  export type PRSModelUpdateWithoutTraitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
    broadAncestryCategories?: BroadAncestryInModelUpdateManyWithoutPrsModelNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUpdateManyWithoutPrsModelNestedInput
    modelEvaluations?: ModelEvaluationUpdateManyWithoutPrsModelNestedInput
    publication?: PublicationUpdateOneRequiredWithoutPrsModelsNestedInput
    prioritizedModels?: PrioritizedModelUpdateManyWithoutPrsModelNestedInput
    scoringFiles?: ScoringFileUpdateOneWithoutPrsModelNestedInput
  }

  export type PRSModelUncheckedUpdateWithoutTraitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
    publicationId?: IntFieldUpdateOperationsInput | number
    broadAncestryCategories?: BroadAncestryInModelUncheckedUpdateManyWithoutPrsModelNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedUpdateManyWithoutPrsModelNestedInput
    modelEvaluations?: ModelEvaluationUncheckedUpdateManyWithoutPrsModelNestedInput
    prioritizedModels?: PrioritizedModelUncheckedUpdateManyWithoutPrsModelNestedInput
    scoringFiles?: ScoringFileUncheckedUpdateOneWithoutPrsModelNestedInput
  }

  export type TraitUpsertWithoutPrsModelsInput = {
    update: XOR<TraitUpdateWithoutPrsModelsInput, TraitUncheckedUpdateWithoutPrsModelsInput>
    create: XOR<TraitCreateWithoutPrsModelsInput, TraitUncheckedCreateWithoutPrsModelsInput>
    where?: TraitWhereInput
  }

  export type TraitUpdateToOneWithWhereWithoutPrsModelsInput = {
    where?: TraitWhereInput
    data: XOR<TraitUpdateWithoutPrsModelsInput, TraitUncheckedUpdateWithoutPrsModelsInput>
  }

  export type TraitUpdateWithoutPrsModelsInput = {
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    efoId?: NullableStringFieldUpdateOperationsInput | string | null
    mondoId?: NullableStringFieldUpdateOperationsInput | string | null
    hpoId?: NullableStringFieldUpdateOperationsInput | string | null
    orphaId?: NullableStringFieldUpdateOperationsInput | string | null
    otherId?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: TraitToTraitCategoryUpdateManyWithoutTraitNestedInput
  }

  export type TraitUncheckedUpdateWithoutPrsModelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    URL?: NullableStringFieldUpdateOperationsInput | string | null
    efoId?: NullableStringFieldUpdateOperationsInput | string | null
    mondoId?: NullableStringFieldUpdateOperationsInput | string | null
    hpoId?: NullableStringFieldUpdateOperationsInput | string | null
    orphaId?: NullableStringFieldUpdateOperationsInput | string | null
    otherId?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: TraitToTraitCategoryUncheckedUpdateManyWithoutTraitNestedInput
  }

  export type PRSModelCreateWithoutScoringFilesInput = {
    name: string
    numberOfSNP?: number | null
    pgscId?: string | null
    pgscURL?: string | null
    broadAncestryCategories?: BroadAncestryInModelCreateNestedManyWithoutPrsModelInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleCreateNestedManyWithoutPrsModelInput
    modelEvaluations?: ModelEvaluationCreateNestedManyWithoutPrsModelInput
    publication: PublicationCreateNestedOneWithoutPrsModelsInput
    traits?: PRSModelToTraitCreateNestedManyWithoutPrsModelInput
    prioritizedModels?: PrioritizedModelCreateNestedManyWithoutPrsModelInput
  }

  export type PRSModelUncheckedCreateWithoutScoringFilesInput = {
    id?: number
    name: string
    numberOfSNP?: number | null
    pgscId?: string | null
    pgscURL?: string | null
    publicationId: number
    broadAncestryCategories?: BroadAncestryInModelUncheckedCreateNestedManyWithoutPrsModelInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedCreateNestedManyWithoutPrsModelInput
    modelEvaluations?: ModelEvaluationUncheckedCreateNestedManyWithoutPrsModelInput
    traits?: PRSModelToTraitUncheckedCreateNestedManyWithoutPrsModelInput
    prioritizedModels?: PrioritizedModelUncheckedCreateNestedManyWithoutPrsModelInput
  }

  export type PRSModelCreateOrConnectWithoutScoringFilesInput = {
    where: PRSModelWhereUniqueInput
    create: XOR<PRSModelCreateWithoutScoringFilesInput, PRSModelUncheckedCreateWithoutScoringFilesInput>
  }

  export type PRSModelUpsertWithoutScoringFilesInput = {
    update: XOR<PRSModelUpdateWithoutScoringFilesInput, PRSModelUncheckedUpdateWithoutScoringFilesInput>
    create: XOR<PRSModelCreateWithoutScoringFilesInput, PRSModelUncheckedCreateWithoutScoringFilesInput>
    where?: PRSModelWhereInput
  }

  export type PRSModelUpdateToOneWithWhereWithoutScoringFilesInput = {
    where?: PRSModelWhereInput
    data: XOR<PRSModelUpdateWithoutScoringFilesInput, PRSModelUncheckedUpdateWithoutScoringFilesInput>
  }

  export type PRSModelUpdateWithoutScoringFilesInput = {
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
    broadAncestryCategories?: BroadAncestryInModelUpdateManyWithoutPrsModelNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUpdateManyWithoutPrsModelNestedInput
    modelEvaluations?: ModelEvaluationUpdateManyWithoutPrsModelNestedInput
    publication?: PublicationUpdateOneRequiredWithoutPrsModelsNestedInput
    traits?: PRSModelToTraitUpdateManyWithoutPrsModelNestedInput
    prioritizedModels?: PrioritizedModelUpdateManyWithoutPrsModelNestedInput
  }

  export type PRSModelUncheckedUpdateWithoutScoringFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
    publicationId?: IntFieldUpdateOperationsInput | number
    broadAncestryCategories?: BroadAncestryInModelUncheckedUpdateManyWithoutPrsModelNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedUpdateManyWithoutPrsModelNestedInput
    modelEvaluations?: ModelEvaluationUncheckedUpdateManyWithoutPrsModelNestedInput
    traits?: PRSModelToTraitUncheckedUpdateManyWithoutPrsModelNestedInput
    prioritizedModels?: PrioritizedModelUncheckedUpdateManyWithoutPrsModelNestedInput
  }

  export type ModelEvaluationCreateWithoutPublicationInput = {
    reportedTrait: string
    covariates?: string | null
    ppmId?: string | null
    evaluationPopulationSample: EvaluationPopulationSampleCreateNestedOneWithoutModelEvaluationsInput
    prsModel: PRSModelCreateNestedOneWithoutModelEvaluationsInput
    metricEvaluations?: PerformanceMetricEvaluationCreateNestedManyWithoutModelEvaluationInput
  }

  export type ModelEvaluationUncheckedCreateWithoutPublicationInput = {
    id?: number
    reportedTrait: string
    covariates?: string | null
    ppmId?: string | null
    prsModelId: number
    evaluationPopulationSampleId: number
    metricEvaluations?: PerformanceMetricEvaluationUncheckedCreateNestedManyWithoutModelEvaluationInput
  }

  export type ModelEvaluationCreateOrConnectWithoutPublicationInput = {
    where: ModelEvaluationWhereUniqueInput
    create: XOR<ModelEvaluationCreateWithoutPublicationInput, ModelEvaluationUncheckedCreateWithoutPublicationInput>
  }

  export type ModelEvaluationCreateManyPublicationInputEnvelope = {
    data: ModelEvaluationCreateManyPublicationInput | ModelEvaluationCreateManyPublicationInput[]
    skipDuplicates?: boolean
  }

  export type PRSModelCreateWithoutPublicationInput = {
    name: string
    numberOfSNP?: number | null
    pgscId?: string | null
    pgscURL?: string | null
    broadAncestryCategories?: BroadAncestryInModelCreateNestedManyWithoutPrsModelInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleCreateNestedManyWithoutPrsModelInput
    modelEvaluations?: ModelEvaluationCreateNestedManyWithoutPrsModelInput
    traits?: PRSModelToTraitCreateNestedManyWithoutPrsModelInput
    prioritizedModels?: PrioritizedModelCreateNestedManyWithoutPrsModelInput
    scoringFiles?: ScoringFileCreateNestedOneWithoutPrsModelInput
  }

  export type PRSModelUncheckedCreateWithoutPublicationInput = {
    id?: number
    name: string
    numberOfSNP?: number | null
    pgscId?: string | null
    pgscURL?: string | null
    broadAncestryCategories?: BroadAncestryInModelUncheckedCreateNestedManyWithoutPrsModelInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedCreateNestedManyWithoutPrsModelInput
    modelEvaluations?: ModelEvaluationUncheckedCreateNestedManyWithoutPrsModelInput
    traits?: PRSModelToTraitUncheckedCreateNestedManyWithoutPrsModelInput
    prioritizedModels?: PrioritizedModelUncheckedCreateNestedManyWithoutPrsModelInput
    scoringFiles?: ScoringFileUncheckedCreateNestedOneWithoutPrsModelInput
  }

  export type PRSModelCreateOrConnectWithoutPublicationInput = {
    where: PRSModelWhereUniqueInput
    create: XOR<PRSModelCreateWithoutPublicationInput, PRSModelUncheckedCreateWithoutPublicationInput>
  }

  export type PRSModelCreateManyPublicationInputEnvelope = {
    data: PRSModelCreateManyPublicationInput | PRSModelCreateManyPublicationInput[]
    skipDuplicates?: boolean
  }

  export type ModelEvaluationUpsertWithWhereUniqueWithoutPublicationInput = {
    where: ModelEvaluationWhereUniqueInput
    update: XOR<ModelEvaluationUpdateWithoutPublicationInput, ModelEvaluationUncheckedUpdateWithoutPublicationInput>
    create: XOR<ModelEvaluationCreateWithoutPublicationInput, ModelEvaluationUncheckedCreateWithoutPublicationInput>
  }

  export type ModelEvaluationUpdateWithWhereUniqueWithoutPublicationInput = {
    where: ModelEvaluationWhereUniqueInput
    data: XOR<ModelEvaluationUpdateWithoutPublicationInput, ModelEvaluationUncheckedUpdateWithoutPublicationInput>
  }

  export type ModelEvaluationUpdateManyWithWhereWithoutPublicationInput = {
    where: ModelEvaluationScalarWhereInput
    data: XOR<ModelEvaluationUpdateManyMutationInput, ModelEvaluationUncheckedUpdateManyWithoutPublicationInput>
  }

  export type PRSModelUpsertWithWhereUniqueWithoutPublicationInput = {
    where: PRSModelWhereUniqueInput
    update: XOR<PRSModelUpdateWithoutPublicationInput, PRSModelUncheckedUpdateWithoutPublicationInput>
    create: XOR<PRSModelCreateWithoutPublicationInput, PRSModelUncheckedCreateWithoutPublicationInput>
  }

  export type PRSModelUpdateWithWhereUniqueWithoutPublicationInput = {
    where: PRSModelWhereUniqueInput
    data: XOR<PRSModelUpdateWithoutPublicationInput, PRSModelUncheckedUpdateWithoutPublicationInput>
  }

  export type PRSModelUpdateManyWithWhereWithoutPublicationInput = {
    where: PRSModelScalarWhereInput
    data: XOR<PRSModelUpdateManyMutationInput, PRSModelUncheckedUpdateManyWithoutPublicationInput>
  }

  export type PRSModelScalarWhereInput = {
    AND?: PRSModelScalarWhereInput | PRSModelScalarWhereInput[]
    OR?: PRSModelScalarWhereInput[]
    NOT?: PRSModelScalarWhereInput | PRSModelScalarWhereInput[]
    id?: IntFilter<"PRSModel"> | number
    name?: StringFilter<"PRSModel"> | string
    numberOfSNP?: IntNullableFilter<"PRSModel"> | number | null
    pgscId?: StringNullableFilter<"PRSModel"> | string | null
    pgscURL?: StringNullableFilter<"PRSModel"> | string | null
    publicationId?: IntFilter<"PRSModel"> | number
  }

  export type EvaluationPopulationSampleCreateWithoutModelEvaluationsInput = {
    numberOfIndividuals: number
    numberOfCases?: number | null
    numberOfControls?: number | null
    percentMale?: number | null
    age?: number | null
    ageUnits?: string | null
    ancestryBroad: string
    ancestryDetails?: string | null
    cohort: string
    gcId?: string | null
    sourcePMID?: string | null
    sourceDOI?: string | null
    phenotypeFree?: string | null
    pssId: string
    broadAncestryCategory: BroadAncestryCategoryCreateNestedOneWithoutEvaluationPopulationSamplesInput
  }

  export type EvaluationPopulationSampleUncheckedCreateWithoutModelEvaluationsInput = {
    id?: number
    numberOfIndividuals: number
    numberOfCases?: number | null
    numberOfControls?: number | null
    percentMale?: number | null
    age?: number | null
    ageUnits?: string | null
    ancestryBroad: string
    ancestryDetails?: string | null
    cohort: string
    gcId?: string | null
    sourcePMID?: string | null
    sourceDOI?: string | null
    phenotypeFree?: string | null
    pssId: string
    broadAncestryId: number
  }

  export type EvaluationPopulationSampleCreateOrConnectWithoutModelEvaluationsInput = {
    where: EvaluationPopulationSampleWhereUniqueInput
    create: XOR<EvaluationPopulationSampleCreateWithoutModelEvaluationsInput, EvaluationPopulationSampleUncheckedCreateWithoutModelEvaluationsInput>
  }

  export type PRSModelCreateWithoutModelEvaluationsInput = {
    name: string
    numberOfSNP?: number | null
    pgscId?: string | null
    pgscURL?: string | null
    broadAncestryCategories?: BroadAncestryInModelCreateNestedManyWithoutPrsModelInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleCreateNestedManyWithoutPrsModelInput
    publication: PublicationCreateNestedOneWithoutPrsModelsInput
    traits?: PRSModelToTraitCreateNestedManyWithoutPrsModelInput
    prioritizedModels?: PrioritizedModelCreateNestedManyWithoutPrsModelInput
    scoringFiles?: ScoringFileCreateNestedOneWithoutPrsModelInput
  }

  export type PRSModelUncheckedCreateWithoutModelEvaluationsInput = {
    id?: number
    name: string
    numberOfSNP?: number | null
    pgscId?: string | null
    pgscURL?: string | null
    publicationId: number
    broadAncestryCategories?: BroadAncestryInModelUncheckedCreateNestedManyWithoutPrsModelInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedCreateNestedManyWithoutPrsModelInput
    traits?: PRSModelToTraitUncheckedCreateNestedManyWithoutPrsModelInput
    prioritizedModels?: PrioritizedModelUncheckedCreateNestedManyWithoutPrsModelInput
    scoringFiles?: ScoringFileUncheckedCreateNestedOneWithoutPrsModelInput
  }

  export type PRSModelCreateOrConnectWithoutModelEvaluationsInput = {
    where: PRSModelWhereUniqueInput
    create: XOR<PRSModelCreateWithoutModelEvaluationsInput, PRSModelUncheckedCreateWithoutModelEvaluationsInput>
  }

  export type PublicationCreateWithoutModelEvaluationsInput = {
    title: string
    journal: string
    author: string
    date?: Date | string | null
    year: number
    PMID?: string | null
    DOI?: string | null
    pgpId?: string | null
    prsModels?: PRSModelCreateNestedManyWithoutPublicationInput
  }

  export type PublicationUncheckedCreateWithoutModelEvaluationsInput = {
    id?: number
    title: string
    journal: string
    author: string
    date?: Date | string | null
    year: number
    PMID?: string | null
    DOI?: string | null
    pgpId?: string | null
    prsModels?: PRSModelUncheckedCreateNestedManyWithoutPublicationInput
  }

  export type PublicationCreateOrConnectWithoutModelEvaluationsInput = {
    where: PublicationWhereUniqueInput
    create: XOR<PublicationCreateWithoutModelEvaluationsInput, PublicationUncheckedCreateWithoutModelEvaluationsInput>
  }

  export type PerformanceMetricEvaluationCreateWithoutModelEvaluationInput = {
    estimate: number
    CILower?: number | null
    CIUpper?: number | null
    performanceMetric: PerformanceMetricCreateNestedOneWithoutPerformanceMetricEvaluationsInput
  }

  export type PerformanceMetricEvaluationUncheckedCreateWithoutModelEvaluationInput = {
    id?: number
    estimate: number
    CILower?: number | null
    CIUpper?: number | null
    performanceMetricId: number
  }

  export type PerformanceMetricEvaluationCreateOrConnectWithoutModelEvaluationInput = {
    where: PerformanceMetricEvaluationWhereUniqueInput
    create: XOR<PerformanceMetricEvaluationCreateWithoutModelEvaluationInput, PerformanceMetricEvaluationUncheckedCreateWithoutModelEvaluationInput>
  }

  export type PerformanceMetricEvaluationCreateManyModelEvaluationInputEnvelope = {
    data: PerformanceMetricEvaluationCreateManyModelEvaluationInput | PerformanceMetricEvaluationCreateManyModelEvaluationInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationPopulationSampleUpsertWithoutModelEvaluationsInput = {
    update: XOR<EvaluationPopulationSampleUpdateWithoutModelEvaluationsInput, EvaluationPopulationSampleUncheckedUpdateWithoutModelEvaluationsInput>
    create: XOR<EvaluationPopulationSampleCreateWithoutModelEvaluationsInput, EvaluationPopulationSampleUncheckedCreateWithoutModelEvaluationsInput>
    where?: EvaluationPopulationSampleWhereInput
  }

  export type EvaluationPopulationSampleUpdateToOneWithWhereWithoutModelEvaluationsInput = {
    where?: EvaluationPopulationSampleWhereInput
    data: XOR<EvaluationPopulationSampleUpdateWithoutModelEvaluationsInput, EvaluationPopulationSampleUncheckedUpdateWithoutModelEvaluationsInput>
  }

  export type EvaluationPopulationSampleUpdateWithoutModelEvaluationsInput = {
    numberOfIndividuals?: IntFieldUpdateOperationsInput | number
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    phenotypeFree?: NullableStringFieldUpdateOperationsInput | string | null
    pssId?: StringFieldUpdateOperationsInput | string
    broadAncestryCategory?: BroadAncestryCategoryUpdateOneRequiredWithoutEvaluationPopulationSamplesNestedInput
  }

  export type EvaluationPopulationSampleUncheckedUpdateWithoutModelEvaluationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    numberOfIndividuals?: IntFieldUpdateOperationsInput | number
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    phenotypeFree?: NullableStringFieldUpdateOperationsInput | string | null
    pssId?: StringFieldUpdateOperationsInput | string
    broadAncestryId?: IntFieldUpdateOperationsInput | number
  }

  export type PRSModelUpsertWithoutModelEvaluationsInput = {
    update: XOR<PRSModelUpdateWithoutModelEvaluationsInput, PRSModelUncheckedUpdateWithoutModelEvaluationsInput>
    create: XOR<PRSModelCreateWithoutModelEvaluationsInput, PRSModelUncheckedCreateWithoutModelEvaluationsInput>
    where?: PRSModelWhereInput
  }

  export type PRSModelUpdateToOneWithWhereWithoutModelEvaluationsInput = {
    where?: PRSModelWhereInput
    data: XOR<PRSModelUpdateWithoutModelEvaluationsInput, PRSModelUncheckedUpdateWithoutModelEvaluationsInput>
  }

  export type PRSModelUpdateWithoutModelEvaluationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
    broadAncestryCategories?: BroadAncestryInModelUpdateManyWithoutPrsModelNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUpdateManyWithoutPrsModelNestedInput
    publication?: PublicationUpdateOneRequiredWithoutPrsModelsNestedInput
    traits?: PRSModelToTraitUpdateManyWithoutPrsModelNestedInput
    prioritizedModels?: PrioritizedModelUpdateManyWithoutPrsModelNestedInput
    scoringFiles?: ScoringFileUpdateOneWithoutPrsModelNestedInput
  }

  export type PRSModelUncheckedUpdateWithoutModelEvaluationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
    publicationId?: IntFieldUpdateOperationsInput | number
    broadAncestryCategories?: BroadAncestryInModelUncheckedUpdateManyWithoutPrsModelNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedUpdateManyWithoutPrsModelNestedInput
    traits?: PRSModelToTraitUncheckedUpdateManyWithoutPrsModelNestedInput
    prioritizedModels?: PrioritizedModelUncheckedUpdateManyWithoutPrsModelNestedInput
    scoringFiles?: ScoringFileUncheckedUpdateOneWithoutPrsModelNestedInput
  }

  export type PublicationUpsertWithoutModelEvaluationsInput = {
    update: XOR<PublicationUpdateWithoutModelEvaluationsInput, PublicationUncheckedUpdateWithoutModelEvaluationsInput>
    create: XOR<PublicationCreateWithoutModelEvaluationsInput, PublicationUncheckedCreateWithoutModelEvaluationsInput>
    where?: PublicationWhereInput
  }

  export type PublicationUpdateToOneWithWhereWithoutModelEvaluationsInput = {
    where?: PublicationWhereInput
    data: XOR<PublicationUpdateWithoutModelEvaluationsInput, PublicationUncheckedUpdateWithoutModelEvaluationsInput>
  }

  export type PublicationUpdateWithoutModelEvaluationsInput = {
    title?: StringFieldUpdateOperationsInput | string
    journal?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    year?: IntFieldUpdateOperationsInput | number
    PMID?: NullableStringFieldUpdateOperationsInput | string | null
    DOI?: NullableStringFieldUpdateOperationsInput | string | null
    pgpId?: NullableStringFieldUpdateOperationsInput | string | null
    prsModels?: PRSModelUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationUncheckedUpdateWithoutModelEvaluationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    journal?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    year?: IntFieldUpdateOperationsInput | number
    PMID?: NullableStringFieldUpdateOperationsInput | string | null
    DOI?: NullableStringFieldUpdateOperationsInput | string | null
    pgpId?: NullableStringFieldUpdateOperationsInput | string | null
    prsModels?: PRSModelUncheckedUpdateManyWithoutPublicationNestedInput
  }

  export type PerformanceMetricEvaluationUpsertWithWhereUniqueWithoutModelEvaluationInput = {
    where: PerformanceMetricEvaluationWhereUniqueInput
    update: XOR<PerformanceMetricEvaluationUpdateWithoutModelEvaluationInput, PerformanceMetricEvaluationUncheckedUpdateWithoutModelEvaluationInput>
    create: XOR<PerformanceMetricEvaluationCreateWithoutModelEvaluationInput, PerformanceMetricEvaluationUncheckedCreateWithoutModelEvaluationInput>
  }

  export type PerformanceMetricEvaluationUpdateWithWhereUniqueWithoutModelEvaluationInput = {
    where: PerformanceMetricEvaluationWhereUniqueInput
    data: XOR<PerformanceMetricEvaluationUpdateWithoutModelEvaluationInput, PerformanceMetricEvaluationUncheckedUpdateWithoutModelEvaluationInput>
  }

  export type PerformanceMetricEvaluationUpdateManyWithWhereWithoutModelEvaluationInput = {
    where: PerformanceMetricEvaluationScalarWhereInput
    data: XOR<PerformanceMetricEvaluationUpdateManyMutationInput, PerformanceMetricEvaluationUncheckedUpdateManyWithoutModelEvaluationInput>
  }

  export type PerformanceMetricEvaluationScalarWhereInput = {
    AND?: PerformanceMetricEvaluationScalarWhereInput | PerformanceMetricEvaluationScalarWhereInput[]
    OR?: PerformanceMetricEvaluationScalarWhereInput[]
    NOT?: PerformanceMetricEvaluationScalarWhereInput | PerformanceMetricEvaluationScalarWhereInput[]
    id?: IntFilter<"PerformanceMetricEvaluation"> | number
    estimate?: FloatFilter<"PerformanceMetricEvaluation"> | number
    CILower?: FloatNullableFilter<"PerformanceMetricEvaluation"> | number | null
    CIUpper?: FloatNullableFilter<"PerformanceMetricEvaluation"> | number | null
    modelEvaluationId?: IntFilter<"PerformanceMetricEvaluation"> | number
    performanceMetricId?: IntFilter<"PerformanceMetricEvaluation"> | number
  }

  export type ModelEvaluationCreateWithoutMetricEvaluationsInput = {
    reportedTrait: string
    covariates?: string | null
    ppmId?: string | null
    evaluationPopulationSample: EvaluationPopulationSampleCreateNestedOneWithoutModelEvaluationsInput
    prsModel: PRSModelCreateNestedOneWithoutModelEvaluationsInput
    publication: PublicationCreateNestedOneWithoutModelEvaluationsInput
  }

  export type ModelEvaluationUncheckedCreateWithoutMetricEvaluationsInput = {
    id?: number
    reportedTrait: string
    covariates?: string | null
    ppmId?: string | null
    prsModelId: number
    publicationId: number
    evaluationPopulationSampleId: number
  }

  export type ModelEvaluationCreateOrConnectWithoutMetricEvaluationsInput = {
    where: ModelEvaluationWhereUniqueInput
    create: XOR<ModelEvaluationCreateWithoutMetricEvaluationsInput, ModelEvaluationUncheckedCreateWithoutMetricEvaluationsInput>
  }

  export type PerformanceMetricCreateWithoutPerformanceMetricEvaluationsInput = {
    nameShort: string
    nameLong?: string | null
    type: $Enums.PerformanceMetricType
  }

  export type PerformanceMetricUncheckedCreateWithoutPerformanceMetricEvaluationsInput = {
    id?: number
    nameShort: string
    nameLong?: string | null
    type: $Enums.PerformanceMetricType
  }

  export type PerformanceMetricCreateOrConnectWithoutPerformanceMetricEvaluationsInput = {
    where: PerformanceMetricWhereUniqueInput
    create: XOR<PerformanceMetricCreateWithoutPerformanceMetricEvaluationsInput, PerformanceMetricUncheckedCreateWithoutPerformanceMetricEvaluationsInput>
  }

  export type ModelEvaluationUpsertWithoutMetricEvaluationsInput = {
    update: XOR<ModelEvaluationUpdateWithoutMetricEvaluationsInput, ModelEvaluationUncheckedUpdateWithoutMetricEvaluationsInput>
    create: XOR<ModelEvaluationCreateWithoutMetricEvaluationsInput, ModelEvaluationUncheckedCreateWithoutMetricEvaluationsInput>
    where?: ModelEvaluationWhereInput
  }

  export type ModelEvaluationUpdateToOneWithWhereWithoutMetricEvaluationsInput = {
    where?: ModelEvaluationWhereInput
    data: XOR<ModelEvaluationUpdateWithoutMetricEvaluationsInput, ModelEvaluationUncheckedUpdateWithoutMetricEvaluationsInput>
  }

  export type ModelEvaluationUpdateWithoutMetricEvaluationsInput = {
    reportedTrait?: StringFieldUpdateOperationsInput | string
    covariates?: NullableStringFieldUpdateOperationsInput | string | null
    ppmId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationPopulationSample?: EvaluationPopulationSampleUpdateOneRequiredWithoutModelEvaluationsNestedInput
    prsModel?: PRSModelUpdateOneRequiredWithoutModelEvaluationsNestedInput
    publication?: PublicationUpdateOneRequiredWithoutModelEvaluationsNestedInput
  }

  export type ModelEvaluationUncheckedUpdateWithoutMetricEvaluationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedTrait?: StringFieldUpdateOperationsInput | string
    covariates?: NullableStringFieldUpdateOperationsInput | string | null
    ppmId?: NullableStringFieldUpdateOperationsInput | string | null
    prsModelId?: IntFieldUpdateOperationsInput | number
    publicationId?: IntFieldUpdateOperationsInput | number
    evaluationPopulationSampleId?: IntFieldUpdateOperationsInput | number
  }

  export type PerformanceMetricUpsertWithoutPerformanceMetricEvaluationsInput = {
    update: XOR<PerformanceMetricUpdateWithoutPerformanceMetricEvaluationsInput, PerformanceMetricUncheckedUpdateWithoutPerformanceMetricEvaluationsInput>
    create: XOR<PerformanceMetricCreateWithoutPerformanceMetricEvaluationsInput, PerformanceMetricUncheckedCreateWithoutPerformanceMetricEvaluationsInput>
    where?: PerformanceMetricWhereInput
  }

  export type PerformanceMetricUpdateToOneWithWhereWithoutPerformanceMetricEvaluationsInput = {
    where?: PerformanceMetricWhereInput
    data: XOR<PerformanceMetricUpdateWithoutPerformanceMetricEvaluationsInput, PerformanceMetricUncheckedUpdateWithoutPerformanceMetricEvaluationsInput>
  }

  export type PerformanceMetricUpdateWithoutPerformanceMetricEvaluationsInput = {
    nameShort?: StringFieldUpdateOperationsInput | string
    nameLong?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPerformanceMetricTypeFieldUpdateOperationsInput | $Enums.PerformanceMetricType
  }

  export type PerformanceMetricUncheckedUpdateWithoutPerformanceMetricEvaluationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameShort?: StringFieldUpdateOperationsInput | string
    nameLong?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPerformanceMetricTypeFieldUpdateOperationsInput | $Enums.PerformanceMetricType
  }

  export type PerformanceMetricEvaluationCreateWithoutPerformanceMetricInput = {
    estimate: number
    CILower?: number | null
    CIUpper?: number | null
    modelEvaluation: ModelEvaluationCreateNestedOneWithoutMetricEvaluationsInput
  }

  export type PerformanceMetricEvaluationUncheckedCreateWithoutPerformanceMetricInput = {
    id?: number
    estimate: number
    CILower?: number | null
    CIUpper?: number | null
    modelEvaluationId: number
  }

  export type PerformanceMetricEvaluationCreateOrConnectWithoutPerformanceMetricInput = {
    where: PerformanceMetricEvaluationWhereUniqueInput
    create: XOR<PerformanceMetricEvaluationCreateWithoutPerformanceMetricInput, PerformanceMetricEvaluationUncheckedCreateWithoutPerformanceMetricInput>
  }

  export type PerformanceMetricEvaluationCreateManyPerformanceMetricInputEnvelope = {
    data: PerformanceMetricEvaluationCreateManyPerformanceMetricInput | PerformanceMetricEvaluationCreateManyPerformanceMetricInput[]
    skipDuplicates?: boolean
  }

  export type PerformanceMetricEvaluationUpsertWithWhereUniqueWithoutPerformanceMetricInput = {
    where: PerformanceMetricEvaluationWhereUniqueInput
    update: XOR<PerformanceMetricEvaluationUpdateWithoutPerformanceMetricInput, PerformanceMetricEvaluationUncheckedUpdateWithoutPerformanceMetricInput>
    create: XOR<PerformanceMetricEvaluationCreateWithoutPerformanceMetricInput, PerformanceMetricEvaluationUncheckedCreateWithoutPerformanceMetricInput>
  }

  export type PerformanceMetricEvaluationUpdateWithWhereUniqueWithoutPerformanceMetricInput = {
    where: PerformanceMetricEvaluationWhereUniqueInput
    data: XOR<PerformanceMetricEvaluationUpdateWithoutPerformanceMetricInput, PerformanceMetricEvaluationUncheckedUpdateWithoutPerformanceMetricInput>
  }

  export type PerformanceMetricEvaluationUpdateManyWithWhereWithoutPerformanceMetricInput = {
    where: PerformanceMetricEvaluationScalarWhereInput
    data: XOR<PerformanceMetricEvaluationUpdateManyMutationInput, PerformanceMetricEvaluationUncheckedUpdateManyWithoutPerformanceMetricInput>
  }

  export type BroadAncestryCategoryCreateWithoutEvaluationPopulationSamplesInput = {
    symbol: string
    label: string
    broadAncestryInModels?: BroadAncestryInModelCreateNestedManyWithoutBroadAncestryCategoryInput
    broadAncestryInRefPops?: BroadAncestryInRefPopCreateNestedManyWithoutBroadAncestryCategoryInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleCreateNestedManyWithoutBroadAncestryCategoryInput
  }

  export type BroadAncestryCategoryUncheckedCreateWithoutEvaluationPopulationSamplesInput = {
    id?: number
    symbol: string
    label: string
    broadAncestryInModels?: BroadAncestryInModelUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput
    broadAncestryInRefPops?: BroadAncestryInRefPopUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput
  }

  export type BroadAncestryCategoryCreateOrConnectWithoutEvaluationPopulationSamplesInput = {
    where: BroadAncestryCategoryWhereUniqueInput
    create: XOR<BroadAncestryCategoryCreateWithoutEvaluationPopulationSamplesInput, BroadAncestryCategoryUncheckedCreateWithoutEvaluationPopulationSamplesInput>
  }

  export type ModelEvaluationCreateWithoutEvaluationPopulationSampleInput = {
    reportedTrait: string
    covariates?: string | null
    ppmId?: string | null
    prsModel: PRSModelCreateNestedOneWithoutModelEvaluationsInput
    publication: PublicationCreateNestedOneWithoutModelEvaluationsInput
    metricEvaluations?: PerformanceMetricEvaluationCreateNestedManyWithoutModelEvaluationInput
  }

  export type ModelEvaluationUncheckedCreateWithoutEvaluationPopulationSampleInput = {
    id?: number
    reportedTrait: string
    covariates?: string | null
    ppmId?: string | null
    prsModelId: number
    publicationId: number
    metricEvaluations?: PerformanceMetricEvaluationUncheckedCreateNestedManyWithoutModelEvaluationInput
  }

  export type ModelEvaluationCreateOrConnectWithoutEvaluationPopulationSampleInput = {
    where: ModelEvaluationWhereUniqueInput
    create: XOR<ModelEvaluationCreateWithoutEvaluationPopulationSampleInput, ModelEvaluationUncheckedCreateWithoutEvaluationPopulationSampleInput>
  }

  export type ModelEvaluationCreateManyEvaluationPopulationSampleInputEnvelope = {
    data: ModelEvaluationCreateManyEvaluationPopulationSampleInput | ModelEvaluationCreateManyEvaluationPopulationSampleInput[]
    skipDuplicates?: boolean
  }

  export type BroadAncestryCategoryUpsertWithoutEvaluationPopulationSamplesInput = {
    update: XOR<BroadAncestryCategoryUpdateWithoutEvaluationPopulationSamplesInput, BroadAncestryCategoryUncheckedUpdateWithoutEvaluationPopulationSamplesInput>
    create: XOR<BroadAncestryCategoryCreateWithoutEvaluationPopulationSamplesInput, BroadAncestryCategoryUncheckedCreateWithoutEvaluationPopulationSamplesInput>
    where?: BroadAncestryCategoryWhereInput
  }

  export type BroadAncestryCategoryUpdateToOneWithWhereWithoutEvaluationPopulationSamplesInput = {
    where?: BroadAncestryCategoryWhereInput
    data: XOR<BroadAncestryCategoryUpdateWithoutEvaluationPopulationSamplesInput, BroadAncestryCategoryUncheckedUpdateWithoutEvaluationPopulationSamplesInput>
  }

  export type BroadAncestryCategoryUpdateWithoutEvaluationPopulationSamplesInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    broadAncestryInModels?: BroadAncestryInModelUpdateManyWithoutBroadAncestryCategoryNestedInput
    broadAncestryInRefPops?: BroadAncestryInRefPopUpdateManyWithoutBroadAncestryCategoryNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUpdateManyWithoutBroadAncestryCategoryNestedInput
  }

  export type BroadAncestryCategoryUncheckedUpdateWithoutEvaluationPopulationSamplesInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    broadAncestryInModels?: BroadAncestryInModelUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput
    broadAncestryInRefPops?: BroadAncestryInRefPopUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput
  }

  export type ModelEvaluationUpsertWithWhereUniqueWithoutEvaluationPopulationSampleInput = {
    where: ModelEvaluationWhereUniqueInput
    update: XOR<ModelEvaluationUpdateWithoutEvaluationPopulationSampleInput, ModelEvaluationUncheckedUpdateWithoutEvaluationPopulationSampleInput>
    create: XOR<ModelEvaluationCreateWithoutEvaluationPopulationSampleInput, ModelEvaluationUncheckedCreateWithoutEvaluationPopulationSampleInput>
  }

  export type ModelEvaluationUpdateWithWhereUniqueWithoutEvaluationPopulationSampleInput = {
    where: ModelEvaluationWhereUniqueInput
    data: XOR<ModelEvaluationUpdateWithoutEvaluationPopulationSampleInput, ModelEvaluationUncheckedUpdateWithoutEvaluationPopulationSampleInput>
  }

  export type ModelEvaluationUpdateManyWithWhereWithoutEvaluationPopulationSampleInput = {
    where: ModelEvaluationScalarWhereInput
    data: XOR<ModelEvaluationUpdateManyMutationInput, ModelEvaluationUncheckedUpdateManyWithoutEvaluationPopulationSampleInput>
  }

  export type BroadAncestryInModelCreateWithoutBroadAncestryCategoryInput = {
    percentage: number
    prsModel: PRSModelCreateNestedOneWithoutBroadAncestryCategoriesInput
  }

  export type BroadAncestryInModelUncheckedCreateWithoutBroadAncestryCategoryInput = {
    percentage: number
    prsModelId: number
  }

  export type BroadAncestryInModelCreateOrConnectWithoutBroadAncestryCategoryInput = {
    where: BroadAncestryInModelWhereUniqueInput
    create: XOR<BroadAncestryInModelCreateWithoutBroadAncestryCategoryInput, BroadAncestryInModelUncheckedCreateWithoutBroadAncestryCategoryInput>
  }

  export type BroadAncestryInModelCreateManyBroadAncestryCategoryInputEnvelope = {
    data: BroadAncestryInModelCreateManyBroadAncestryCategoryInput | BroadAncestryInModelCreateManyBroadAncestryCategoryInput[]
    skipDuplicates?: boolean
  }

  export type BroadAncestryInRefPopCreateWithoutBroadAncestryCategoryInput = {
    percentage: number
    referencePopulation: ReferencePopulationCreateNestedOneWithoutBroadAncestryCategoriesInput
  }

  export type BroadAncestryInRefPopUncheckedCreateWithoutBroadAncestryCategoryInput = {
    percentage: number
    referencePopulationId: number
  }

  export type BroadAncestryInRefPopCreateOrConnectWithoutBroadAncestryCategoryInput = {
    where: BroadAncestryInRefPopWhereUniqueInput
    create: XOR<BroadAncestryInRefPopCreateWithoutBroadAncestryCategoryInput, BroadAncestryInRefPopUncheckedCreateWithoutBroadAncestryCategoryInput>
  }

  export type BroadAncestryInRefPopCreateManyBroadAncestryCategoryInputEnvelope = {
    data: BroadAncestryInRefPopCreateManyBroadAncestryCategoryInput | BroadAncestryInRefPopCreateManyBroadAncestryCategoryInput[]
    skipDuplicates?: boolean
  }

  export type DevelopmentPopulationSampleCreateWithoutBroadAncestryCategoryInput = {
    numberOfIndividuals?: number | null
    numberOfCases?: number | null
    numberOfControls?: number | null
    percentMale?: number | null
    age?: number | null
    ageUnits?: string | null
    ancestryBroad: string
    ancestryDetails?: string | null
    cohort: string
    gcId?: string | null
    sourcePMID?: string | null
    sourceDOI?: string | null
    role: $Enums.DevelopmentRoleType
    prsModel: PRSModelCreateNestedOneWithoutDevelopmentPopulationSamplesInput
  }

  export type DevelopmentPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput = {
    id?: number
    numberOfIndividuals?: number | null
    numberOfCases?: number | null
    numberOfControls?: number | null
    percentMale?: number | null
    age?: number | null
    ageUnits?: string | null
    ancestryBroad: string
    ancestryDetails?: string | null
    cohort: string
    gcId?: string | null
    sourcePMID?: string | null
    sourceDOI?: string | null
    role: $Enums.DevelopmentRoleType
    prsModelId: number
  }

  export type DevelopmentPopulationSampleCreateOrConnectWithoutBroadAncestryCategoryInput = {
    where: DevelopmentPopulationSampleWhereUniqueInput
    create: XOR<DevelopmentPopulationSampleCreateWithoutBroadAncestryCategoryInput, DevelopmentPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput>
  }

  export type DevelopmentPopulationSampleCreateManyBroadAncestryCategoryInputEnvelope = {
    data: DevelopmentPopulationSampleCreateManyBroadAncestryCategoryInput | DevelopmentPopulationSampleCreateManyBroadAncestryCategoryInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationPopulationSampleCreateWithoutBroadAncestryCategoryInput = {
    numberOfIndividuals: number
    numberOfCases?: number | null
    numberOfControls?: number | null
    percentMale?: number | null
    age?: number | null
    ageUnits?: string | null
    ancestryBroad: string
    ancestryDetails?: string | null
    cohort: string
    gcId?: string | null
    sourcePMID?: string | null
    sourceDOI?: string | null
    phenotypeFree?: string | null
    pssId: string
    modelEvaluations?: ModelEvaluationCreateNestedManyWithoutEvaluationPopulationSampleInput
  }

  export type EvaluationPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput = {
    id?: number
    numberOfIndividuals: number
    numberOfCases?: number | null
    numberOfControls?: number | null
    percentMale?: number | null
    age?: number | null
    ageUnits?: string | null
    ancestryBroad: string
    ancestryDetails?: string | null
    cohort: string
    gcId?: string | null
    sourcePMID?: string | null
    sourceDOI?: string | null
    phenotypeFree?: string | null
    pssId: string
    modelEvaluations?: ModelEvaluationUncheckedCreateNestedManyWithoutEvaluationPopulationSampleInput
  }

  export type EvaluationPopulationSampleCreateOrConnectWithoutBroadAncestryCategoryInput = {
    where: EvaluationPopulationSampleWhereUniqueInput
    create: XOR<EvaluationPopulationSampleCreateWithoutBroadAncestryCategoryInput, EvaluationPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput>
  }

  export type EvaluationPopulationSampleCreateManyBroadAncestryCategoryInputEnvelope = {
    data: EvaluationPopulationSampleCreateManyBroadAncestryCategoryInput | EvaluationPopulationSampleCreateManyBroadAncestryCategoryInput[]
    skipDuplicates?: boolean
  }

  export type BroadAncestryInModelUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput = {
    where: BroadAncestryInModelWhereUniqueInput
    update: XOR<BroadAncestryInModelUpdateWithoutBroadAncestryCategoryInput, BroadAncestryInModelUncheckedUpdateWithoutBroadAncestryCategoryInput>
    create: XOR<BroadAncestryInModelCreateWithoutBroadAncestryCategoryInput, BroadAncestryInModelUncheckedCreateWithoutBroadAncestryCategoryInput>
  }

  export type BroadAncestryInModelUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput = {
    where: BroadAncestryInModelWhereUniqueInput
    data: XOR<BroadAncestryInModelUpdateWithoutBroadAncestryCategoryInput, BroadAncestryInModelUncheckedUpdateWithoutBroadAncestryCategoryInput>
  }

  export type BroadAncestryInModelUpdateManyWithWhereWithoutBroadAncestryCategoryInput = {
    where: BroadAncestryInModelScalarWhereInput
    data: XOR<BroadAncestryInModelUpdateManyMutationInput, BroadAncestryInModelUncheckedUpdateManyWithoutBroadAncestryCategoryInput>
  }

  export type BroadAncestryInRefPopUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput = {
    where: BroadAncestryInRefPopWhereUniqueInput
    update: XOR<BroadAncestryInRefPopUpdateWithoutBroadAncestryCategoryInput, BroadAncestryInRefPopUncheckedUpdateWithoutBroadAncestryCategoryInput>
    create: XOR<BroadAncestryInRefPopCreateWithoutBroadAncestryCategoryInput, BroadAncestryInRefPopUncheckedCreateWithoutBroadAncestryCategoryInput>
  }

  export type BroadAncestryInRefPopUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput = {
    where: BroadAncestryInRefPopWhereUniqueInput
    data: XOR<BroadAncestryInRefPopUpdateWithoutBroadAncestryCategoryInput, BroadAncestryInRefPopUncheckedUpdateWithoutBroadAncestryCategoryInput>
  }

  export type BroadAncestryInRefPopUpdateManyWithWhereWithoutBroadAncestryCategoryInput = {
    where: BroadAncestryInRefPopScalarWhereInput
    data: XOR<BroadAncestryInRefPopUpdateManyMutationInput, BroadAncestryInRefPopUncheckedUpdateManyWithoutBroadAncestryCategoryInput>
  }

  export type BroadAncestryInRefPopScalarWhereInput = {
    AND?: BroadAncestryInRefPopScalarWhereInput | BroadAncestryInRefPopScalarWhereInput[]
    OR?: BroadAncestryInRefPopScalarWhereInput[]
    NOT?: BroadAncestryInRefPopScalarWhereInput | BroadAncestryInRefPopScalarWhereInput[]
    percentage?: FloatFilter<"BroadAncestryInRefPop"> | number
    broadAncestryId?: IntFilter<"BroadAncestryInRefPop"> | number
    referencePopulationId?: IntFilter<"BroadAncestryInRefPop"> | number
  }

  export type DevelopmentPopulationSampleUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput = {
    where: DevelopmentPopulationSampleWhereUniqueInput
    update: XOR<DevelopmentPopulationSampleUpdateWithoutBroadAncestryCategoryInput, DevelopmentPopulationSampleUncheckedUpdateWithoutBroadAncestryCategoryInput>
    create: XOR<DevelopmentPopulationSampleCreateWithoutBroadAncestryCategoryInput, DevelopmentPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput>
  }

  export type DevelopmentPopulationSampleUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput = {
    where: DevelopmentPopulationSampleWhereUniqueInput
    data: XOR<DevelopmentPopulationSampleUpdateWithoutBroadAncestryCategoryInput, DevelopmentPopulationSampleUncheckedUpdateWithoutBroadAncestryCategoryInput>
  }

  export type DevelopmentPopulationSampleUpdateManyWithWhereWithoutBroadAncestryCategoryInput = {
    where: DevelopmentPopulationSampleScalarWhereInput
    data: XOR<DevelopmentPopulationSampleUpdateManyMutationInput, DevelopmentPopulationSampleUncheckedUpdateManyWithoutBroadAncestryCategoryInput>
  }

  export type EvaluationPopulationSampleUpsertWithWhereUniqueWithoutBroadAncestryCategoryInput = {
    where: EvaluationPopulationSampleWhereUniqueInput
    update: XOR<EvaluationPopulationSampleUpdateWithoutBroadAncestryCategoryInput, EvaluationPopulationSampleUncheckedUpdateWithoutBroadAncestryCategoryInput>
    create: XOR<EvaluationPopulationSampleCreateWithoutBroadAncestryCategoryInput, EvaluationPopulationSampleUncheckedCreateWithoutBroadAncestryCategoryInput>
  }

  export type EvaluationPopulationSampleUpdateWithWhereUniqueWithoutBroadAncestryCategoryInput = {
    where: EvaluationPopulationSampleWhereUniqueInput
    data: XOR<EvaluationPopulationSampleUpdateWithoutBroadAncestryCategoryInput, EvaluationPopulationSampleUncheckedUpdateWithoutBroadAncestryCategoryInput>
  }

  export type EvaluationPopulationSampleUpdateManyWithWhereWithoutBroadAncestryCategoryInput = {
    where: EvaluationPopulationSampleScalarWhereInput
    data: XOR<EvaluationPopulationSampleUpdateManyMutationInput, EvaluationPopulationSampleUncheckedUpdateManyWithoutBroadAncestryCategoryInput>
  }

  export type EvaluationPopulationSampleScalarWhereInput = {
    AND?: EvaluationPopulationSampleScalarWhereInput | EvaluationPopulationSampleScalarWhereInput[]
    OR?: EvaluationPopulationSampleScalarWhereInput[]
    NOT?: EvaluationPopulationSampleScalarWhereInput | EvaluationPopulationSampleScalarWhereInput[]
    id?: IntFilter<"EvaluationPopulationSample"> | number
    numberOfIndividuals?: IntFilter<"EvaluationPopulationSample"> | number
    numberOfCases?: IntNullableFilter<"EvaluationPopulationSample"> | number | null
    numberOfControls?: IntNullableFilter<"EvaluationPopulationSample"> | number | null
    percentMale?: FloatNullableFilter<"EvaluationPopulationSample"> | number | null
    age?: FloatNullableFilter<"EvaluationPopulationSample"> | number | null
    ageUnits?: StringNullableFilter<"EvaluationPopulationSample"> | string | null
    ancestryBroad?: StringFilter<"EvaluationPopulationSample"> | string
    ancestryDetails?: StringNullableFilter<"EvaluationPopulationSample"> | string | null
    cohort?: StringFilter<"EvaluationPopulationSample"> | string
    gcId?: StringNullableFilter<"EvaluationPopulationSample"> | string | null
    sourcePMID?: StringNullableFilter<"EvaluationPopulationSample"> | string | null
    sourceDOI?: StringNullableFilter<"EvaluationPopulationSample"> | string | null
    phenotypeFree?: StringNullableFilter<"EvaluationPopulationSample"> | string | null
    pssId?: StringFilter<"EvaluationPopulationSample"> | string
    broadAncestryId?: IntFilter<"EvaluationPopulationSample"> | number
  }

  export type BroadAncestryCategoryCreateWithoutBroadAncestryInModelsInput = {
    symbol: string
    label: string
    broadAncestryInRefPops?: BroadAncestryInRefPopCreateNestedManyWithoutBroadAncestryCategoryInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleCreateNestedManyWithoutBroadAncestryCategoryInput
    EvaluationPopulationSamples?: EvaluationPopulationSampleCreateNestedManyWithoutBroadAncestryCategoryInput
  }

  export type BroadAncestryCategoryUncheckedCreateWithoutBroadAncestryInModelsInput = {
    id?: number
    symbol: string
    label: string
    broadAncestryInRefPops?: BroadAncestryInRefPopUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput
    EvaluationPopulationSamples?: EvaluationPopulationSampleUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput
  }

  export type BroadAncestryCategoryCreateOrConnectWithoutBroadAncestryInModelsInput = {
    where: BroadAncestryCategoryWhereUniqueInput
    create: XOR<BroadAncestryCategoryCreateWithoutBroadAncestryInModelsInput, BroadAncestryCategoryUncheckedCreateWithoutBroadAncestryInModelsInput>
  }

  export type PRSModelCreateWithoutBroadAncestryCategoriesInput = {
    name: string
    numberOfSNP?: number | null
    pgscId?: string | null
    pgscURL?: string | null
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleCreateNestedManyWithoutPrsModelInput
    modelEvaluations?: ModelEvaluationCreateNestedManyWithoutPrsModelInput
    publication: PublicationCreateNestedOneWithoutPrsModelsInput
    traits?: PRSModelToTraitCreateNestedManyWithoutPrsModelInput
    prioritizedModels?: PrioritizedModelCreateNestedManyWithoutPrsModelInput
    scoringFiles?: ScoringFileCreateNestedOneWithoutPrsModelInput
  }

  export type PRSModelUncheckedCreateWithoutBroadAncestryCategoriesInput = {
    id?: number
    name: string
    numberOfSNP?: number | null
    pgscId?: string | null
    pgscURL?: string | null
    publicationId: number
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedCreateNestedManyWithoutPrsModelInput
    modelEvaluations?: ModelEvaluationUncheckedCreateNestedManyWithoutPrsModelInput
    traits?: PRSModelToTraitUncheckedCreateNestedManyWithoutPrsModelInput
    prioritizedModels?: PrioritizedModelUncheckedCreateNestedManyWithoutPrsModelInput
    scoringFiles?: ScoringFileUncheckedCreateNestedOneWithoutPrsModelInput
  }

  export type PRSModelCreateOrConnectWithoutBroadAncestryCategoriesInput = {
    where: PRSModelWhereUniqueInput
    create: XOR<PRSModelCreateWithoutBroadAncestryCategoriesInput, PRSModelUncheckedCreateWithoutBroadAncestryCategoriesInput>
  }

  export type BroadAncestryCategoryUpsertWithoutBroadAncestryInModelsInput = {
    update: XOR<BroadAncestryCategoryUpdateWithoutBroadAncestryInModelsInput, BroadAncestryCategoryUncheckedUpdateWithoutBroadAncestryInModelsInput>
    create: XOR<BroadAncestryCategoryCreateWithoutBroadAncestryInModelsInput, BroadAncestryCategoryUncheckedCreateWithoutBroadAncestryInModelsInput>
    where?: BroadAncestryCategoryWhereInput
  }

  export type BroadAncestryCategoryUpdateToOneWithWhereWithoutBroadAncestryInModelsInput = {
    where?: BroadAncestryCategoryWhereInput
    data: XOR<BroadAncestryCategoryUpdateWithoutBroadAncestryInModelsInput, BroadAncestryCategoryUncheckedUpdateWithoutBroadAncestryInModelsInput>
  }

  export type BroadAncestryCategoryUpdateWithoutBroadAncestryInModelsInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    broadAncestryInRefPops?: BroadAncestryInRefPopUpdateManyWithoutBroadAncestryCategoryNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUpdateManyWithoutBroadAncestryCategoryNestedInput
    EvaluationPopulationSamples?: EvaluationPopulationSampleUpdateManyWithoutBroadAncestryCategoryNestedInput
  }

  export type BroadAncestryCategoryUncheckedUpdateWithoutBroadAncestryInModelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    broadAncestryInRefPops?: BroadAncestryInRefPopUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput
    EvaluationPopulationSamples?: EvaluationPopulationSampleUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput
  }

  export type PRSModelUpsertWithoutBroadAncestryCategoriesInput = {
    update: XOR<PRSModelUpdateWithoutBroadAncestryCategoriesInput, PRSModelUncheckedUpdateWithoutBroadAncestryCategoriesInput>
    create: XOR<PRSModelCreateWithoutBroadAncestryCategoriesInput, PRSModelUncheckedCreateWithoutBroadAncestryCategoriesInput>
    where?: PRSModelWhereInput
  }

  export type PRSModelUpdateToOneWithWhereWithoutBroadAncestryCategoriesInput = {
    where?: PRSModelWhereInput
    data: XOR<PRSModelUpdateWithoutBroadAncestryCategoriesInput, PRSModelUncheckedUpdateWithoutBroadAncestryCategoriesInput>
  }

  export type PRSModelUpdateWithoutBroadAncestryCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUpdateManyWithoutPrsModelNestedInput
    modelEvaluations?: ModelEvaluationUpdateManyWithoutPrsModelNestedInput
    publication?: PublicationUpdateOneRequiredWithoutPrsModelsNestedInput
    traits?: PRSModelToTraitUpdateManyWithoutPrsModelNestedInput
    prioritizedModels?: PrioritizedModelUpdateManyWithoutPrsModelNestedInput
    scoringFiles?: ScoringFileUpdateOneWithoutPrsModelNestedInput
  }

  export type PRSModelUncheckedUpdateWithoutBroadAncestryCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
    publicationId?: IntFieldUpdateOperationsInput | number
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedUpdateManyWithoutPrsModelNestedInput
    modelEvaluations?: ModelEvaluationUncheckedUpdateManyWithoutPrsModelNestedInput
    traits?: PRSModelToTraitUncheckedUpdateManyWithoutPrsModelNestedInput
    prioritizedModels?: PrioritizedModelUncheckedUpdateManyWithoutPrsModelNestedInput
    scoringFiles?: ScoringFileUncheckedUpdateOneWithoutPrsModelNestedInput
  }

  export type BroadAncestryCategoryCreateWithoutDevelopmentPopulationSamplesInput = {
    symbol: string
    label: string
    broadAncestryInModels?: BroadAncestryInModelCreateNestedManyWithoutBroadAncestryCategoryInput
    broadAncestryInRefPops?: BroadAncestryInRefPopCreateNestedManyWithoutBroadAncestryCategoryInput
    EvaluationPopulationSamples?: EvaluationPopulationSampleCreateNestedManyWithoutBroadAncestryCategoryInput
  }

  export type BroadAncestryCategoryUncheckedCreateWithoutDevelopmentPopulationSamplesInput = {
    id?: number
    symbol: string
    label: string
    broadAncestryInModels?: BroadAncestryInModelUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput
    broadAncestryInRefPops?: BroadAncestryInRefPopUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput
    EvaluationPopulationSamples?: EvaluationPopulationSampleUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput
  }

  export type BroadAncestryCategoryCreateOrConnectWithoutDevelopmentPopulationSamplesInput = {
    where: BroadAncestryCategoryWhereUniqueInput
    create: XOR<BroadAncestryCategoryCreateWithoutDevelopmentPopulationSamplesInput, BroadAncestryCategoryUncheckedCreateWithoutDevelopmentPopulationSamplesInput>
  }

  export type PRSModelCreateWithoutDevelopmentPopulationSamplesInput = {
    name: string
    numberOfSNP?: number | null
    pgscId?: string | null
    pgscURL?: string | null
    broadAncestryCategories?: BroadAncestryInModelCreateNestedManyWithoutPrsModelInput
    modelEvaluations?: ModelEvaluationCreateNestedManyWithoutPrsModelInput
    publication: PublicationCreateNestedOneWithoutPrsModelsInput
    traits?: PRSModelToTraitCreateNestedManyWithoutPrsModelInput
    prioritizedModels?: PrioritizedModelCreateNestedManyWithoutPrsModelInput
    scoringFiles?: ScoringFileCreateNestedOneWithoutPrsModelInput
  }

  export type PRSModelUncheckedCreateWithoutDevelopmentPopulationSamplesInput = {
    id?: number
    name: string
    numberOfSNP?: number | null
    pgscId?: string | null
    pgscURL?: string | null
    publicationId: number
    broadAncestryCategories?: BroadAncestryInModelUncheckedCreateNestedManyWithoutPrsModelInput
    modelEvaluations?: ModelEvaluationUncheckedCreateNestedManyWithoutPrsModelInput
    traits?: PRSModelToTraitUncheckedCreateNestedManyWithoutPrsModelInput
    prioritizedModels?: PrioritizedModelUncheckedCreateNestedManyWithoutPrsModelInput
    scoringFiles?: ScoringFileUncheckedCreateNestedOneWithoutPrsModelInput
  }

  export type PRSModelCreateOrConnectWithoutDevelopmentPopulationSamplesInput = {
    where: PRSModelWhereUniqueInput
    create: XOR<PRSModelCreateWithoutDevelopmentPopulationSamplesInput, PRSModelUncheckedCreateWithoutDevelopmentPopulationSamplesInput>
  }

  export type BroadAncestryCategoryUpsertWithoutDevelopmentPopulationSamplesInput = {
    update: XOR<BroadAncestryCategoryUpdateWithoutDevelopmentPopulationSamplesInput, BroadAncestryCategoryUncheckedUpdateWithoutDevelopmentPopulationSamplesInput>
    create: XOR<BroadAncestryCategoryCreateWithoutDevelopmentPopulationSamplesInput, BroadAncestryCategoryUncheckedCreateWithoutDevelopmentPopulationSamplesInput>
    where?: BroadAncestryCategoryWhereInput
  }

  export type BroadAncestryCategoryUpdateToOneWithWhereWithoutDevelopmentPopulationSamplesInput = {
    where?: BroadAncestryCategoryWhereInput
    data: XOR<BroadAncestryCategoryUpdateWithoutDevelopmentPopulationSamplesInput, BroadAncestryCategoryUncheckedUpdateWithoutDevelopmentPopulationSamplesInput>
  }

  export type BroadAncestryCategoryUpdateWithoutDevelopmentPopulationSamplesInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    broadAncestryInModels?: BroadAncestryInModelUpdateManyWithoutBroadAncestryCategoryNestedInput
    broadAncestryInRefPops?: BroadAncestryInRefPopUpdateManyWithoutBroadAncestryCategoryNestedInput
    EvaluationPopulationSamples?: EvaluationPopulationSampleUpdateManyWithoutBroadAncestryCategoryNestedInput
  }

  export type BroadAncestryCategoryUncheckedUpdateWithoutDevelopmentPopulationSamplesInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    broadAncestryInModels?: BroadAncestryInModelUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput
    broadAncestryInRefPops?: BroadAncestryInRefPopUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput
    EvaluationPopulationSamples?: EvaluationPopulationSampleUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput
  }

  export type PRSModelUpsertWithoutDevelopmentPopulationSamplesInput = {
    update: XOR<PRSModelUpdateWithoutDevelopmentPopulationSamplesInput, PRSModelUncheckedUpdateWithoutDevelopmentPopulationSamplesInput>
    create: XOR<PRSModelCreateWithoutDevelopmentPopulationSamplesInput, PRSModelUncheckedCreateWithoutDevelopmentPopulationSamplesInput>
    where?: PRSModelWhereInput
  }

  export type PRSModelUpdateToOneWithWhereWithoutDevelopmentPopulationSamplesInput = {
    where?: PRSModelWhereInput
    data: XOR<PRSModelUpdateWithoutDevelopmentPopulationSamplesInput, PRSModelUncheckedUpdateWithoutDevelopmentPopulationSamplesInput>
  }

  export type PRSModelUpdateWithoutDevelopmentPopulationSamplesInput = {
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
    broadAncestryCategories?: BroadAncestryInModelUpdateManyWithoutPrsModelNestedInput
    modelEvaluations?: ModelEvaluationUpdateManyWithoutPrsModelNestedInput
    publication?: PublicationUpdateOneRequiredWithoutPrsModelsNestedInput
    traits?: PRSModelToTraitUpdateManyWithoutPrsModelNestedInput
    prioritizedModels?: PrioritizedModelUpdateManyWithoutPrsModelNestedInput
    scoringFiles?: ScoringFileUpdateOneWithoutPrsModelNestedInput
  }

  export type PRSModelUncheckedUpdateWithoutDevelopmentPopulationSamplesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
    publicationId?: IntFieldUpdateOperationsInput | number
    broadAncestryCategories?: BroadAncestryInModelUncheckedUpdateManyWithoutPrsModelNestedInput
    modelEvaluations?: ModelEvaluationUncheckedUpdateManyWithoutPrsModelNestedInput
    traits?: PRSModelToTraitUncheckedUpdateManyWithoutPrsModelNestedInput
    prioritizedModels?: PrioritizedModelUncheckedUpdateManyWithoutPrsModelNestedInput
    scoringFiles?: ScoringFileUncheckedUpdateOneWithoutPrsModelNestedInput
  }

  export type BroadAncestryCategoryCreateWithoutBroadAncestryInRefPopsInput = {
    symbol: string
    label: string
    broadAncestryInModels?: BroadAncestryInModelCreateNestedManyWithoutBroadAncestryCategoryInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleCreateNestedManyWithoutBroadAncestryCategoryInput
    EvaluationPopulationSamples?: EvaluationPopulationSampleCreateNestedManyWithoutBroadAncestryCategoryInput
  }

  export type BroadAncestryCategoryUncheckedCreateWithoutBroadAncestryInRefPopsInput = {
    id?: number
    symbol: string
    label: string
    broadAncestryInModels?: BroadAncestryInModelUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput
    EvaluationPopulationSamples?: EvaluationPopulationSampleUncheckedCreateNestedManyWithoutBroadAncestryCategoryInput
  }

  export type BroadAncestryCategoryCreateOrConnectWithoutBroadAncestryInRefPopsInput = {
    where: BroadAncestryCategoryWhereUniqueInput
    create: XOR<BroadAncestryCategoryCreateWithoutBroadAncestryInRefPopsInput, BroadAncestryCategoryUncheckedCreateWithoutBroadAncestryInRefPopsInput>
  }

  export type ReferencePopulationCreateWithoutBroadAncestryCategoriesInput = {
    name: string
    description?: string | null
    studyURL?: string | null
    assembly: $Enums.AssemblyType
    numberOfindividuals?: number | null
    numberOfvariants?: number | null
    studyName: string
    date: Date | string
    path: string
    prsAnalyses?: PRSAnalysisCreateNestedManyWithoutReferencePopulationInput
  }

  export type ReferencePopulationUncheckedCreateWithoutBroadAncestryCategoriesInput = {
    id?: number
    name: string
    description?: string | null
    studyURL?: string | null
    assembly: $Enums.AssemblyType
    numberOfindividuals?: number | null
    numberOfvariants?: number | null
    studyName: string
    date: Date | string
    path: string
    prsAnalyses?: PRSAnalysisUncheckedCreateNestedManyWithoutReferencePopulationInput
  }

  export type ReferencePopulationCreateOrConnectWithoutBroadAncestryCategoriesInput = {
    where: ReferencePopulationWhereUniqueInput
    create: XOR<ReferencePopulationCreateWithoutBroadAncestryCategoriesInput, ReferencePopulationUncheckedCreateWithoutBroadAncestryCategoriesInput>
  }

  export type BroadAncestryCategoryUpsertWithoutBroadAncestryInRefPopsInput = {
    update: XOR<BroadAncestryCategoryUpdateWithoutBroadAncestryInRefPopsInput, BroadAncestryCategoryUncheckedUpdateWithoutBroadAncestryInRefPopsInput>
    create: XOR<BroadAncestryCategoryCreateWithoutBroadAncestryInRefPopsInput, BroadAncestryCategoryUncheckedCreateWithoutBroadAncestryInRefPopsInput>
    where?: BroadAncestryCategoryWhereInput
  }

  export type BroadAncestryCategoryUpdateToOneWithWhereWithoutBroadAncestryInRefPopsInput = {
    where?: BroadAncestryCategoryWhereInput
    data: XOR<BroadAncestryCategoryUpdateWithoutBroadAncestryInRefPopsInput, BroadAncestryCategoryUncheckedUpdateWithoutBroadAncestryInRefPopsInput>
  }

  export type BroadAncestryCategoryUpdateWithoutBroadAncestryInRefPopsInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    broadAncestryInModels?: BroadAncestryInModelUpdateManyWithoutBroadAncestryCategoryNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUpdateManyWithoutBroadAncestryCategoryNestedInput
    EvaluationPopulationSamples?: EvaluationPopulationSampleUpdateManyWithoutBroadAncestryCategoryNestedInput
  }

  export type BroadAncestryCategoryUncheckedUpdateWithoutBroadAncestryInRefPopsInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    broadAncestryInModels?: BroadAncestryInModelUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput
    EvaluationPopulationSamples?: EvaluationPopulationSampleUncheckedUpdateManyWithoutBroadAncestryCategoryNestedInput
  }

  export type ReferencePopulationUpsertWithoutBroadAncestryCategoriesInput = {
    update: XOR<ReferencePopulationUpdateWithoutBroadAncestryCategoriesInput, ReferencePopulationUncheckedUpdateWithoutBroadAncestryCategoriesInput>
    create: XOR<ReferencePopulationCreateWithoutBroadAncestryCategoriesInput, ReferencePopulationUncheckedCreateWithoutBroadAncestryCategoriesInput>
    where?: ReferencePopulationWhereInput
  }

  export type ReferencePopulationUpdateToOneWithWhereWithoutBroadAncestryCategoriesInput = {
    where?: ReferencePopulationWhereInput
    data: XOR<ReferencePopulationUpdateWithoutBroadAncestryCategoriesInput, ReferencePopulationUncheckedUpdateWithoutBroadAncestryCategoriesInput>
  }

  export type ReferencePopulationUpdateWithoutBroadAncestryCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    studyURL?: NullableStringFieldUpdateOperationsInput | string | null
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    numberOfindividuals?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfvariants?: NullableIntFieldUpdateOperationsInput | number | null
    studyName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: StringFieldUpdateOperationsInput | string
    prsAnalyses?: PRSAnalysisUpdateManyWithoutReferencePopulationNestedInput
  }

  export type ReferencePopulationUncheckedUpdateWithoutBroadAncestryCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    studyURL?: NullableStringFieldUpdateOperationsInput | string | null
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    numberOfindividuals?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfvariants?: NullableIntFieldUpdateOperationsInput | number | null
    studyName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: StringFieldUpdateOperationsInput | string
    prsAnalyses?: PRSAnalysisUncheckedUpdateManyWithoutReferencePopulationNestedInput
  }

  export type BroadAncestryInRefPopCreateWithoutReferencePopulationInput = {
    percentage: number
    broadAncestryCategory: BroadAncestryCategoryCreateNestedOneWithoutBroadAncestryInRefPopsInput
  }

  export type BroadAncestryInRefPopUncheckedCreateWithoutReferencePopulationInput = {
    percentage: number
    broadAncestryId: number
  }

  export type BroadAncestryInRefPopCreateOrConnectWithoutReferencePopulationInput = {
    where: BroadAncestryInRefPopWhereUniqueInput
    create: XOR<BroadAncestryInRefPopCreateWithoutReferencePopulationInput, BroadAncestryInRefPopUncheckedCreateWithoutReferencePopulationInput>
  }

  export type BroadAncestryInRefPopCreateManyReferencePopulationInputEnvelope = {
    data: BroadAncestryInRefPopCreateManyReferencePopulationInput | BroadAncestryInRefPopCreateManyReferencePopulationInput[]
    skipDuplicates?: boolean
  }

  export type PRSAnalysisCreateWithoutReferencePopulationInput = {
    name: string
    description?: string | null
    userId?: string | null
    date: string
    status: string
    HTMLResultPath: string
    ancestryThreshold: number
    overlapThreshold: number
    ancestryAdjustment: $Enums.AncestryAdjustmentType
    assembly: $Enums.AssemblyType
    patient: PatientCreateNestedOneWithoutPrsAnalysesInput
    prioritizedModels?: PrioritizedModelCreateNestedManyWithoutPrsAnalysisInput
  }

  export type PRSAnalysisUncheckedCreateWithoutReferencePopulationInput = {
    id?: number
    name: string
    description?: string | null
    userId?: string | null
    date: string
    status: string
    HTMLResultPath: string
    ancestryThreshold: number
    overlapThreshold: number
    ancestryAdjustment: $Enums.AncestryAdjustmentType
    assembly: $Enums.AssemblyType
    patientId: number
    prioritizedModels?: PrioritizedModelUncheckedCreateNestedManyWithoutPrsAnalysisInput
  }

  export type PRSAnalysisCreateOrConnectWithoutReferencePopulationInput = {
    where: PRSAnalysisWhereUniqueInput
    create: XOR<PRSAnalysisCreateWithoutReferencePopulationInput, PRSAnalysisUncheckedCreateWithoutReferencePopulationInput>
  }

  export type PRSAnalysisCreateManyReferencePopulationInputEnvelope = {
    data: PRSAnalysisCreateManyReferencePopulationInput | PRSAnalysisCreateManyReferencePopulationInput[]
    skipDuplicates?: boolean
  }

  export type BroadAncestryInRefPopUpsertWithWhereUniqueWithoutReferencePopulationInput = {
    where: BroadAncestryInRefPopWhereUniqueInput
    update: XOR<BroadAncestryInRefPopUpdateWithoutReferencePopulationInput, BroadAncestryInRefPopUncheckedUpdateWithoutReferencePopulationInput>
    create: XOR<BroadAncestryInRefPopCreateWithoutReferencePopulationInput, BroadAncestryInRefPopUncheckedCreateWithoutReferencePopulationInput>
  }

  export type BroadAncestryInRefPopUpdateWithWhereUniqueWithoutReferencePopulationInput = {
    where: BroadAncestryInRefPopWhereUniqueInput
    data: XOR<BroadAncestryInRefPopUpdateWithoutReferencePopulationInput, BroadAncestryInRefPopUncheckedUpdateWithoutReferencePopulationInput>
  }

  export type BroadAncestryInRefPopUpdateManyWithWhereWithoutReferencePopulationInput = {
    where: BroadAncestryInRefPopScalarWhereInput
    data: XOR<BroadAncestryInRefPopUpdateManyMutationInput, BroadAncestryInRefPopUncheckedUpdateManyWithoutReferencePopulationInput>
  }

  export type PRSAnalysisUpsertWithWhereUniqueWithoutReferencePopulationInput = {
    where: PRSAnalysisWhereUniqueInput
    update: XOR<PRSAnalysisUpdateWithoutReferencePopulationInput, PRSAnalysisUncheckedUpdateWithoutReferencePopulationInput>
    create: XOR<PRSAnalysisCreateWithoutReferencePopulationInput, PRSAnalysisUncheckedCreateWithoutReferencePopulationInput>
  }

  export type PRSAnalysisUpdateWithWhereUniqueWithoutReferencePopulationInput = {
    where: PRSAnalysisWhereUniqueInput
    data: XOR<PRSAnalysisUpdateWithoutReferencePopulationInput, PRSAnalysisUncheckedUpdateWithoutReferencePopulationInput>
  }

  export type PRSAnalysisUpdateManyWithWhereWithoutReferencePopulationInput = {
    where: PRSAnalysisScalarWhereInput
    data: XOR<PRSAnalysisUpdateManyMutationInput, PRSAnalysisUncheckedUpdateManyWithoutReferencePopulationInput>
  }

  export type PRSAnalysisScalarWhereInput = {
    AND?: PRSAnalysisScalarWhereInput | PRSAnalysisScalarWhereInput[]
    OR?: PRSAnalysisScalarWhereInput[]
    NOT?: PRSAnalysisScalarWhereInput | PRSAnalysisScalarWhereInput[]
    id?: IntFilter<"PRSAnalysis"> | number
    name?: StringFilter<"PRSAnalysis"> | string
    description?: StringNullableFilter<"PRSAnalysis"> | string | null
    userId?: StringNullableFilter<"PRSAnalysis"> | string | null
    date?: StringFilter<"PRSAnalysis"> | string
    status?: StringFilter<"PRSAnalysis"> | string
    HTMLResultPath?: StringFilter<"PRSAnalysis"> | string
    ancestryThreshold?: IntFilter<"PRSAnalysis"> | number
    overlapThreshold?: IntFilter<"PRSAnalysis"> | number
    ancestryAdjustment?: EnumAncestryAdjustmentTypeFilter<"PRSAnalysis"> | $Enums.AncestryAdjustmentType
    assembly?: EnumAssemblyTypeFilter<"PRSAnalysis"> | $Enums.AssemblyType
    patientId?: IntFilter<"PRSAnalysis"> | number
    referencePopulationId?: IntFilter<"PRSAnalysis"> | number
  }

  export type PatientCreateWithoutPrsAnalysesInput = {
    patientId: string
    genotypingMethod?: string | null
    DataFilePath: string
    DataFilteFormat: string
  }

  export type PatientUncheckedCreateWithoutPrsAnalysesInput = {
    id?: number
    patientId: string
    genotypingMethod?: string | null
    DataFilePath: string
    DataFilteFormat: string
  }

  export type PatientCreateOrConnectWithoutPrsAnalysesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPrsAnalysesInput, PatientUncheckedCreateWithoutPrsAnalysesInput>
  }

  export type ReferencePopulationCreateWithoutPrsAnalysesInput = {
    name: string
    description?: string | null
    studyURL?: string | null
    assembly: $Enums.AssemblyType
    numberOfindividuals?: number | null
    numberOfvariants?: number | null
    studyName: string
    date: Date | string
    path: string
    broadAncestryCategories?: BroadAncestryInRefPopCreateNestedManyWithoutReferencePopulationInput
  }

  export type ReferencePopulationUncheckedCreateWithoutPrsAnalysesInput = {
    id?: number
    name: string
    description?: string | null
    studyURL?: string | null
    assembly: $Enums.AssemblyType
    numberOfindividuals?: number | null
    numberOfvariants?: number | null
    studyName: string
    date: Date | string
    path: string
    broadAncestryCategories?: BroadAncestryInRefPopUncheckedCreateNestedManyWithoutReferencePopulationInput
  }

  export type ReferencePopulationCreateOrConnectWithoutPrsAnalysesInput = {
    where: ReferencePopulationWhereUniqueInput
    create: XOR<ReferencePopulationCreateWithoutPrsAnalysesInput, ReferencePopulationUncheckedCreateWithoutPrsAnalysesInput>
  }

  export type PrioritizedModelCreateWithoutPrsAnalysisInput = {
    position: number
    prsResultId?: number | null
    prsResult?: PRSResultCreateNestedOneWithoutPrioritizedModelInput
    prsModel: PRSModelCreateNestedOneWithoutPrioritizedModelsInput
  }

  export type PrioritizedModelUncheckedCreateWithoutPrsAnalysisInput = {
    position: number
    prsModelId: number
    prsResultId?: number | null
    prsResult?: PRSResultUncheckedCreateNestedOneWithoutPrioritizedModelInput
  }

  export type PrioritizedModelCreateOrConnectWithoutPrsAnalysisInput = {
    where: PrioritizedModelWhereUniqueInput
    create: XOR<PrioritizedModelCreateWithoutPrsAnalysisInput, PrioritizedModelUncheckedCreateWithoutPrsAnalysisInput>
  }

  export type PrioritizedModelCreateManyPrsAnalysisInputEnvelope = {
    data: PrioritizedModelCreateManyPrsAnalysisInput | PrioritizedModelCreateManyPrsAnalysisInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutPrsAnalysesInput = {
    update: XOR<PatientUpdateWithoutPrsAnalysesInput, PatientUncheckedUpdateWithoutPrsAnalysesInput>
    create: XOR<PatientCreateWithoutPrsAnalysesInput, PatientUncheckedCreateWithoutPrsAnalysesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPrsAnalysesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPrsAnalysesInput, PatientUncheckedUpdateWithoutPrsAnalysesInput>
  }

  export type PatientUpdateWithoutPrsAnalysesInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    genotypingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    DataFilePath?: StringFieldUpdateOperationsInput | string
    DataFilteFormat?: StringFieldUpdateOperationsInput | string
  }

  export type PatientUncheckedUpdateWithoutPrsAnalysesInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    genotypingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    DataFilePath?: StringFieldUpdateOperationsInput | string
    DataFilteFormat?: StringFieldUpdateOperationsInput | string
  }

  export type ReferencePopulationUpsertWithoutPrsAnalysesInput = {
    update: XOR<ReferencePopulationUpdateWithoutPrsAnalysesInput, ReferencePopulationUncheckedUpdateWithoutPrsAnalysesInput>
    create: XOR<ReferencePopulationCreateWithoutPrsAnalysesInput, ReferencePopulationUncheckedCreateWithoutPrsAnalysesInput>
    where?: ReferencePopulationWhereInput
  }

  export type ReferencePopulationUpdateToOneWithWhereWithoutPrsAnalysesInput = {
    where?: ReferencePopulationWhereInput
    data: XOR<ReferencePopulationUpdateWithoutPrsAnalysesInput, ReferencePopulationUncheckedUpdateWithoutPrsAnalysesInput>
  }

  export type ReferencePopulationUpdateWithoutPrsAnalysesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    studyURL?: NullableStringFieldUpdateOperationsInput | string | null
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    numberOfindividuals?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfvariants?: NullableIntFieldUpdateOperationsInput | number | null
    studyName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: StringFieldUpdateOperationsInput | string
    broadAncestryCategories?: BroadAncestryInRefPopUpdateManyWithoutReferencePopulationNestedInput
  }

  export type ReferencePopulationUncheckedUpdateWithoutPrsAnalysesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    studyURL?: NullableStringFieldUpdateOperationsInput | string | null
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    numberOfindividuals?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfvariants?: NullableIntFieldUpdateOperationsInput | number | null
    studyName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: StringFieldUpdateOperationsInput | string
    broadAncestryCategories?: BroadAncestryInRefPopUncheckedUpdateManyWithoutReferencePopulationNestedInput
  }

  export type PrioritizedModelUpsertWithWhereUniqueWithoutPrsAnalysisInput = {
    where: PrioritizedModelWhereUniqueInput
    update: XOR<PrioritizedModelUpdateWithoutPrsAnalysisInput, PrioritizedModelUncheckedUpdateWithoutPrsAnalysisInput>
    create: XOR<PrioritizedModelCreateWithoutPrsAnalysisInput, PrioritizedModelUncheckedCreateWithoutPrsAnalysisInput>
  }

  export type PrioritizedModelUpdateWithWhereUniqueWithoutPrsAnalysisInput = {
    where: PrioritizedModelWhereUniqueInput
    data: XOR<PrioritizedModelUpdateWithoutPrsAnalysisInput, PrioritizedModelUncheckedUpdateWithoutPrsAnalysisInput>
  }

  export type PrioritizedModelUpdateManyWithWhereWithoutPrsAnalysisInput = {
    where: PrioritizedModelScalarWhereInput
    data: XOR<PrioritizedModelUpdateManyMutationInput, PrioritizedModelUncheckedUpdateManyWithoutPrsAnalysisInput>
  }

  export type PRSResultCreateWithoutPrioritizedModelInput = {
    prs: number
    percentile: string
    overlapPercent: number
  }

  export type PRSResultUncheckedCreateWithoutPrioritizedModelInput = {
    id?: number
    prs: number
    percentile: string
    overlapPercent: number
  }

  export type PRSResultCreateOrConnectWithoutPrioritizedModelInput = {
    where: PRSResultWhereUniqueInput
    create: XOR<PRSResultCreateWithoutPrioritizedModelInput, PRSResultUncheckedCreateWithoutPrioritizedModelInput>
  }

  export type PRSAnalysisCreateWithoutPrioritizedModelsInput = {
    name: string
    description?: string | null
    userId?: string | null
    date: string
    status: string
    HTMLResultPath: string
    ancestryThreshold: number
    overlapThreshold: number
    ancestryAdjustment: $Enums.AncestryAdjustmentType
    assembly: $Enums.AssemblyType
    patient: PatientCreateNestedOneWithoutPrsAnalysesInput
    referencePopulation: ReferencePopulationCreateNestedOneWithoutPrsAnalysesInput
  }

  export type PRSAnalysisUncheckedCreateWithoutPrioritizedModelsInput = {
    id?: number
    name: string
    description?: string | null
    userId?: string | null
    date: string
    status: string
    HTMLResultPath: string
    ancestryThreshold: number
    overlapThreshold: number
    ancestryAdjustment: $Enums.AncestryAdjustmentType
    assembly: $Enums.AssemblyType
    patientId: number
    referencePopulationId: number
  }

  export type PRSAnalysisCreateOrConnectWithoutPrioritizedModelsInput = {
    where: PRSAnalysisWhereUniqueInput
    create: XOR<PRSAnalysisCreateWithoutPrioritizedModelsInput, PRSAnalysisUncheckedCreateWithoutPrioritizedModelsInput>
  }

  export type PRSModelCreateWithoutPrioritizedModelsInput = {
    name: string
    numberOfSNP?: number | null
    pgscId?: string | null
    pgscURL?: string | null
    broadAncestryCategories?: BroadAncestryInModelCreateNestedManyWithoutPrsModelInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleCreateNestedManyWithoutPrsModelInput
    modelEvaluations?: ModelEvaluationCreateNestedManyWithoutPrsModelInput
    publication: PublicationCreateNestedOneWithoutPrsModelsInput
    traits?: PRSModelToTraitCreateNestedManyWithoutPrsModelInput
    scoringFiles?: ScoringFileCreateNestedOneWithoutPrsModelInput
  }

  export type PRSModelUncheckedCreateWithoutPrioritizedModelsInput = {
    id?: number
    name: string
    numberOfSNP?: number | null
    pgscId?: string | null
    pgscURL?: string | null
    publicationId: number
    broadAncestryCategories?: BroadAncestryInModelUncheckedCreateNestedManyWithoutPrsModelInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedCreateNestedManyWithoutPrsModelInput
    modelEvaluations?: ModelEvaluationUncheckedCreateNestedManyWithoutPrsModelInput
    traits?: PRSModelToTraitUncheckedCreateNestedManyWithoutPrsModelInput
    scoringFiles?: ScoringFileUncheckedCreateNestedOneWithoutPrsModelInput
  }

  export type PRSModelCreateOrConnectWithoutPrioritizedModelsInput = {
    where: PRSModelWhereUniqueInput
    create: XOR<PRSModelCreateWithoutPrioritizedModelsInput, PRSModelUncheckedCreateWithoutPrioritizedModelsInput>
  }

  export type PRSResultUpsertWithoutPrioritizedModelInput = {
    update: XOR<PRSResultUpdateWithoutPrioritizedModelInput, PRSResultUncheckedUpdateWithoutPrioritizedModelInput>
    create: XOR<PRSResultCreateWithoutPrioritizedModelInput, PRSResultUncheckedCreateWithoutPrioritizedModelInput>
    where?: PRSResultWhereInput
  }

  export type PRSResultUpdateToOneWithWhereWithoutPrioritizedModelInput = {
    where?: PRSResultWhereInput
    data: XOR<PRSResultUpdateWithoutPrioritizedModelInput, PRSResultUncheckedUpdateWithoutPrioritizedModelInput>
  }

  export type PRSResultUpdateWithoutPrioritizedModelInput = {
    prs?: FloatFieldUpdateOperationsInput | number
    percentile?: StringFieldUpdateOperationsInput | string
    overlapPercent?: FloatFieldUpdateOperationsInput | number
  }

  export type PRSResultUncheckedUpdateWithoutPrioritizedModelInput = {
    id?: IntFieldUpdateOperationsInput | number
    prs?: FloatFieldUpdateOperationsInput | number
    percentile?: StringFieldUpdateOperationsInput | string
    overlapPercent?: FloatFieldUpdateOperationsInput | number
  }

  export type PRSAnalysisUpsertWithoutPrioritizedModelsInput = {
    update: XOR<PRSAnalysisUpdateWithoutPrioritizedModelsInput, PRSAnalysisUncheckedUpdateWithoutPrioritizedModelsInput>
    create: XOR<PRSAnalysisCreateWithoutPrioritizedModelsInput, PRSAnalysisUncheckedCreateWithoutPrioritizedModelsInput>
    where?: PRSAnalysisWhereInput
  }

  export type PRSAnalysisUpdateToOneWithWhereWithoutPrioritizedModelsInput = {
    where?: PRSAnalysisWhereInput
    data: XOR<PRSAnalysisUpdateWithoutPrioritizedModelsInput, PRSAnalysisUncheckedUpdateWithoutPrioritizedModelsInput>
  }

  export type PRSAnalysisUpdateWithoutPrioritizedModelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    HTMLResultPath?: StringFieldUpdateOperationsInput | string
    ancestryThreshold?: IntFieldUpdateOperationsInput | number
    overlapThreshold?: IntFieldUpdateOperationsInput | number
    ancestryAdjustment?: EnumAncestryAdjustmentTypeFieldUpdateOperationsInput | $Enums.AncestryAdjustmentType
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    patient?: PatientUpdateOneRequiredWithoutPrsAnalysesNestedInput
    referencePopulation?: ReferencePopulationUpdateOneRequiredWithoutPrsAnalysesNestedInput
  }

  export type PRSAnalysisUncheckedUpdateWithoutPrioritizedModelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    HTMLResultPath?: StringFieldUpdateOperationsInput | string
    ancestryThreshold?: IntFieldUpdateOperationsInput | number
    overlapThreshold?: IntFieldUpdateOperationsInput | number
    ancestryAdjustment?: EnumAncestryAdjustmentTypeFieldUpdateOperationsInput | $Enums.AncestryAdjustmentType
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    patientId?: IntFieldUpdateOperationsInput | number
    referencePopulationId?: IntFieldUpdateOperationsInput | number
  }

  export type PRSModelUpsertWithoutPrioritizedModelsInput = {
    update: XOR<PRSModelUpdateWithoutPrioritizedModelsInput, PRSModelUncheckedUpdateWithoutPrioritizedModelsInput>
    create: XOR<PRSModelCreateWithoutPrioritizedModelsInput, PRSModelUncheckedCreateWithoutPrioritizedModelsInput>
    where?: PRSModelWhereInput
  }

  export type PRSModelUpdateToOneWithWhereWithoutPrioritizedModelsInput = {
    where?: PRSModelWhereInput
    data: XOR<PRSModelUpdateWithoutPrioritizedModelsInput, PRSModelUncheckedUpdateWithoutPrioritizedModelsInput>
  }

  export type PRSModelUpdateWithoutPrioritizedModelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
    broadAncestryCategories?: BroadAncestryInModelUpdateManyWithoutPrsModelNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUpdateManyWithoutPrsModelNestedInput
    modelEvaluations?: ModelEvaluationUpdateManyWithoutPrsModelNestedInput
    publication?: PublicationUpdateOneRequiredWithoutPrsModelsNestedInput
    traits?: PRSModelToTraitUpdateManyWithoutPrsModelNestedInput
    scoringFiles?: ScoringFileUpdateOneWithoutPrsModelNestedInput
  }

  export type PRSModelUncheckedUpdateWithoutPrioritizedModelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
    publicationId?: IntFieldUpdateOperationsInput | number
    broadAncestryCategories?: BroadAncestryInModelUncheckedUpdateManyWithoutPrsModelNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedUpdateManyWithoutPrsModelNestedInput
    modelEvaluations?: ModelEvaluationUncheckedUpdateManyWithoutPrsModelNestedInput
    traits?: PRSModelToTraitUncheckedUpdateManyWithoutPrsModelNestedInput
    scoringFiles?: ScoringFileUncheckedUpdateOneWithoutPrsModelNestedInput
  }

  export type PrioritizedModelCreateWithoutPrsResultInput = {
    position: number
    prsResultId?: number | null
    prsAnalysis: PRSAnalysisCreateNestedOneWithoutPrioritizedModelsInput
    prsModel: PRSModelCreateNestedOneWithoutPrioritizedModelsInput
  }

  export type PrioritizedModelUncheckedCreateWithoutPrsResultInput = {
    position: number
    prsModelId: number
    prsAnalysisId: number
    prsResultId?: number | null
  }

  export type PrioritizedModelCreateOrConnectWithoutPrsResultInput = {
    where: PrioritizedModelWhereUniqueInput
    create: XOR<PrioritizedModelCreateWithoutPrsResultInput, PrioritizedModelUncheckedCreateWithoutPrsResultInput>
  }

  export type PrioritizedModelUpsertWithoutPrsResultInput = {
    update: XOR<PrioritizedModelUpdateWithoutPrsResultInput, PrioritizedModelUncheckedUpdateWithoutPrsResultInput>
    create: XOR<PrioritizedModelCreateWithoutPrsResultInput, PrioritizedModelUncheckedCreateWithoutPrsResultInput>
    where?: PrioritizedModelWhereInput
  }

  export type PrioritizedModelUpdateToOneWithWhereWithoutPrsResultInput = {
    where?: PrioritizedModelWhereInput
    data: XOR<PrioritizedModelUpdateWithoutPrsResultInput, PrioritizedModelUncheckedUpdateWithoutPrsResultInput>
  }

  export type PrioritizedModelUpdateWithoutPrsResultInput = {
    position?: IntFieldUpdateOperationsInput | number
    prsResultId?: NullableIntFieldUpdateOperationsInput | number | null
    prsAnalysis?: PRSAnalysisUpdateOneRequiredWithoutPrioritizedModelsNestedInput
    prsModel?: PRSModelUpdateOneRequiredWithoutPrioritizedModelsNestedInput
  }

  export type PrioritizedModelUncheckedUpdateWithoutPrsResultInput = {
    position?: IntFieldUpdateOperationsInput | number
    prsModelId?: IntFieldUpdateOperationsInput | number
    prsAnalysisId?: IntFieldUpdateOperationsInput | number
    prsResultId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PRSAnalysisCreateWithoutPatientInput = {
    name: string
    description?: string | null
    userId?: string | null
    date: string
    status: string
    HTMLResultPath: string
    ancestryThreshold: number
    overlapThreshold: number
    ancestryAdjustment: $Enums.AncestryAdjustmentType
    assembly: $Enums.AssemblyType
    referencePopulation: ReferencePopulationCreateNestedOneWithoutPrsAnalysesInput
    prioritizedModels?: PrioritizedModelCreateNestedManyWithoutPrsAnalysisInput
  }

  export type PRSAnalysisUncheckedCreateWithoutPatientInput = {
    id?: number
    name: string
    description?: string | null
    userId?: string | null
    date: string
    status: string
    HTMLResultPath: string
    ancestryThreshold: number
    overlapThreshold: number
    ancestryAdjustment: $Enums.AncestryAdjustmentType
    assembly: $Enums.AssemblyType
    referencePopulationId: number
    prioritizedModels?: PrioritizedModelUncheckedCreateNestedManyWithoutPrsAnalysisInput
  }

  export type PRSAnalysisCreateOrConnectWithoutPatientInput = {
    where: PRSAnalysisWhereUniqueInput
    create: XOR<PRSAnalysisCreateWithoutPatientInput, PRSAnalysisUncheckedCreateWithoutPatientInput>
  }

  export type PRSAnalysisCreateManyPatientInputEnvelope = {
    data: PRSAnalysisCreateManyPatientInput | PRSAnalysisCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PRSAnalysisUpsertWithWhereUniqueWithoutPatientInput = {
    where: PRSAnalysisWhereUniqueInput
    update: XOR<PRSAnalysisUpdateWithoutPatientInput, PRSAnalysisUncheckedUpdateWithoutPatientInput>
    create: XOR<PRSAnalysisCreateWithoutPatientInput, PRSAnalysisUncheckedCreateWithoutPatientInput>
  }

  export type PRSAnalysisUpdateWithWhereUniqueWithoutPatientInput = {
    where: PRSAnalysisWhereUniqueInput
    data: XOR<PRSAnalysisUpdateWithoutPatientInput, PRSAnalysisUncheckedUpdateWithoutPatientInput>
  }

  export type PRSAnalysisUpdateManyWithWhereWithoutPatientInput = {
    where: PRSAnalysisScalarWhereInput
    data: XOR<PRSAnalysisUpdateManyMutationInput, PRSAnalysisUncheckedUpdateManyWithoutPatientInput>
  }

  export type TraitToTraitCategoryCreateManyTraitCategoryInput = {
    traitId: number
  }

  export type TraitToTraitCategoryUpdateWithoutTraitCategoryInput = {
    trait?: TraitUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type TraitToTraitCategoryUncheckedUpdateWithoutTraitCategoryInput = {
    traitId?: IntFieldUpdateOperationsInput | number
  }

  export type TraitToTraitCategoryUncheckedUpdateManyWithoutTraitCategoryInput = {
    traitId?: IntFieldUpdateOperationsInput | number
  }

  export type PRSModelToTraitCreateManyTraitInput = {
    prsModelId: number
  }

  export type TraitToTraitCategoryCreateManyTraitInput = {
    traitCategoryId: number
  }

  export type PRSModelToTraitUpdateWithoutTraitInput = {
    prsModel?: PRSModelUpdateOneRequiredWithoutTraitsNestedInput
  }

  export type PRSModelToTraitUncheckedUpdateWithoutTraitInput = {
    prsModelId?: IntFieldUpdateOperationsInput | number
  }

  export type PRSModelToTraitUncheckedUpdateManyWithoutTraitInput = {
    prsModelId?: IntFieldUpdateOperationsInput | number
  }

  export type TraitToTraitCategoryUpdateWithoutTraitInput = {
    traitCategory?: TraitCategoryUpdateOneRequiredWithoutTraitsNestedInput
  }

  export type TraitToTraitCategoryUncheckedUpdateWithoutTraitInput = {
    traitCategoryId?: IntFieldUpdateOperationsInput | number
  }

  export type TraitToTraitCategoryUncheckedUpdateManyWithoutTraitInput = {
    traitCategoryId?: IntFieldUpdateOperationsInput | number
  }

  export type BroadAncestryInModelCreateManyPrsModelInput = {
    percentage: number
    broadAncestryId: number
  }

  export type DevelopmentPopulationSampleCreateManyPrsModelInput = {
    id?: number
    numberOfIndividuals?: number | null
    numberOfCases?: number | null
    numberOfControls?: number | null
    percentMale?: number | null
    age?: number | null
    ageUnits?: string | null
    ancestryBroad: string
    ancestryDetails?: string | null
    cohort: string
    gcId?: string | null
    sourcePMID?: string | null
    sourceDOI?: string | null
    role: $Enums.DevelopmentRoleType
    broadAncestryId: number
  }

  export type ModelEvaluationCreateManyPrsModelInput = {
    id?: number
    reportedTrait: string
    covariates?: string | null
    ppmId?: string | null
    publicationId: number
    evaluationPopulationSampleId: number
  }

  export type PRSModelToTraitCreateManyPrsModelInput = {
    traitId: number
  }

  export type PrioritizedModelCreateManyPrsModelInput = {
    position: number
    prsAnalysisId: number
    prsResultId?: number | null
  }

  export type BroadAncestryInModelUpdateWithoutPrsModelInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    broadAncestryCategory?: BroadAncestryCategoryUpdateOneRequiredWithoutBroadAncestryInModelsNestedInput
  }

  export type BroadAncestryInModelUncheckedUpdateWithoutPrsModelInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    broadAncestryId?: IntFieldUpdateOperationsInput | number
  }

  export type BroadAncestryInModelUncheckedUpdateManyWithoutPrsModelInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    broadAncestryId?: IntFieldUpdateOperationsInput | number
  }

  export type DevelopmentPopulationSampleUpdateWithoutPrsModelInput = {
    numberOfIndividuals?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumDevelopmentRoleTypeFieldUpdateOperationsInput | $Enums.DevelopmentRoleType
    broadAncestryCategory?: BroadAncestryCategoryUpdateOneRequiredWithoutDevelopmentPopulationSamplesNestedInput
  }

  export type DevelopmentPopulationSampleUncheckedUpdateWithoutPrsModelInput = {
    id?: IntFieldUpdateOperationsInput | number
    numberOfIndividuals?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumDevelopmentRoleTypeFieldUpdateOperationsInput | $Enums.DevelopmentRoleType
    broadAncestryId?: IntFieldUpdateOperationsInput | number
  }

  export type DevelopmentPopulationSampleUncheckedUpdateManyWithoutPrsModelInput = {
    id?: IntFieldUpdateOperationsInput | number
    numberOfIndividuals?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumDevelopmentRoleTypeFieldUpdateOperationsInput | $Enums.DevelopmentRoleType
    broadAncestryId?: IntFieldUpdateOperationsInput | number
  }

  export type ModelEvaluationUpdateWithoutPrsModelInput = {
    reportedTrait?: StringFieldUpdateOperationsInput | string
    covariates?: NullableStringFieldUpdateOperationsInput | string | null
    ppmId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationPopulationSample?: EvaluationPopulationSampleUpdateOneRequiredWithoutModelEvaluationsNestedInput
    publication?: PublicationUpdateOneRequiredWithoutModelEvaluationsNestedInput
    metricEvaluations?: PerformanceMetricEvaluationUpdateManyWithoutModelEvaluationNestedInput
  }

  export type ModelEvaluationUncheckedUpdateWithoutPrsModelInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedTrait?: StringFieldUpdateOperationsInput | string
    covariates?: NullableStringFieldUpdateOperationsInput | string | null
    ppmId?: NullableStringFieldUpdateOperationsInput | string | null
    publicationId?: IntFieldUpdateOperationsInput | number
    evaluationPopulationSampleId?: IntFieldUpdateOperationsInput | number
    metricEvaluations?: PerformanceMetricEvaluationUncheckedUpdateManyWithoutModelEvaluationNestedInput
  }

  export type ModelEvaluationUncheckedUpdateManyWithoutPrsModelInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedTrait?: StringFieldUpdateOperationsInput | string
    covariates?: NullableStringFieldUpdateOperationsInput | string | null
    ppmId?: NullableStringFieldUpdateOperationsInput | string | null
    publicationId?: IntFieldUpdateOperationsInput | number
    evaluationPopulationSampleId?: IntFieldUpdateOperationsInput | number
  }

  export type PRSModelToTraitUpdateWithoutPrsModelInput = {
    trait?: TraitUpdateOneRequiredWithoutPrsModelsNestedInput
  }

  export type PRSModelToTraitUncheckedUpdateWithoutPrsModelInput = {
    traitId?: IntFieldUpdateOperationsInput | number
  }

  export type PRSModelToTraitUncheckedUpdateManyWithoutPrsModelInput = {
    traitId?: IntFieldUpdateOperationsInput | number
  }

  export type PrioritizedModelUpdateWithoutPrsModelInput = {
    position?: IntFieldUpdateOperationsInput | number
    prsResultId?: NullableIntFieldUpdateOperationsInput | number | null
    prsResult?: PRSResultUpdateOneWithoutPrioritizedModelNestedInput
    prsAnalysis?: PRSAnalysisUpdateOneRequiredWithoutPrioritizedModelsNestedInput
  }

  export type PrioritizedModelUncheckedUpdateWithoutPrsModelInput = {
    position?: IntFieldUpdateOperationsInput | number
    prsAnalysisId?: IntFieldUpdateOperationsInput | number
    prsResultId?: NullableIntFieldUpdateOperationsInput | number | null
    prsResult?: PRSResultUncheckedUpdateOneWithoutPrioritizedModelNestedInput
  }

  export type PrioritizedModelUncheckedUpdateManyWithoutPrsModelInput = {
    position?: IntFieldUpdateOperationsInput | number
    prsAnalysisId?: IntFieldUpdateOperationsInput | number
    prsResultId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ModelEvaluationCreateManyPublicationInput = {
    id?: number
    reportedTrait: string
    covariates?: string | null
    ppmId?: string | null
    prsModelId: number
    evaluationPopulationSampleId: number
  }

  export type PRSModelCreateManyPublicationInput = {
    id?: number
    name: string
    numberOfSNP?: number | null
    pgscId?: string | null
    pgscURL?: string | null
  }

  export type ModelEvaluationUpdateWithoutPublicationInput = {
    reportedTrait?: StringFieldUpdateOperationsInput | string
    covariates?: NullableStringFieldUpdateOperationsInput | string | null
    ppmId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationPopulationSample?: EvaluationPopulationSampleUpdateOneRequiredWithoutModelEvaluationsNestedInput
    prsModel?: PRSModelUpdateOneRequiredWithoutModelEvaluationsNestedInput
    metricEvaluations?: PerformanceMetricEvaluationUpdateManyWithoutModelEvaluationNestedInput
  }

  export type ModelEvaluationUncheckedUpdateWithoutPublicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedTrait?: StringFieldUpdateOperationsInput | string
    covariates?: NullableStringFieldUpdateOperationsInput | string | null
    ppmId?: NullableStringFieldUpdateOperationsInput | string | null
    prsModelId?: IntFieldUpdateOperationsInput | number
    evaluationPopulationSampleId?: IntFieldUpdateOperationsInput | number
    metricEvaluations?: PerformanceMetricEvaluationUncheckedUpdateManyWithoutModelEvaluationNestedInput
  }

  export type ModelEvaluationUncheckedUpdateManyWithoutPublicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedTrait?: StringFieldUpdateOperationsInput | string
    covariates?: NullableStringFieldUpdateOperationsInput | string | null
    ppmId?: NullableStringFieldUpdateOperationsInput | string | null
    prsModelId?: IntFieldUpdateOperationsInput | number
    evaluationPopulationSampleId?: IntFieldUpdateOperationsInput | number
  }

  export type PRSModelUpdateWithoutPublicationInput = {
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
    broadAncestryCategories?: BroadAncestryInModelUpdateManyWithoutPrsModelNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUpdateManyWithoutPrsModelNestedInput
    modelEvaluations?: ModelEvaluationUpdateManyWithoutPrsModelNestedInput
    traits?: PRSModelToTraitUpdateManyWithoutPrsModelNestedInput
    prioritizedModels?: PrioritizedModelUpdateManyWithoutPrsModelNestedInput
    scoringFiles?: ScoringFileUpdateOneWithoutPrsModelNestedInput
  }

  export type PRSModelUncheckedUpdateWithoutPublicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
    broadAncestryCategories?: BroadAncestryInModelUncheckedUpdateManyWithoutPrsModelNestedInput
    DevelopmentPopulationSamples?: DevelopmentPopulationSampleUncheckedUpdateManyWithoutPrsModelNestedInput
    modelEvaluations?: ModelEvaluationUncheckedUpdateManyWithoutPrsModelNestedInput
    traits?: PRSModelToTraitUncheckedUpdateManyWithoutPrsModelNestedInput
    prioritizedModels?: PrioritizedModelUncheckedUpdateManyWithoutPrsModelNestedInput
    scoringFiles?: ScoringFileUncheckedUpdateOneWithoutPrsModelNestedInput
  }

  export type PRSModelUncheckedUpdateManyWithoutPublicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberOfSNP?: NullableIntFieldUpdateOperationsInput | number | null
    pgscId?: NullableStringFieldUpdateOperationsInput | string | null
    pgscURL?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PerformanceMetricEvaluationCreateManyModelEvaluationInput = {
    id?: number
    estimate: number
    CILower?: number | null
    CIUpper?: number | null
    performanceMetricId: number
  }

  export type PerformanceMetricEvaluationUpdateWithoutModelEvaluationInput = {
    estimate?: FloatFieldUpdateOperationsInput | number
    CILower?: NullableFloatFieldUpdateOperationsInput | number | null
    CIUpper?: NullableFloatFieldUpdateOperationsInput | number | null
    performanceMetric?: PerformanceMetricUpdateOneRequiredWithoutPerformanceMetricEvaluationsNestedInput
  }

  export type PerformanceMetricEvaluationUncheckedUpdateWithoutModelEvaluationInput = {
    id?: IntFieldUpdateOperationsInput | number
    estimate?: FloatFieldUpdateOperationsInput | number
    CILower?: NullableFloatFieldUpdateOperationsInput | number | null
    CIUpper?: NullableFloatFieldUpdateOperationsInput | number | null
    performanceMetricId?: IntFieldUpdateOperationsInput | number
  }

  export type PerformanceMetricEvaluationUncheckedUpdateManyWithoutModelEvaluationInput = {
    id?: IntFieldUpdateOperationsInput | number
    estimate?: FloatFieldUpdateOperationsInput | number
    CILower?: NullableFloatFieldUpdateOperationsInput | number | null
    CIUpper?: NullableFloatFieldUpdateOperationsInput | number | null
    performanceMetricId?: IntFieldUpdateOperationsInput | number
  }

  export type PerformanceMetricEvaluationCreateManyPerformanceMetricInput = {
    id?: number
    estimate: number
    CILower?: number | null
    CIUpper?: number | null
    modelEvaluationId: number
  }

  export type PerformanceMetricEvaluationUpdateWithoutPerformanceMetricInput = {
    estimate?: FloatFieldUpdateOperationsInput | number
    CILower?: NullableFloatFieldUpdateOperationsInput | number | null
    CIUpper?: NullableFloatFieldUpdateOperationsInput | number | null
    modelEvaluation?: ModelEvaluationUpdateOneRequiredWithoutMetricEvaluationsNestedInput
  }

  export type PerformanceMetricEvaluationUncheckedUpdateWithoutPerformanceMetricInput = {
    id?: IntFieldUpdateOperationsInput | number
    estimate?: FloatFieldUpdateOperationsInput | number
    CILower?: NullableFloatFieldUpdateOperationsInput | number | null
    CIUpper?: NullableFloatFieldUpdateOperationsInput | number | null
    modelEvaluationId?: IntFieldUpdateOperationsInput | number
  }

  export type PerformanceMetricEvaluationUncheckedUpdateManyWithoutPerformanceMetricInput = {
    id?: IntFieldUpdateOperationsInput | number
    estimate?: FloatFieldUpdateOperationsInput | number
    CILower?: NullableFloatFieldUpdateOperationsInput | number | null
    CIUpper?: NullableFloatFieldUpdateOperationsInput | number | null
    modelEvaluationId?: IntFieldUpdateOperationsInput | number
  }

  export type ModelEvaluationCreateManyEvaluationPopulationSampleInput = {
    id?: number
    reportedTrait: string
    covariates?: string | null
    ppmId?: string | null
    prsModelId: number
    publicationId: number
  }

  export type ModelEvaluationUpdateWithoutEvaluationPopulationSampleInput = {
    reportedTrait?: StringFieldUpdateOperationsInput | string
    covariates?: NullableStringFieldUpdateOperationsInput | string | null
    ppmId?: NullableStringFieldUpdateOperationsInput | string | null
    prsModel?: PRSModelUpdateOneRequiredWithoutModelEvaluationsNestedInput
    publication?: PublicationUpdateOneRequiredWithoutModelEvaluationsNestedInput
    metricEvaluations?: PerformanceMetricEvaluationUpdateManyWithoutModelEvaluationNestedInput
  }

  export type ModelEvaluationUncheckedUpdateWithoutEvaluationPopulationSampleInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedTrait?: StringFieldUpdateOperationsInput | string
    covariates?: NullableStringFieldUpdateOperationsInput | string | null
    ppmId?: NullableStringFieldUpdateOperationsInput | string | null
    prsModelId?: IntFieldUpdateOperationsInput | number
    publicationId?: IntFieldUpdateOperationsInput | number
    metricEvaluations?: PerformanceMetricEvaluationUncheckedUpdateManyWithoutModelEvaluationNestedInput
  }

  export type ModelEvaluationUncheckedUpdateManyWithoutEvaluationPopulationSampleInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedTrait?: StringFieldUpdateOperationsInput | string
    covariates?: NullableStringFieldUpdateOperationsInput | string | null
    ppmId?: NullableStringFieldUpdateOperationsInput | string | null
    prsModelId?: IntFieldUpdateOperationsInput | number
    publicationId?: IntFieldUpdateOperationsInput | number
  }

  export type BroadAncestryInModelCreateManyBroadAncestryCategoryInput = {
    percentage: number
    prsModelId: number
  }

  export type BroadAncestryInRefPopCreateManyBroadAncestryCategoryInput = {
    percentage: number
    referencePopulationId: number
  }

  export type DevelopmentPopulationSampleCreateManyBroadAncestryCategoryInput = {
    id?: number
    numberOfIndividuals?: number | null
    numberOfCases?: number | null
    numberOfControls?: number | null
    percentMale?: number | null
    age?: number | null
    ageUnits?: string | null
    ancestryBroad: string
    ancestryDetails?: string | null
    cohort: string
    gcId?: string | null
    sourcePMID?: string | null
    sourceDOI?: string | null
    role: $Enums.DevelopmentRoleType
    prsModelId: number
  }

  export type EvaluationPopulationSampleCreateManyBroadAncestryCategoryInput = {
    id?: number
    numberOfIndividuals: number
    numberOfCases?: number | null
    numberOfControls?: number | null
    percentMale?: number | null
    age?: number | null
    ageUnits?: string | null
    ancestryBroad: string
    ancestryDetails?: string | null
    cohort: string
    gcId?: string | null
    sourcePMID?: string | null
    sourceDOI?: string | null
    phenotypeFree?: string | null
    pssId: string
  }

  export type BroadAncestryInModelUpdateWithoutBroadAncestryCategoryInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    prsModel?: PRSModelUpdateOneRequiredWithoutBroadAncestryCategoriesNestedInput
  }

  export type BroadAncestryInModelUncheckedUpdateWithoutBroadAncestryCategoryInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    prsModelId?: IntFieldUpdateOperationsInput | number
  }

  export type BroadAncestryInModelUncheckedUpdateManyWithoutBroadAncestryCategoryInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    prsModelId?: IntFieldUpdateOperationsInput | number
  }

  export type BroadAncestryInRefPopUpdateWithoutBroadAncestryCategoryInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    referencePopulation?: ReferencePopulationUpdateOneRequiredWithoutBroadAncestryCategoriesNestedInput
  }

  export type BroadAncestryInRefPopUncheckedUpdateWithoutBroadAncestryCategoryInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    referencePopulationId?: IntFieldUpdateOperationsInput | number
  }

  export type BroadAncestryInRefPopUncheckedUpdateManyWithoutBroadAncestryCategoryInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    referencePopulationId?: IntFieldUpdateOperationsInput | number
  }

  export type DevelopmentPopulationSampleUpdateWithoutBroadAncestryCategoryInput = {
    numberOfIndividuals?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumDevelopmentRoleTypeFieldUpdateOperationsInput | $Enums.DevelopmentRoleType
    prsModel?: PRSModelUpdateOneRequiredWithoutDevelopmentPopulationSamplesNestedInput
  }

  export type DevelopmentPopulationSampleUncheckedUpdateWithoutBroadAncestryCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    numberOfIndividuals?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumDevelopmentRoleTypeFieldUpdateOperationsInput | $Enums.DevelopmentRoleType
    prsModelId?: IntFieldUpdateOperationsInput | number
  }

  export type DevelopmentPopulationSampleUncheckedUpdateManyWithoutBroadAncestryCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    numberOfIndividuals?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumDevelopmentRoleTypeFieldUpdateOperationsInput | $Enums.DevelopmentRoleType
    prsModelId?: IntFieldUpdateOperationsInput | number
  }

  export type EvaluationPopulationSampleUpdateWithoutBroadAncestryCategoryInput = {
    numberOfIndividuals?: IntFieldUpdateOperationsInput | number
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    phenotypeFree?: NullableStringFieldUpdateOperationsInput | string | null
    pssId?: StringFieldUpdateOperationsInput | string
    modelEvaluations?: ModelEvaluationUpdateManyWithoutEvaluationPopulationSampleNestedInput
  }

  export type EvaluationPopulationSampleUncheckedUpdateWithoutBroadAncestryCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    numberOfIndividuals?: IntFieldUpdateOperationsInput | number
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    phenotypeFree?: NullableStringFieldUpdateOperationsInput | string | null
    pssId?: StringFieldUpdateOperationsInput | string
    modelEvaluations?: ModelEvaluationUncheckedUpdateManyWithoutEvaluationPopulationSampleNestedInput
  }

  export type EvaluationPopulationSampleUncheckedUpdateManyWithoutBroadAncestryCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    numberOfIndividuals?: IntFieldUpdateOperationsInput | number
    numberOfCases?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfControls?: NullableIntFieldUpdateOperationsInput | number | null
    percentMale?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    ageUnits?: NullableStringFieldUpdateOperationsInput | string | null
    ancestryBroad?: StringFieldUpdateOperationsInput | string
    ancestryDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cohort?: StringFieldUpdateOperationsInput | string
    gcId?: NullableStringFieldUpdateOperationsInput | string | null
    sourcePMID?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDOI?: NullableStringFieldUpdateOperationsInput | string | null
    phenotypeFree?: NullableStringFieldUpdateOperationsInput | string | null
    pssId?: StringFieldUpdateOperationsInput | string
  }

  export type BroadAncestryInRefPopCreateManyReferencePopulationInput = {
    percentage: number
    broadAncestryId: number
  }

  export type PRSAnalysisCreateManyReferencePopulationInput = {
    id?: number
    name: string
    description?: string | null
    userId?: string | null
    date: string
    status: string
    HTMLResultPath: string
    ancestryThreshold: number
    overlapThreshold: number
    ancestryAdjustment: $Enums.AncestryAdjustmentType
    assembly: $Enums.AssemblyType
    patientId: number
  }

  export type BroadAncestryInRefPopUpdateWithoutReferencePopulationInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    broadAncestryCategory?: BroadAncestryCategoryUpdateOneRequiredWithoutBroadAncestryInRefPopsNestedInput
  }

  export type BroadAncestryInRefPopUncheckedUpdateWithoutReferencePopulationInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    broadAncestryId?: IntFieldUpdateOperationsInput | number
  }

  export type BroadAncestryInRefPopUncheckedUpdateManyWithoutReferencePopulationInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    broadAncestryId?: IntFieldUpdateOperationsInput | number
  }

  export type PRSAnalysisUpdateWithoutReferencePopulationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    HTMLResultPath?: StringFieldUpdateOperationsInput | string
    ancestryThreshold?: IntFieldUpdateOperationsInput | number
    overlapThreshold?: IntFieldUpdateOperationsInput | number
    ancestryAdjustment?: EnumAncestryAdjustmentTypeFieldUpdateOperationsInput | $Enums.AncestryAdjustmentType
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    patient?: PatientUpdateOneRequiredWithoutPrsAnalysesNestedInput
    prioritizedModels?: PrioritizedModelUpdateManyWithoutPrsAnalysisNestedInput
  }

  export type PRSAnalysisUncheckedUpdateWithoutReferencePopulationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    HTMLResultPath?: StringFieldUpdateOperationsInput | string
    ancestryThreshold?: IntFieldUpdateOperationsInput | number
    overlapThreshold?: IntFieldUpdateOperationsInput | number
    ancestryAdjustment?: EnumAncestryAdjustmentTypeFieldUpdateOperationsInput | $Enums.AncestryAdjustmentType
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    patientId?: IntFieldUpdateOperationsInput | number
    prioritizedModels?: PrioritizedModelUncheckedUpdateManyWithoutPrsAnalysisNestedInput
  }

  export type PRSAnalysisUncheckedUpdateManyWithoutReferencePopulationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    HTMLResultPath?: StringFieldUpdateOperationsInput | string
    ancestryThreshold?: IntFieldUpdateOperationsInput | number
    overlapThreshold?: IntFieldUpdateOperationsInput | number
    ancestryAdjustment?: EnumAncestryAdjustmentTypeFieldUpdateOperationsInput | $Enums.AncestryAdjustmentType
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    patientId?: IntFieldUpdateOperationsInput | number
  }

  export type PrioritizedModelCreateManyPrsAnalysisInput = {
    position: number
    prsModelId: number
    prsResultId?: number | null
  }

  export type PrioritizedModelUpdateWithoutPrsAnalysisInput = {
    position?: IntFieldUpdateOperationsInput | number
    prsResultId?: NullableIntFieldUpdateOperationsInput | number | null
    prsResult?: PRSResultUpdateOneWithoutPrioritizedModelNestedInput
    prsModel?: PRSModelUpdateOneRequiredWithoutPrioritizedModelsNestedInput
  }

  export type PrioritizedModelUncheckedUpdateWithoutPrsAnalysisInput = {
    position?: IntFieldUpdateOperationsInput | number
    prsModelId?: IntFieldUpdateOperationsInput | number
    prsResultId?: NullableIntFieldUpdateOperationsInput | number | null
    prsResult?: PRSResultUncheckedUpdateOneWithoutPrioritizedModelNestedInput
  }

  export type PrioritizedModelUncheckedUpdateManyWithoutPrsAnalysisInput = {
    position?: IntFieldUpdateOperationsInput | number
    prsModelId?: IntFieldUpdateOperationsInput | number
    prsResultId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PRSAnalysisCreateManyPatientInput = {
    id?: number
    name: string
    description?: string | null
    userId?: string | null
    date: string
    status: string
    HTMLResultPath: string
    ancestryThreshold: number
    overlapThreshold: number
    ancestryAdjustment: $Enums.AncestryAdjustmentType
    assembly: $Enums.AssemblyType
    referencePopulationId: number
  }

  export type PRSAnalysisUpdateWithoutPatientInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    HTMLResultPath?: StringFieldUpdateOperationsInput | string
    ancestryThreshold?: IntFieldUpdateOperationsInput | number
    overlapThreshold?: IntFieldUpdateOperationsInput | number
    ancestryAdjustment?: EnumAncestryAdjustmentTypeFieldUpdateOperationsInput | $Enums.AncestryAdjustmentType
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    referencePopulation?: ReferencePopulationUpdateOneRequiredWithoutPrsAnalysesNestedInput
    prioritizedModels?: PrioritizedModelUpdateManyWithoutPrsAnalysisNestedInput
  }

  export type PRSAnalysisUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    HTMLResultPath?: StringFieldUpdateOperationsInput | string
    ancestryThreshold?: IntFieldUpdateOperationsInput | number
    overlapThreshold?: IntFieldUpdateOperationsInput | number
    ancestryAdjustment?: EnumAncestryAdjustmentTypeFieldUpdateOperationsInput | $Enums.AncestryAdjustmentType
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    referencePopulationId?: IntFieldUpdateOperationsInput | number
    prioritizedModels?: PrioritizedModelUncheckedUpdateManyWithoutPrsAnalysisNestedInput
  }

  export type PRSAnalysisUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    HTMLResultPath?: StringFieldUpdateOperationsInput | string
    ancestryThreshold?: IntFieldUpdateOperationsInput | number
    overlapThreshold?: IntFieldUpdateOperationsInput | number
    ancestryAdjustment?: EnumAncestryAdjustmentTypeFieldUpdateOperationsInput | $Enums.AncestryAdjustmentType
    assembly?: EnumAssemblyTypeFieldUpdateOperationsInput | $Enums.AssemblyType
    referencePopulationId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}